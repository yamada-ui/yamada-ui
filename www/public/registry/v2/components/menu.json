{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["popover", "icon"],
    "externals": [],
    "hooks": ["use-descendants", "use-disclosure", "use-controllable-state"],
    "providers": []
  },
  "dependents": { "components": ["select"], "hooks": [], "providers": [] },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./menu.style\"\nexport {\n  MenuAnchor,\n  MenuCommand,\n  MenuContent,\n  MenuContextTrigger,\n  MenuFooter,\n  MenuGroup,\n  MenuHeader,\n  MenuIndicator,\n  MenuItem,\n  MenuLabel,\n  MenuOptionGroup,\n  MenuOptionItem,\n  MenuPropsContext,\n  MenuRoot,\n  MenuSeparator,\n  MenuTrigger,\n  useMenuPropsContext,\n} from \"./menu\"\nexport type {\n  MenuAnchorProps,\n  MenuCommandProps,\n  MenuContentProps,\n  MenuContextTriggerProps,\n  MenuFooterProps,\n  MenuGroupProps,\n  MenuHeaderProps,\n  MenuIndicatorProps,\n  MenuItemProps,\n  MenuLabelProps,\n  MenuOptionGroupProps,\n  MenuOptionItemProps,\n  MenuRootProps,\n  MenuSeparatorProps,\n  MenuTriggerProps,\n} from \"./menu\"\nexport * as Menu from \"./namespace\"\nexport * from \"./use-menu\"\n"
    },
    {
      "name": "menu.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\nimport { popoverStyle } from \"../popover\"\n\nexport const menuStyle = defineComponentSlotStyle({\n  base: {\n    command: {\n      textStyle: \"mono\",\n      color: \"fg.muted\",\n      ms: \"auto\",\n    },\n    content: {\n      \"&:has([data-footer])\": {\n        scrollPaddingBottom: \"calc({space} + {footer-height} + {border-width})\",\n      },\n      \"&:has([data-header])\": {\n        scrollPaddingTop: \"calc({space} + {header-height} + {border-width})\",\n      },\n      \"--border-width\": \"1px\",\n      \"--footer-height\": \"{item-height}\",\n      \"--header-height\": \"{item-height}\",\n      gap: \"0\",\n      overflow: \"auto\",\n      p: \"{space}\",\n      scrollPaddingBottom: \"{space}\",\n      scrollPaddingTop: \"{space}\",\n    },\n    footer: {\n      alignItems: \"center\",\n      bg: popoverStyle.base?.content?.bg,\n      borderTopWidth: \"{border-width}\",\n      bottom: \"calc({space} * -1)\",\n      display: \"flex\",\n      left: \"0\",\n      mb: \"calc({space} * -1)\",\n      minH: \"{footer-height}\",\n      mt: \"{space}\",\n      mx: \"calc({space} * -1)\",\n      position: \"sticky\",\n      right: \"0\",\n    },\n    group: {\n      display: \"flex\",\n      flexDirection: \"column\",\n    },\n    header: {\n      alignItems: \"center\",\n      bg: popoverStyle.base?.content?.bg,\n      borderBottomWidth: \"{border-width}\",\n      display: \"flex\",\n      left: \"0\",\n      mb: \"{space}\",\n      minH: \"{header-height}\",\n      mt: \"calc({space} * -1)\",\n      mx: \"calc({space} * -1)\",\n      position: \"sticky\",\n      right: \"0\",\n      top: \"calc({space} * -1)\",\n    },\n    indicator: {\n      alignItems: \"center\",\n      display: \"flex\",\n      justifyContent: \"center\",\n    },\n    item: {\n      alignItems: \"center\",\n      display: \"flex\",\n      focusVisibleRing: \"none\",\n      minH: \"{item-height}\",\n      userSelect: \"none\",\n      _activedescendant: { bg: \"bg.muted/70\" },\n      _disabled: { layerStyle: \"disabled\" },\n    },\n    label: {\n      alignItems: \"center\",\n      display: \"flex\",\n      fontWeight: \"medium\",\n      minH: \"{item-height}\",\n    },\n    separator: {\n      \"& + hr\": { display: \"none\" },\n      \"&:last-child, &:first-child\": { display: \"none\" },\n      borderBottomWidth: \"{border-width}\",\n      mx: \"calc({space} * -1)\",\n      my: \"{space}\",\n    },\n  },\n\n  sizes: {\n    sm: {\n      command: { fontSize: \"2xs\" },\n      content: {\n        \"--item-height\": \"spaces.7\",\n        \"--space\": \"spaces.1\",\n        fontSize: \"xs\",\n        minW: \"3xs\",\n      },\n      footer: { px: \"1.5\" },\n      header: { px: \"1.5\" },\n      indicator: { fontSize: \"sm\" },\n      item: { gap: \"1.5\", px: \"1.5\", rounded: \"l1\" },\n      label: { px: \"1.5\" },\n    },\n    md: {\n      command: { fontSize: \"xs\" },\n      content: {\n        \"--item-height\": \"spaces.8\",\n        \"--space\": \"spaces.1\",\n        fontSize: \"sm\",\n        minW: \"2xs\",\n      },\n      footer: { px: \"2\" },\n      header: { px: \"2\" },\n      indicator: { fontSize: \"md\" },\n      item: { gap: \"2\", px: \"2\", rounded: \"l1\" },\n      label: { px: \"2\" },\n    },\n    lg: {\n      command: { fontSize: \"sm\" },\n      content: {\n        \"--item-height\": \"spaces.9\",\n        \"--space\": \"spaces.1\",\n        fontSize: \"md\",\n        minW: \"2xs\",\n      },\n      footer: { px: \"2\" },\n      header: { px: \"2\" },\n      indicator: { fontSize: \"lg\" },\n      item: { gap: \"2\", px: \"2\", rounded: \"l1\" },\n      label: { px: \"2\" },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n  },\n})\n\nexport type MenuStyle = typeof menuStyle\n"
    },
    {
      "name": "menu.tsx",
      "content": "\"use client\"\n\nimport type { FC, ReactElement, ReactNode } from \"react\"\nimport type {\n  Direction,\n  GenericsComponent,\n  HTMLProps,\n  HTMLStyledProps,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type { MenuStyle } from \"./menu.style\"\nimport type {\n  MenuOptionGroupType,\n  MenuOptionGroupValue,\n  UseMenuGroupProps,\n  UseMenuItemProps,\n  UseMenuOptionGroupProps,\n  UseMenuOptionItemProps,\n  UseMenuProps,\n  UseMenuReturn,\n} from \"./use-menu\"\nimport { Fragment, useMemo, useState } from \"react\"\nimport { createSlotComponent, styled, cast, handlerAll } from \"@yamada-ui/react\"\nimport { CheckIcon, ChevronRightIcon, CircleSmallIcon } from \"../icon\"\nimport { Popover, usePopoverProps } from \"../popover\"\nimport { menuStyle } from \"./menu.style\"\nimport {\n  MainMenuContext,\n  MenuContext,\n  MenuDescendantsContext,\n  MenuGroupContext,\n  MenuOptionGroupContext,\n  useMenu,\n  useMenuContext,\n  useMenuGroup,\n  useMenuGroupContext,\n  useMenuItem,\n  useMenuOptionGroup,\n  useMenuOptionItem,\n} from \"./use-menu\"\n\ninterface MenuSharedItem {\n  label?: ReactNode\n}\n\ninterface MenuItemWithValue extends MenuSharedItem, MenuItemProps {}\n\ninterface MenuOptionItem extends MenuSharedItem, MenuOptionItemProps {}\n\ninterface MenuItemWithSeparator extends MenuSeparatorProps {\n  type: \"separator\"\n}\n\ninterface MenuItemWithRadioGroup<Y extends string = string>\n  extends Omit<MenuItemWithItems, \"defaultValue\" | \"items\" | \"onChange\">,\n    MenuOptionGroupProps<\"radio\", Y> {\n  type: \"radio\"\n  items?: MenuOptionItem[]\n}\n\ninterface MenuItemWithCheckboxGroup<Y extends string[] = string[]>\n  extends Omit<MenuItemWithItems, \"defaultValue\" | \"items\" | \"onChange\">,\n    MenuOptionGroupProps<\"checkbox\", Y> {\n  type: \"checkbox\"\n  items?: MenuOptionItem[]\n}\n\ninterface MenuItemWithItems extends MenuSharedItem, MenuGroupProps {\n  hasEndSeparator?: boolean\n  hasSeparator?: boolean\n  hasStartSeparator?: boolean\n  items?: MenuItemWithValue[]\n  labelProps?: MenuLabelProps\n}\n\ninterface ComponentContext\n  extends Pick<\n    UseMenuReturn,\n    | \"getContentProps\"\n    | \"getContextTriggerProps\"\n    | \"getSeparatorProps\"\n    | \"getTriggerProps\"\n  > {}\n\nexport interface MenuRootProps\n  extends UseMenuProps,\n    Omit<\n      WithoutThemeProps<Popover.RootProps, MenuStyle>,\n      \"autoFocus\" | \"modal\" | \"updateRef\" | \"withCloseButton\"\n    >,\n    ThemeProps<MenuStyle> {\n  /**\n   * The placement of the popper relative to its reference.\n   *\n   * @default 'end-start'\n   */\n  placement?: Direction\n}\n\nconst {\n  ComponentContext,\n  PropsContext: MenuPropsContext,\n  StyleContext,\n  useComponentContext,\n  usePropsContext: useMenuPropsContext,\n  withContext,\n  useRootComponentProps,\n} = createSlotComponent<MenuRootProps, MenuStyle, ComponentContext>(\n  \"menu\",\n  menuStyle,\n)\n\nexport { MenuPropsContext, useMenuPropsContext }\n\n/**\n * `Menu` is a component that displays a common dropdown menu.\n *\n * @see https://yamada-ui.com/components/menu\n */\nexport const MenuRoot: FC<MenuRootProps> = (props) => {\n  const [styleContext, mergedProps] = useRootComponentProps(props)\n  const [\n    { animationScheme, initialFocusRef, offset, placement, ...popoverProps },\n    { children, disabled, ...rest },\n  ] = usePopoverProps(mergedProps, [\n    \"disabled\",\n    \"open\",\n    \"defaultOpen\",\n    \"onOpen\",\n    \"onClose\",\n  ])\n  const {\n    closeOnSelect,\n    descendants,\n    open,\n    subMenu,\n    subMenuDirection,\n    updateRef,\n    getContentProps,\n    getContextTriggerProps,\n    getSeparatorProps,\n    getTriggerProps,\n    onActiveDescendant,\n    onClose,\n    onCloseRef,\n    onCloseSubMenu,\n    onOpen,\n    onSelect,\n  } = useMenu({ disabled, ...rest })\n  const mergedPopoverProps = useMemo<Popover.RootProps>(\n    () => ({\n      ...popoverProps,\n      animationScheme:\n        animationScheme ?? (subMenu ? \"inline-start\" : \"block-start\"),\n      autoFocus: !!initialFocusRef,\n      disabled,\n      initialFocusRef,\n      offset: offset ?? (subMenu ? [0, 0] : undefined),\n      open,\n      placement:\n        placement ?? (subMenu ? `center-${subMenuDirection}` : \"end-start\"),\n      updateRef,\n      onClose,\n      onOpen,\n    }),\n    [\n      animationScheme,\n      disabled,\n      initialFocusRef,\n      offset,\n      onClose,\n      onOpen,\n      open,\n      placement,\n      popoverProps,\n      subMenu,\n      subMenuDirection,\n      updateRef,\n    ],\n  )\n  const menuContext = useMemo(\n    () => ({\n      subMenu,\n      subMenuDirection,\n      onActiveDescendant,\n      onClose,\n      onCloseSubMenu,\n      onOpen,\n      onSelect,\n    }),\n    [\n      onClose,\n      onOpen,\n      onSelect,\n      onActiveDescendant,\n      subMenu,\n      subMenuDirection,\n      onCloseSubMenu,\n    ],\n  )\n  const mainMenuContext = useMemo(\n    () => ({\n      closeOnSelect,\n      descendants,\n      onActiveDescendant,\n      onCloseRef,\n      onSelect,\n    }),\n    [closeOnSelect, descendants, onActiveDescendant, onCloseRef, onSelect],\n  )\n  const componentContext = useMemo(\n    () => ({\n      getContentProps,\n      getContextTriggerProps,\n      getSeparatorProps,\n      getTriggerProps,\n    }),\n    [\n      getContentProps,\n      getContextTriggerProps,\n      getSeparatorProps,\n      getTriggerProps,\n    ],\n  )\n\n  return (\n    <StyleContext value={styleContext}>\n      <MenuDescendantsContext value={descendants}>\n        <MenuContext value={menuContext}>\n          <MainMenuContext value={mainMenuContext}>\n            <ComponentContext value={componentContext}>\n              <Popover.Root {...mergedPopoverProps}>{children}</Popover.Root>\n            </ComponentContext>\n          </MainMenuContext>\n        </MenuContext>\n      </MenuDescendantsContext>\n    </StyleContext>\n  )\n}\n\nexport interface MenuTriggerProps extends Popover.TriggerProps {}\n\nexport const MenuTrigger = withContext<\"button\", MenuTriggerProps>(\n  Popover.Trigger,\n  \"trigger\",\n)(undefined, (props) => {\n  const { getTriggerProps } = useComponentContext()\n\n  return cast<HTMLProps<\"button\">>(getTriggerProps(cast<HTMLProps>(props)))\n})\n\ninterface Rect {\n  left: number\n  top: number\n}\n\nexport interface MenuContextTriggerProps extends HTMLProps {}\n\nexport const MenuContextTrigger = withContext<\"div\", MenuContextTriggerProps>(\n  ({ children, onContextMenu, ...rest }) => {\n    const [rect, setRect] = useState<Rect>({\n      left: 0,\n      top: 0,\n    })\n    const { getContextTriggerProps } = useComponentContext()\n\n    return (\n      <>\n        <MenuAnchor>\n          <styled.div style={{ position: \"absolute\", ...rect }} />\n        </MenuAnchor>\n\n        <styled.div\n          asChild\n          {...getContextTriggerProps({\n            onContextMenu: handlerAll(onContextMenu, (ev) => {\n              setRect({ left: ev.pageX, top: ev.pageY })\n            }),\n            ...rest,\n          })}\n        >\n          {children}\n        </styled.div>\n      </>\n    )\n  },\n  \"contextTrigger\",\n)()\n\nexport interface MenuAnchorProps extends Popover.AnchorProps {}\n\nexport const MenuAnchor = withContext<\"div\", MenuAnchorProps>(\n  Popover.Anchor,\n  \"anchor\",\n)()\n\nexport interface MenuContentProps extends Popover.ContentProps {\n  /**\n   * The footer of the menu.\n   */\n  footer?: ReactNode\n  /**\n   * The header of the menu.\n   */\n  header?: ReactNode\n  /**\n   * If provided, generate elements based on items.\n   */\n  items?: (\n    | MenuItemWithCheckboxGroup\n    | MenuItemWithItems\n    | MenuItemWithRadioGroup\n    | MenuItemWithSeparator\n    | MenuItemWithValue\n  )[]\n  /**\n   * Props for the footer component.\n   */\n  footerProps?: MenuFooterProps\n  /**\n   * Props for the header component.\n   */\n  headerProps?: MenuHeaderProps\n}\n\nexport const MenuContent = withContext<\"div\", MenuContentProps>(\n  Popover.Content,\n  \"content\",\n)(\n  undefined,\n  ({\n    children,\n    footer,\n    header,\n    items = [],\n    footerProps,\n    headerProps,\n    portalProps,\n    ...rest\n  }) => {\n    const { subMenu } = useMenuContext()\n    const { getContentProps } = useComponentContext()\n    const computedChildren = useMemo(() => {\n      if (children) return children\n\n      return (\n        <>\n          {header ? <MenuHeader {...headerProps}>{header}</MenuHeader> : null}\n\n          {items.map((props, index) => {\n            if (\"type\" in props) {\n              if (props.type === \"radio\") {\n                const {\n                  type,\n                  hasSeparator = true,\n                  hasEndSeparator = hasSeparator,\n                  hasStartSeparator = hasSeparator,\n                  items = [],\n                  ...rest\n                } = props\n\n                return (\n                  <Fragment key={index}>\n                    {hasStartSeparator ? <MenuSeparator /> : null}\n\n                    <MenuOptionGroup type={type} {...rest}>\n                      {items.map(({ label, ...rest }, index) => (\n                        <MenuOptionItem key={index} {...rest}>\n                          {label}\n                        </MenuOptionItem>\n                      ))}\n                    </MenuOptionGroup>\n\n                    {hasEndSeparator ? <MenuSeparator /> : null}\n                  </Fragment>\n                )\n              } else if (props.type === \"checkbox\") {\n                const {\n                  type,\n                  hasSeparator = true,\n                  hasEndSeparator = hasSeparator,\n                  hasStartSeparator = hasSeparator,\n                  items = [],\n                  ...rest\n                } = props\n\n                return (\n                  <Fragment key={index}>\n                    {hasStartSeparator ? <MenuSeparator /> : null}\n\n                    <MenuOptionGroup type={type} {...rest}>\n                      {items.map(({ label, ...rest }, index) => (\n                        <MenuOptionItem key={index} {...rest}>\n                          {label}\n                        </MenuOptionItem>\n                      ))}\n                    </MenuOptionGroup>\n\n                    {hasEndSeparator ? <MenuSeparator /> : null}\n                  </Fragment>\n                )\n              } else {\n                return <MenuSeparator key={index} />\n              }\n            } else if (\"items\" in props) {\n              const {\n                hasSeparator = true,\n                hasEndSeparator = hasSeparator,\n                hasStartSeparator = hasSeparator,\n                items = [],\n                ...rest\n              } = props\n\n              return (\n                <Fragment key={index}>\n                  {hasStartSeparator ? <MenuSeparator /> : null}\n\n                  <MenuGroup {...rest}>\n                    {items.map(({ label, ...rest }, index) => (\n                      <MenuItem key={index} {...rest}>\n                        {label}\n                      </MenuItem>\n                    ))}\n                  </MenuGroup>\n\n                  {hasEndSeparator ? <MenuSeparator /> : null}\n                </Fragment>\n              )\n            } else if (\"value\" in props) {\n              const { label, ...rest } = props\n\n              return (\n                <MenuItem key={index} {...rest}>\n                  {label}\n                </MenuItem>\n              )\n            }\n          })}\n\n          {footer ? <MenuFooter {...footerProps}>{footer}</MenuFooter> : null}\n        </>\n      )\n    }, [children, footer, footerProps, header, headerProps, items])\n\n    return {\n      ...getContentProps(\n        cast<HTMLProps>({ ...rest, children: computedChildren }),\n      ),\n      portalProps: subMenu ? { ...portalProps, disabled: true } : portalProps,\n    }\n  },\n)\n\nexport interface MenuHeaderProps extends HTMLStyledProps {}\n\nexport const MenuHeader = withContext<\"div\", MenuHeaderProps>(\n  \"div\",\n  \"header\",\n)({ \"data-header\": \"\" })\n\nexport interface MenuFooterProps extends HTMLStyledProps {}\n\nexport const MenuFooter = withContext<\"div\", MenuFooterProps>(\n  \"div\",\n  \"footer\",\n)({ \"data-footer\": \"\" })\n\nexport interface MenuLabelProps extends HTMLStyledProps<\"span\"> {}\n\nexport const MenuLabel = withContext<\"span\", MenuLabelProps>(\"span\", \"label\")(\n  undefined,\n  (props) => {\n    const { getLabelProps } = useMenuGroupContext()\n\n    return getLabelProps(props)\n  },\n)\n\nexport interface MenuGroupProps extends UseMenuGroupProps, HTMLStyledProps {\n  /**\n   * The label of the group.\n   */\n  label?: ReactNode\n  /**\n   * Props for the label component.\n   */\n  labelProps?: MenuLabelProps\n}\n\nexport const MenuGroup = withContext<\"div\", MenuGroupProps>(\n  ({ children, label, labelProps, ...rest }) => {\n    const { getGroupProps, getLabelProps } = useMenuGroup(rest)\n    const context = useMemo(() => ({ getLabelProps }), [getLabelProps])\n\n    return (\n      <MenuGroupContext value={context}>\n        <styled.div {...getGroupProps()}>\n          {label ? <MenuLabel {...labelProps}>{label}</MenuLabel> : null}\n          {children}\n        </styled.div>\n      </MenuGroupContext>\n    )\n  },\n  \"group\",\n)()\n\nexport interface MenuOptionGroupProps<\n  Y extends MenuOptionGroupType = \"checkbox\",\n  M extends MenuOptionGroupValue<Y> = MenuOptionGroupValue<Y>,\n> extends UseMenuOptionGroupProps<Y, M>,\n    Omit<MenuGroupProps, \"defaultValue\" | \"onChange\"> {}\n\nexport const MenuOptionGroup = withContext<\"div\", MenuOptionGroupProps>(\n  ({\n    type: typeProp,\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n    ...rest\n  }) => {\n    const { type, value, onChange } = useMenuOptionGroup({\n      type: typeProp,\n      defaultValue,\n      value: valueProp,\n      onChange: onChangeProp,\n    })\n    const context = useMemo(\n      () => ({ type, value, onChange }),\n      [type, value, onChange],\n    )\n\n    return (\n      <MenuOptionGroupContext value={context}>\n        <MenuGroup {...rest} />\n      </MenuOptionGroupContext>\n    )\n  },\n  { name: \"optionGroup\", slot: [\"group\", \"option\"] },\n)() as GenericsComponent<{\n  <\n    Y extends MenuOptionGroupType = \"checkbox\",\n    M extends MenuOptionGroupValue<Y> = MenuOptionGroupValue<Y>,\n  >(\n    props: MenuOptionGroupProps<Y, M>,\n  ): ReactElement\n}>\n\nexport interface MenuItemProps extends HTMLStyledProps, UseMenuItemProps {}\n\nexport const MenuItem = withContext<\"div\", MenuItemProps>(\n  ({ children, ...rest }) => {\n    const { subMenuTrigger, getItemProps } = useMenuItem(rest)\n\n    return (\n      <styled.div {...getItemProps()}>\n        {children}\n\n        {subMenuTrigger ? (\n          <MenuIndicator as={ChevronRightIcon} ms=\"auto\" />\n        ) : null}\n      </styled.div>\n    )\n  },\n  \"item\",\n)()\n\nexport interface MenuOptionItemProps\n  extends HTMLStyledProps,\n    UseMenuOptionItemProps {\n  /**\n   * The icon to be used in the menu option item.\n   */\n  icon?: ReactNode\n}\n\nexport const MenuOptionItem = withContext<\"div\", MenuOptionItemProps>(\n  ({ children, icon, ...rest }) => {\n    const { type, getIndicatorProps, getOptionItemProps } =\n      useMenuOptionItem(rest)\n\n    return (\n      <styled.div {...getOptionItemProps()}>\n        <MenuIndicator {...getIndicatorProps()}>\n          {icon ||\n            (type === \"radio\" ? (\n              <CircleSmallIcon fill=\"currentColor\" />\n            ) : (\n              <CheckIcon />\n            ))}\n        </MenuIndicator>\n        {children}\n      </styled.div>\n    )\n  },\n  { name: \"optionItem\", slot: [\"item\", \"option\"] },\n)()\n\nexport interface MenuIndicatorProps extends HTMLStyledProps {}\n\nexport const MenuIndicator = withContext<\"div\", MenuIndicatorProps>(\n  \"div\",\n  \"indicator\",\n)()\n\nexport interface MenuCommandProps extends HTMLStyledProps<\"kbd\"> {}\n\nexport const MenuCommand = withContext<\"kbd\", MenuCommandProps>(\n  \"kbd\",\n  \"command\",\n)()\n\nexport interface MenuSeparatorProps extends HTMLStyledProps<\"hr\"> {}\n\nexport const MenuSeparator = withContext<\"hr\", MenuSeparatorProps>(\n  \"hr\",\n  \"separator\",\n)(undefined, (props) => {\n  const { getSeparatorProps } = useComponentContext()\n\n  return getSeparatorProps(props)\n})\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  MenuAnchor as Anchor,\n  MenuCommand as Command,\n  MenuContent as Content,\n  MenuContextTrigger as ContextTrigger,\n  MenuFooter as Footer,\n  MenuGroup as Group,\n  MenuHeader as Header,\n  MenuIndicator as Indicator,\n  MenuItem as Item,\n  MenuLabel as Label,\n  MenuOptionGroup as OptionGroup,\n  MenuOptionItem as OptionItem,\n  MenuPropsContext as PropsContext,\n  MenuRoot as Root,\n  MenuSeparator as Separator,\n  MenuTrigger as Trigger,\n  useMenuPropsContext as usePropsContext,\n} from \"./menu\"\nexport type {\n  MenuAnchorProps as AnchorProps,\n  MenuCommandProps as CommandProps,\n  MenuContentProps as ContentProps,\n  MenuContextTriggerProps as ContextTriggerProps,\n  MenuFooterProps as FooterProps,\n  MenuGroupProps as GroupProps,\n  MenuHeaderProps as HeaderProps,\n  MenuIndicatorProps as IndicatorProps,\n  MenuItemProps as ItemProps,\n  MenuLabelProps as LabelProps,\n  MenuOptionGroupProps as OptionGroupProps,\n  MenuOptionItemProps as OptionItemProps,\n  MenuRootProps as RootProps,\n  MenuSeparatorProps as SeparatorProps,\n  MenuTriggerProps as TriggerProps,\n} from \"./menu\"\n"
    },
    {
      "name": "use-menu.ts",
      "content": "\"use client\"\n\nimport type { KeyboardEvent, MouseEvent, RefObject } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type { Descendant, Descendants } from \"../../hooks/use-descendants\"\nimport type { UseDisclosureProps } from \"../../hooks/use-disclosure\"\nimport { useCallback, useId, useRef } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { createDescendants } from \"../../hooks/use-descendants\"\nimport { useDisclosure } from \"../../hooks/use-disclosure\"\nimport {\n  ariaAttr,\n  assignRef,\n  createContext,\n  cx,\n  dataAttr,\n  handlerAll,\n  isArray,\n  isString,\n  isTruthyDataAttr,\n  mergeRefs,\n  noop,\n  runKeyAction,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\n\ntype SubMenuDirection = \"end\" | \"start\"\n\ninterface MenuDescendantProps {\n  id: string\n}\ntype MenuDescendant = Descendant<HTMLDivElement, MenuDescendantProps>\n\nconst {\n  DescendantsContext: MenuDescendantsContext,\n  useDescendant: useMenuDescendant,\n  useDescendantRegister: useMenuDescendantRegister,\n  useDescendants: useMenuDescendants,\n} = createDescendants<HTMLDivElement, MenuDescendantProps>()\n\nexport { MenuDescendantsContext, useMenuDescendant, useMenuDescendants }\n\ninterface MenuContext\n  extends Pick<\n    UseMenuReturn,\n    | \"onActiveDescendant\"\n    | \"onClose\"\n    | \"onCloseSubMenu\"\n    | \"onOpen\"\n    | \"onSelect\"\n    | \"subMenu\"\n    | \"subMenuDirection\"\n  > {}\n\nconst [MenuContext, useMenuContext] = createContext<MenuContext>({\n  name: \"MenuContext\",\n})\n\ninterface MenuGroupContext extends Pick<UseMenuGroupReturn, \"getLabelProps\"> {}\n\nconst [MenuGroupContext, useMenuGroupContext] = createContext<MenuGroupContext>(\n  {\n    name: \"MenuGroupContext\",\n  },\n)\n\ninterface MainMenuContext {\n  descendants: Descendants<HTMLDivElement, MenuDescendantProps>\n  onActiveDescendant: (descendant?: MenuDescendant) => void\n  onCloseRef: RefObject<() => void>\n  onSelect: (value?: string, closeOnSelect?: boolean) => void\n  closeOnSelect?: boolean\n}\n\nconst [MainMenuContext, useMainMenuContext] = createContext<MainMenuContext>({\n  name: \"MainMenuContext\",\n  strict: false,\n})\n\ninterface MenuOptionGroupContext {\n  type: \"checkbox\" | \"radio\"\n  value: string | string[]\n  onChange?: (value: string) => void\n}\n\nconst [MenuOptionGroupContext, useMenuOptionGroupContext] =\n  createContext<MenuOptionGroupContext>({\n    name: \"MenuOptionGroupContext\",\n  })\n\nexport {\n  MainMenuContext,\n  MenuContext,\n  MenuGroupContext,\n  MenuOptionGroupContext,\n  useMainMenuContext,\n  useMenuContext,\n  useMenuGroupContext,\n  useMenuOptionGroupContext,\n}\n\nexport interface UseMenuProps extends Omit<UseDisclosureProps, \"timing\"> {\n  /**\n   * If `true`, the menu item will be closed when selected.\n   *\n   * @default true\n   */\n  closeOnSelect?: boolean\n  /**\n   * If `true`, the menu will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * The direction of the sub menu.\n   *\n   * @default 'end'\n   */\n  subMenuDirection?: SubMenuDirection\n  /**\n   * Callback invoked when a menu item is selected.\n   */\n  onSelect?: (value?: string) => void\n}\n\nexport const useMenu = ({\n  closeOnSelect,\n  defaultOpen,\n  disabled = false,\n  open: openProp,\n  subMenuDirection = \"end\",\n  onClose: onCloseProp,\n  onOpen: onOpenProp,\n  onSelect: onSelectProp,\n}: UseMenuProps = {}) => {\n  const triggerId = useId()\n  const contentId = useId()\n  const descendants = useMenuDescendants()\n  const updateRef = useRef<() => void>(noop)\n  const onCloseRef = useRef<() => void>(noop)\n  const contentRef = useRef<HTMLDivElement>(null)\n  const { open, onClose, onOpen } = useDisclosure({\n    defaultOpen,\n    open: openProp,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n  })\n  const onCloseSubMenu = useCallback(() => onCloseRef.current(), [])\n  const onActiveDescendant = useCallback(\n    (\n      descendant?: MenuDescendant,\n      options: FocusOptions = { preventScroll: true },\n    ) => {\n      if (!contentRef.current || !descendant || disabled) return\n\n      contentRef.current.setAttribute(\"aria-activedescendant\", descendant.id)\n\n      descendants.active(descendant, options)\n    },\n    [descendants, disabled],\n  )\n  const { mainCloseOnSelect, subMenu, getSubMenuProps, onMainSelect } =\n    useSubMenu({\n      descendants,\n      disabled,\n      open,\n      subMenuDirection,\n      onActiveDescendant,\n      onClose,\n      onOpen,\n    })\n\n  closeOnSelect ??= mainCloseOnSelect ?? true\n\n  const onSelect = useCallback(\n    (value?: string, closeOnSelectProp = closeOnSelect) => {\n      if (disabled) return\n\n      onSelectProp?.(value)\n      onMainSelect?.(value, closeOnSelectProp)\n\n      if (!closeOnSelectProp) return\n\n      onClose()\n    },\n    [closeOnSelect, disabled, onClose, onMainSelect, onSelectProp],\n  )\n\n  const onClick = useCallback(\n    (ev: MouseEvent<HTMLDivElement>) => {\n      if (disabled) return\n\n      ev.preventDefault()\n\n      if (!open) {\n        onOpen()\n      } else {\n        onClose()\n      }\n    },\n    [disabled, onClose, onOpen, open],\n  )\n\n  const onContextMenu = useCallback(\n    (ev: MouseEvent<HTMLDivElement>) => {\n      if (disabled) return\n\n      ev.preventDefault()\n      onOpen()\n      updateRef.current()\n    },\n    [disabled, onOpen],\n  )\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLDivElement>) => {\n      if (disabled) return\n\n      runKeyAction(ev, {\n        ArrowDown: () => {\n          onOpen()\n\n          setTimeout(() => {\n            const descendant = descendants.enabledFirstValue()\n\n            onActiveDescendant(descendant)\n          })\n        },\n        ArrowUp: () => {\n          onOpen()\n\n          setTimeout(() => {\n            const descendant = descendants.enabledLastValue()\n\n            onActiveDescendant(descendant)\n          })\n        },\n        Enter: () => {\n          onOpen()\n\n          setTimeout(() => {\n            const descendant = descendants.enabledFirstValue()\n\n            onActiveDescendant(descendant)\n          })\n        },\n        Space: () => {\n          onOpen()\n\n          setTimeout(() => {\n            const descendant = descendants.enabledFirstValue()\n\n            onActiveDescendant(descendant)\n          })\n        },\n      })\n    },\n    [descendants, disabled, onActiveDescendant, onOpen],\n  )\n\n  const getTriggerProps: PropGetter = useCallback(\n    (props = {}) => ({\n      ...getSubMenuProps({\n        id: triggerId,\n        \"aria-controls\": open ? contentId : undefined,\n        \"aria-disabled\": ariaAttr(disabled),\n        \"aria-expanded\": open,\n        \"aria-haspopup\": \"menu\",\n        \"data-trigger\": dataAttr(true),\n        role: \"button\",\n        tabIndex: disabled ? -1 : 0,\n        ...props,\n        onClick: handlerAll(props.onClick, onClick),\n        onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n      }),\n    }),\n    [contentId, disabled, getSubMenuProps, onClick, onKeyDown, open, triggerId],\n  )\n\n  const getContextTriggerProps: PropGetter = useCallback(\n    (props = {}) => ({\n      id: triggerId,\n      \"aria-controls\": open ? contentId : undefined,\n      \"aria-disabled\": ariaAttr(disabled),\n      \"aria-expanded\": open,\n      \"aria-haspopup\": \"menu\",\n      \"data-trigger\": dataAttr(true),\n      role: \"application\",\n      ...props,\n      onContextMenu: handlerAll(props.onContextMenu, onContextMenu),\n    }),\n    [contentId, disabled, onContextMenu, open, triggerId],\n  )\n\n  const getContentProps: PropGetter = useCallback(\n    ({ ref, \"aria-labelledby\": ariaLabelledby, ...props } = {}) => ({\n      id: contentId,\n      \"aria-labelledby\": cx(ariaLabelledby, triggerId),\n      role: \"menu\",\n      ...props,\n      ref: mergeRefs(ref, contentRef),\n    }),\n    [contentId, triggerId],\n  )\n\n  const getSeparatorProps: PropGetter = useCallback(\n    (props) => ({ role: \"separator\", ...props }),\n    [],\n  )\n\n  return {\n    closeOnSelect,\n    descendants,\n    open,\n    subMenu,\n    subMenuDirection,\n    updateRef,\n    getContentProps,\n    getContextTriggerProps,\n    getSeparatorProps,\n    getTriggerProps,\n    onActiveDescendant,\n    onClose,\n    onCloseRef,\n    onCloseSubMenu,\n    onOpen,\n    onSelect,\n  }\n}\n\nexport type UseMenuReturn = ReturnType<typeof useMenu>\n\nexport interface UseSubMenuProps\n  extends Omit<Required<UseDisclosureProps>, \"defaultOpen\" | \"timing\"> {\n  descendants: Descendants<HTMLDivElement, MenuDescendantProps>\n  onActiveDescendant: (descendant?: MenuDescendant) => void\n  disabled?: boolean\n  subMenuDirection?: SubMenuDirection\n}\n\nexport const useSubMenu = ({\n  descendants,\n  disabled = false,\n  open,\n  subMenuDirection = \"end\",\n  onActiveDescendant,\n  onClose,\n  onOpen,\n}: UseSubMenuProps) => {\n  const uuid = useId()\n  const {\n    closeOnSelect: mainCloseOnSelect,\n    descendants: mainDescendants,\n    onActiveDescendant: onActiveMainDescendant,\n    onCloseRef,\n    onSelect: onMainSelect,\n  } = useMainMenuContext() ?? {}\n  const subMenu = !!mainDescendants && !!onActiveMainDescendant\n  const createRegister = useMenuDescendantRegister(mainDescendants)\n  const triggerRef = useRef<HTMLDivElement>(null)\n\n  const dataDisabled = useCallback((node?: HTMLDivElement | null) => {\n    node ??= triggerRef.current\n\n    if (!node) return false\n\n    const dataDisabled = isTruthyDataAttr(node.getAttribute(\"data-disabled\"))\n\n    return dataDisabled\n  }, [])\n\n  const ariaDisabled = useCallback((node?: HTMLDivElement | null) => {\n    node ??= triggerRef.current\n\n    if (!node) return false\n\n    const ariaDisabled = isTruthyDataAttr(node.getAttribute(\"aria-disabled\"))\n\n    return ariaDisabled\n  }, [])\n\n  const onClick = useCallback(\n    (ev: MouseEvent<HTMLDivElement>) => {\n      if (!subMenu) return\n\n      ev.defaultPrevented = disabled || dataDisabled() || ariaDisabled()\n    },\n    [ariaDisabled, dataDisabled, disabled, subMenu],\n  )\n\n  const onMouseEnter = useCallback(() => {\n    if (!subMenu || disabled || dataDisabled() || ariaDisabled()) return\n\n    onOpen()\n  }, [ariaDisabled, dataDisabled, disabled, onOpen, subMenu])\n\n  const onMouseMove = useCallback(\n    (ev: MouseEvent<HTMLDivElement>) => {\n      if (!subMenu || disabled || dataDisabled() || ariaDisabled()) return\n\n      const descendant = descendants.value(triggerRef.current)\n\n      onActiveMainDescendant(descendant)\n\n      ev.defaultPrevented = true\n    },\n    [\n      ariaDisabled,\n      dataDisabled,\n      descendants,\n      disabled,\n      onActiveMainDescendant,\n      subMenu,\n    ],\n  )\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLDivElement>) => {\n      if (!subMenu || disabled) return\n\n      const currentDescendant = open ? descendants : mainDescendants\n      const onActiveCurrentDescendant = open\n        ? onActiveDescendant\n        : onActiveMainDescendant\n\n      runKeyAction(ev, {\n        ArrowDown: () => {\n          const descendant = currentDescendant.enabledNextValue(\n            triggerRef.current,\n          )\n\n          onActiveCurrentDescendant(descendant)\n\n          ev.defaultPrevented = true\n        },\n        ArrowUp: () => {\n          const descendant = currentDescendant.enabledPrevValue(\n            triggerRef.current,\n          )\n\n          onActiveCurrentDescendant(descendant)\n\n          ev.defaultPrevented = true\n        },\n        End: () => {\n          const descendant = currentDescendant.enabledLastValue()\n\n          onActiveCurrentDescendant(descendant)\n\n          ev.defaultPrevented = true\n        },\n        Home: () => {\n          const descendant = currentDescendant.enabledFirstValue()\n\n          onActiveCurrentDescendant(descendant)\n\n          ev.defaultPrevented = true\n        },\n        [subMenuDirection === \"end\" ? \"ArrowRight\" : \"ArrowLeft\"]: () => {\n          onOpen()\n\n          setTimeout(() => {\n            const descendant = descendants.enabledFirstValue()\n\n            onActiveDescendant(descendant)\n          })\n\n          ev.defaultPrevented = true\n        },\n      })\n    },\n    [\n      subMenu,\n      disabled,\n      open,\n      descendants,\n      mainDescendants,\n      onActiveDescendant,\n      onActiveMainDescendant,\n      subMenuDirection,\n      onOpen,\n    ],\n  )\n\n  assignRef(onCloseRef, onClose)\n\n  const getSubMenuProps: PropGetter = useCallback(\n    ({ id = uuid, ref, ...props } = {}) => {\n      const getDisabled = (node: HTMLDivElement) =>\n        disabled || dataDisabled(node) || ariaDisabled(node)\n      const register = createRegister({ id, disabled: getDisabled })\n\n      return {\n        role: subMenu ? \"menuitem\" : \"button\",\n        ...props,\n        ref: mergeRefs(ref, triggerRef, register),\n        onClick: handlerAll(onClick, props.onClick),\n        onKeyDown: handlerAll(onKeyDown, props.onKeyDown),\n        onMouseEnter: handlerAll(onMouseEnter, props.onMouseEnter),\n        onMouseMove: handlerAll(onMouseMove, props.onMouseMove),\n      }\n    },\n    [\n      uuid,\n      subMenu,\n      createRegister,\n      onClick,\n      onKeyDown,\n      onMouseEnter,\n      onMouseMove,\n      disabled,\n      dataDisabled,\n      ariaDisabled,\n    ],\n  )\n\n  return { mainCloseOnSelect, subMenu, getSubMenuProps, onMainSelect }\n}\n\nexport type UseSubMenuReturn = ReturnType<typeof useSubMenu>\n\nexport interface UseMenuGroupProps extends HTMLProps {}\n\nexport const useMenuGroup = ({\n  \"aria-labelledby\": ariaLabelledbyProp,\n  ...rest\n}: UseMenuGroupProps) => {\n  const labelId = useId()\n\n  const getGroupProps: PropGetter = useCallback(\n    ({ \"aria-labelledby\": ariaLabelledby, ...props } = {}) => ({\n      \"aria-labelledby\": cx(ariaLabelledbyProp, ariaLabelledby, labelId),\n      role: \"group\",\n      ...rest,\n      ...props,\n    }),\n    [ariaLabelledbyProp, labelId, rest],\n  )\n\n  const getLabelProps: PropGetter<\"span\"> = useCallback(\n    (props) => ({ id: labelId, role: \"presentation\", ...props }),\n    [labelId],\n  )\n\n  return { getGroupProps, getLabelProps }\n}\n\nexport type UseMenuGroupReturn = ReturnType<typeof useMenuGroup>\n\nexport interface UseMenuItemProps extends HTMLProps {\n  /**\n   * If `true`, the menu item will be closed when selected.\n   */\n  closeOnSelect?: boolean\n  /**\n   * If `true`, the menu item will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * The value of the menu item.\n   */\n  value?: string\n}\n\nexport const useMenuItem = ({\n  id,\n  \"aria-disabled\": ariaDisabled,\n  \"data-disabled\": dataDisabled,\n  \"data-trigger\": dataTrigger,\n  closeOnSelect,\n  disabled = false,\n  value,\n  ...rest\n}: UseMenuItemProps) => {\n  const trigger = isTruthyDataAttr(dataTrigger)\n  const {\n    subMenu,\n    subMenuDirection,\n    onActiveDescendant,\n    onClose,\n    onCloseSubMenu,\n    onSelect,\n  } = useMenuContext()\n  const uuid = useId()\n  const itemRef = useRef<HTMLDivElement>(null)\n  const subMenuTrigger = subMenu && trigger\n\n  id ??= uuid\n\n  const { descendants, register } = useMenuDescendant({\n    id,\n    disabled: disabled || subMenuTrigger,\n  })\n\n  const onActive = useCallback(() => {\n    if (disabled) return\n\n    const descendant = descendants.value(itemRef.current)\n\n    onActiveDescendant(descendant)\n  }, [descendants, disabled, onActiveDescendant])\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLDivElement>) => {\n      runKeyAction(ev, {\n        ArrowDown: () => {\n          const descendant = descendants.enabledNextValue(itemRef.current)\n\n          onActiveDescendant(descendant)\n        },\n        ArrowUp: () => {\n          const descendant = descendants.enabledPrevValue(itemRef.current)\n\n          onActiveDescendant(descendant)\n        },\n        End: () => {\n          const descendant = descendants.enabledLastValue()\n\n          onActiveDescendant(descendant)\n        },\n        Enter: () => onSelect(value, closeOnSelect),\n        Home: () => {\n          const descendant = descendants.enabledFirstValue()\n\n          onActiveDescendant(descendant)\n        },\n        Space: () => onSelect(value, closeOnSelect),\n        [subMenuDirection === \"end\" ? \"ArrowLeft\" : \"ArrowRight\"]: () => {\n          if (!subMenu) return\n\n          onClose()\n\n          const descendant = descendants.firstValue()\n\n          descendant?.node.focus()\n        },\n      })\n    },\n    [\n      closeOnSelect,\n      descendants,\n      onActiveDescendant,\n      onClose,\n      onSelect,\n      subMenu,\n      subMenuDirection,\n      value,\n    ],\n  )\n\n  const getItemProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      id,\n      \"aria-disabled\": ariaDisabled ?? ariaAttr(disabled),\n      \"data-disabled\": dataDisabled ?? dataAttr(disabled),\n      role: \"menuitem\",\n      tabIndex: -1,\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref, itemRef, register),\n      onClick: handlerAll(props.onClick, rest.onClick, () =>\n        onSelect(value, closeOnSelect),\n      ),\n      onFocus: handlerAll(props.onFocus, rest.onFocus, onActive),\n      onKeyDown: handlerAll(props.onKeyDown, rest.onKeyDown, onKeyDown),\n      onMouseMove: handlerAll(props.onMouseMove, rest.onMouseMove, () => {\n        onCloseSubMenu()\n        onActive()\n      }),\n    }),\n    [\n      id,\n      ariaDisabled,\n      disabled,\n      dataDisabled,\n      rest,\n      register,\n      onActive,\n      onKeyDown,\n      onSelect,\n      value,\n      closeOnSelect,\n      onCloseSubMenu,\n    ],\n  )\n\n  return {\n    subMenuTrigger,\n    getItemProps,\n  }\n}\n\nexport type UseMenuItemReturn = ReturnType<typeof useMenuItem>\n\nexport type MenuOptionGroupType = \"checkbox\" | \"radio\"\nexport type MenuOptionGroupValue<Y extends MenuOptionGroupType> =\n  Y extends \"checkbox\" ? string[] : string\n\nexport interface UseMenuOptionGroupProps<\n  Y extends MenuOptionGroupType = \"checkbox\",\n  M extends MenuOptionGroupValue<Y> = MenuOptionGroupValue<Y>,\n> {\n  /**\n   * The type of the menu option group.\n   */\n  type?: Y\n  /**\n   * The initial value of the menu item group.\n   */\n  defaultValue?: M\n  /**\n   * The value of the menu item group.\n   */\n  value?: M\n  /**\n   * The callback fired when any children checkbox is checked or unchecked.\n   */\n  onChange?: (value: M) => void\n}\n\nexport const useMenuOptionGroup = <\n  Y extends \"checkbox\" | \"radio\" = \"checkbox\",\n  M extends Y extends \"checkbox\" ? string[] : string = Y extends \"checkbox\"\n    ? string[]\n    : string,\n>({\n  type = \"checkbox\" as Y,\n  defaultValue = (type === \"checkbox\" ? [] : \"\") as M,\n  value: valueProp,\n  onChange: onChangeProp,\n}: UseMenuOptionGroupProps<Y, M>) => {\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const radio = type === \"radio\"\n\n  const onChange = useCallback(\n    (selectedValue: string) => {\n      setValue((prev) => {\n        if (radio && isString(prev)) {\n          return selectedValue as M\n        } else if (!radio && isArray(prev)) {\n          return (\n            prev.includes(selectedValue)\n              ? prev.filter((value) => value !== selectedValue)\n              : prev.concat(selectedValue)\n          ) as M\n        } else {\n          return prev\n        }\n      })\n    },\n    [radio, setValue],\n  )\n\n  useUpdateEffect(() => {\n    setValue(valueProp!)\n  }, [valueProp])\n\n  return {\n    type,\n    value,\n    onChange,\n  }\n}\n\nexport type UseMenuOptionGroupReturn = ReturnType<typeof useMenuOptionGroup>\n\nexport interface UseMenuOptionItemProps extends UseMenuItemProps {\n  /**\n   * The value of the menu option item.\n   */\n  value: string\n}\n\nexport const useMenuOptionItem = ({\n  disabled,\n  value,\n  ...rest\n}: UseMenuOptionItemProps) => {\n  const { type, value: selectedValue, onChange } = useMenuOptionGroupContext()\n  const { getItemProps } = useMenuItem({ disabled, value, ...rest })\n  const radio = type === \"radio\" && isString(selectedValue)\n  const checkbox = type === \"checkbox\" && isArray(selectedValue)\n  const selected = radio\n    ? value === selectedValue\n    : checkbox\n      ? selectedValue.includes(value)\n      : false\n\n  const getIndicatorProps: PropGetter = useCallback(\n    ({ style, ...props } = {}) => ({\n      style: { opacity: selected ? 1 : 0, ...style },\n      ...props,\n    }),\n    [selected],\n  )\n\n  const getOptionItemProps: PropGetter = useCallback(\n    (props = {}) =>\n      getItemProps({\n        role: radio ? \"menuitemradio\" : \"menuitemcheckbox\",\n        ...props,\n        onClick: handlerAll(props.onClick, () =>\n          !disabled ? onChange?.(value) : noop,\n        ),\n      }),\n    [disabled, getItemProps, onChange, radio, value],\n  )\n\n  return {\n    type,\n    selected,\n    getIndicatorProps,\n    getOptionItemProps,\n  }\n}\n\nexport type UseMenuOptionItemReturn = ReturnType<typeof useMenuOptionItem>\n"
    }
  ]
}
