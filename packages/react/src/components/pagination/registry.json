{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["button", "icon"],
    "externals": [],
    "hooks": ["use-controllable-state"],
    "providers": ["i18n-provider"]
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./pagination.style\"\nexport * as Pagination from \"./namespace\"\nexport type {\n  PaginationEndTriggerProps,\n  PaginationItemProps,\n  PaginationItemsProps,\n  PaginationNextTriggerProps,\n  PaginationPrevTriggerProps,\n  PaginationRootProps,\n  PaginationStartTriggerProps,\n  PaginationTextProps,\n} from \"./pagination\"\nexport {\n  PaginationEndTrigger,\n  PaginationItem,\n  PaginationItems,\n  PaginationNextTrigger,\n  PaginationPrevTrigger,\n  PaginationPropsContext,\n  PaginationRoot,\n  PaginationStartTrigger,\n  PaginationText,\n  usePaginationPropsContext,\n} from \"./pagination\"\nexport * from \"./use-pagination\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  PaginationEndTrigger as EndTrigger,\n  PaginationItem as Item,\n  PaginationItems as Items,\n  PaginationNextTrigger as NextTrigger,\n  PaginationPrevTrigger as PrevTrigger,\n  PaginationPropsContext as PropsContext,\n  PaginationRoot as Root,\n  PaginationStartTrigger as StartTrigger,\n  PaginationText as Text,\n  usePaginationPropsContext as usePropsContext,\n} from \"./pagination\"\nexport type {\n  PaginationEndTriggerProps as EndTriggerProps,\n  PaginationItemProps as ItemProps,\n  PaginationItemsProps as ItemsProps,\n  PaginationNextTriggerProps as NextTriggerProps,\n  PaginationPrevTriggerProps as PrevTriggerProps,\n  PaginationRootProps as RootProps,\n  PaginationStartTriggerProps as StartTriggerProps,\n  PaginationTextProps as TextProps,\n} from \"./pagination\"\n"
    },
    {
      "name": "pagination.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\nimport { iconButtonStyle } from \"../button\"\n\nexport const paginationStyle = defineComponentSlotStyle({\n  base: {\n    item: {\n      fontWeight: \"normal\",\n      _current: {\n        cursor: \"default\",\n        pointerEvents: \"none\",\n      },\n    },\n    root: {\n      \"& > [data-ellipsis]\": {\n        pointerEvents: \"none\",\n      },\n    },\n    text: {\n      alignItems: \"center\",\n      display: \"flex\",\n      justifyContent: \"center\",\n    },\n  },\n\n  variants: {\n    outline: {\n      item: {\n        ...iconButtonStyle.variants?.ghost,\n        _current: {\n          ...iconButtonStyle.variants?.outline,\n        },\n      },\n    },\n    solid: {\n      item: {\n        ...iconButtonStyle.variants?.ghost,\n        _current: {\n          ...iconButtonStyle.variants?.solid,\n        },\n      },\n    },\n    subtle: {\n      item: {\n        ...iconButtonStyle.variants?.ghost,\n        _current: {\n          ...iconButtonStyle.variants?.subtle,\n        },\n      },\n    },\n    surface: {\n      item: {\n        ...iconButtonStyle.variants?.ghost,\n        _current: {\n          ...iconButtonStyle.variants?.surface,\n        },\n      },\n    },\n  },\n\n  sizes: {\n    xs: {\n      item: {\n        ...iconButtonStyle.sizes?.xs,\n        fontSize: \"{font-size}\",\n        _icon: { fontSize: iconButtonStyle.sizes?.xs.fontSize },\n      },\n      root: {\n        \"--font-size\": \"fontSizes.sm\",\n      },\n      text: {\n        fontSize: \"{font-size}\",\n      },\n    },\n    sm: {\n      item: {\n        ...iconButtonStyle.sizes?.sm,\n        fontSize: \"{font-size}\",\n        _icon: { fontSize: iconButtonStyle.sizes?.sm.fontSize },\n      },\n      root: {\n        \"--font-size\": \"fontSizes.md\",\n      },\n      text: {\n        fontSize: \"{font-size}\",\n      },\n    },\n    md: {\n      item: {\n        ...iconButtonStyle.sizes?.md,\n        fontSize: \"{font-size}\",\n        _icon: { fontSize: iconButtonStyle.sizes?.md.fontSize },\n      },\n      root: {\n        \"--font-size\": \"fontSizes.lg\",\n      },\n      text: {\n        fontSize: \"{font-size}\",\n      },\n    },\n    lg: {\n      item: {\n        ...iconButtonStyle.sizes?.lg,\n        fontSize: \"{font-size}\",\n        _icon: { fontSize: iconButtonStyle.sizes?.lg.fontSize },\n      },\n      root: {\n        \"--font-size\": \"fontSizes.xl\",\n      },\n      text: {\n        fontSize: \"{font-size}\",\n      },\n    },\n    xl: {\n      item: {\n        ...iconButtonStyle.sizes?.xl,\n        fontSize: \"{font-size}\",\n        _icon: { fontSize: iconButtonStyle.sizes?.xl.fontSize },\n      },\n      root: {\n        \"--font-size\": \"fontSizes.2xl\",\n      },\n      text: {\n        fontSize: \"{font-size}\",\n      },\n    },\n    \"2xl\": {\n      item: {\n        ...iconButtonStyle.sizes?.[\"2xl\"],\n        fontSize: \"{font-size}\",\n        _icon: { fontSize: iconButtonStyle.sizes?.[\"2xl\"].fontSize },\n      },\n      root: {\n        \"--font-size\": \"fontSizes.2xl\",\n      },\n      text: {\n        fontSize: \"{font-size}\",\n      },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"solid\",\n  },\n})\n\nexport type PaginationStyle = typeof paginationStyle\n"
    },
    {
      "name": "pagination.tsx",
      "content": "\"use client\"\n\nimport type { FC, ReactNode } from \"react\"\nimport type {\n  HTMLProps,\n  HTMLStyledProps,\n  ThemeProps,\n  WithoutThemeProps,\n  ReactNodeOrFunction,\n} from \"@yamada-ui/react\"\nimport type { PaginationStyle } from \"./pagination.style\"\nimport type { Page, UsePaginationProps } from \"./use-pagination\"\nimport { cloneElement, isValidElement, useMemo } from \"react\"\nimport {\n  createSlotComponent,\n  styled,\n  isNumber,\n  runIfFn,\n} from \"@yamada-ui/react\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport { ButtonGroup } from \"../button\"\nimport {\n  ChevronLeftIcon,\n  ChevronRightIcon,\n  ChevronsLeftIcon,\n  ChevronsRightIcon,\n  EllipsisIcon,\n} from \"../icon\"\nimport { paginationStyle } from \"./pagination.style\"\nimport {\n  PaginationContext,\n  usePagination,\n  usePaginationContext,\n} from \"./use-pagination\"\n\nexport interface PaginationRootProps\n  extends WithoutThemeProps<\n      Omit<ButtonGroup.RootProps, \"onChange\" | \"page\">,\n      PaginationStyle\n    >,\n    ThemeProps<PaginationStyle>,\n    Omit<UsePaginationProps, \"boundaries\" | \"siblings\"> {\n  /**\n   * Number of elements visible on the left/right edges.\n   *\n   * @default 1\n   */\n  boundaries?: number\n  /** Number of siblings displayed on the left/right side of selected page.\n   *\n   * @default 1\n   */\n  siblings?: number\n  /**\n   * If `true`, display the control buttons.\n   *\n   * @default true\n   */\n  withControls?: boolean\n  /**\n   * If `true`, display the edge buttons.\n   *\n   * @default false\n   */\n  withEdges?: boolean\n  /**\n   * Props for next of the control button element.\n   */\n  controlNextProps?: PaginationItemProps\n  /**\n   * Props for previous of the control button element.\n   */\n  controlPrevProps?: PaginationItemProps\n  /**\n   * Props for control button element.\n   */\n  controlProps?: PaginationItemProps\n  /**\n   * Props for end of the edge button element.\n   */\n  edgeEndProps?: PaginationItemProps\n  /**\n   * Props for edge button element.\n   */\n  edgeProps?: PaginationItemProps\n  /**\n   * Props for start of the edge button element.\n   */\n  edgeStartProps?: PaginationItemProps\n  /**\n   * Props for ellipsis of the element.\n   */\n  ellipsisProps?: PaginationItemProps\n  /**\n   * Props for item of the button element.\n   */\n  itemProps?: PaginationItemProps\n}\n\nconst {\n  PropsContext: PaginationPropsContext,\n  usePropsContext: usePaginationPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<PaginationRootProps, PaginationStyle>(\n  \"pagination\",\n  paginationStyle,\n)\n\nexport { PaginationPropsContext, usePaginationPropsContext }\n\n/**\n * `Pagination` is a component for managing the pagination and navigation of content.\n *\n * @see https://yamada-ui.com/docs/components/pagination\n */\nexport const PaginationRoot = withProvider<\n  \"nav\",\n  PaginationRootProps,\n  \"size\" | \"variant\"\n>(\n  ({\n    size,\n    variant,\n    children,\n    withControls = true,\n    withEdges = false,\n    controlNextProps,\n    controlPrevProps,\n    controlProps,\n    edgeEndProps,\n    edgeProps,\n    edgeStartProps,\n    ellipsisProps,\n    itemProps,\n    ...rest\n  }) => {\n    const {\n      currentPage,\n      disabled,\n      range,\n      total,\n      getEndTriggerProps,\n      getItemProps,\n      getNextTriggerProps,\n      getPrevTriggerProps,\n      getRootProps,\n      getStartTriggerProps,\n      onChange,\n      onChangeEnd,\n      onChangeNext,\n      onChangePrev,\n      onChangeStart,\n    } = usePagination(rest)\n    const context = useMemo(\n      () => ({\n        currentPage,\n        disabled,\n        range,\n        total,\n        getEndTriggerProps,\n        getItemProps,\n        getNextTriggerProps,\n        getPrevTriggerProps,\n        getStartTriggerProps,\n        onChange,\n        onChangeEnd,\n        onChangeNext,\n        onChangePrev,\n        onChangeStart,\n      }),\n      [\n        currentPage,\n        disabled,\n        range,\n        total,\n        getEndTriggerProps,\n        getItemProps,\n        getNextTriggerProps,\n        getPrevTriggerProps,\n        getStartTriggerProps,\n        onChange,\n        onChangeEnd,\n        onChangeNext,\n        onChangePrev,\n        onChangeStart,\n      ],\n    )\n    const computedChildren = useMemo(() => {\n      if (children) {\n        return children\n      } else {\n        const children: ReactNode[] = []\n\n        if (withEdges)\n          children.push(\n            <PaginationStartTrigger>\n              <PaginationItem\n                icon={<ChevronsLeftIcon />}\n                {...edgeProps}\n                {...edgeStartProps}\n              />\n            </PaginationStartTrigger>,\n          )\n        if (withControls)\n          children.push(\n            <PaginationPrevTrigger>\n              <PaginationItem\n                icon={<ChevronLeftIcon />}\n                {...controlProps}\n                {...controlPrevProps}\n              />\n            </PaginationPrevTrigger>,\n          )\n\n        children.push(\n          <PaginationItems\n            render={(page) =>\n              isNumber(page) ? (\n                <PaginationItem {...itemProps}>\n                  <styled.span role=\"presentation\">{page}</styled.span>\n                </PaginationItem>\n              ) : (\n                <PaginationItem\n                  as=\"span\"\n                  icon={<EllipsisIcon />}\n                  {...ellipsisProps}\n                />\n              )\n            }\n          />,\n        )\n\n        if (withControls)\n          children.push(\n            <PaginationNextTrigger>\n              <PaginationItem\n                icon={<ChevronRightIcon />}\n                {...controlProps}\n                {...controlNextProps}\n              />\n            </PaginationNextTrigger>,\n          )\n        if (withEdges)\n          children.push(\n            <PaginationEndTrigger>\n              <PaginationItem\n                icon={<ChevronsRightIcon />}\n                {...edgeProps}\n                {...edgeEndProps}\n              />\n            </PaginationEndTrigger>,\n          )\n\n        return children\n      }\n    }, [\n      children,\n      withEdges,\n      withControls,\n      itemProps,\n      ellipsisProps,\n      edgeProps,\n      edgeStartProps,\n      edgeEndProps,\n      controlProps,\n      controlPrevProps,\n      controlNextProps,\n    ])\n\n    return (\n      <PaginationContext value={context}>\n        <ButtonGroup.Root\n          as=\"nav\"\n          size={size}\n          variant={variant}\n          {...getRootProps()}\n        >\n          {computedChildren}\n        </ButtonGroup.Root>\n      </PaginationContext>\n    )\n  },\n  \"root\",\n  { transferProps: [\"variant\", \"size\"] },\n)()\n\nexport interface PaginationItemsProps {\n  /**\n   * The function used to generate children.\n   * it will be called with page number or `\"ellipsis\"`.\n   */\n  children?: (page: Page) => ReactNode\n  /**\n   * The function used to generate children.\n   * it will be called with page number or `\"ellipsis\"`.\n   */\n  render?: (page: Page) => ReactNode\n}\n\nexport const PaginationItems: FC<PaginationItemsProps> = ({\n  children,\n  render,\n}) => {\n  const { range, getItemProps } = usePaginationContext()\n\n  return useMemo(\n    () =>\n      range.map((page, index) => {\n        const component = children?.(page) ?? render?.(page)\n\n        if (isValidElement<HTMLProps<\"button\">>(component)) {\n          return cloneElement(component, {\n            ...getItemProps({ key: index, page, ...component.props }),\n          })\n        } else {\n          return component\n        }\n      }),\n    [children, getItemProps, range, render],\n  )\n}\n\nexport interface PaginationItemProps extends ButtonGroup.IconItemProps {}\n\nexport const PaginationItem = withContext<\"button\", PaginationItemProps>(\n  ButtonGroup.IconItem,\n  \"item\",\n)()\n\nexport interface PaginationTextProps\n  extends Omit<HTMLStyledProps<\"span\">, \"children\"> {\n  /**\n   * The children of the text.\n   * if function, it will be called with `{ page: number; total: number }`.\n   */\n  children?: ReactNodeOrFunction<{ page: number; total: number }>\n  /**\n   * The format of the text.\n   *\n   * @default 'compact'\n   */\n  format?: \"compact\" | \"short\"\n}\n\nexport const PaginationText = withContext<\"span\", PaginationTextProps>(\n  \"span\",\n  \"text\",\n)(undefined, ({ children, format = \"compact\", ...rest }) => {\n  const { currentPage, total } = usePaginationContext()\n  const { t } = useI18n(\"pagination\")\n  const computedChildren = useMemo(() => {\n    if (children) {\n      return runIfFn(children, { page: currentPage, total })\n    } else if (format === \"short\") {\n      return t(\"{value} / {total}\", {\n        total,\n        value: currentPage,\n      })\n    } else {\n      return t(\"{value} of {total}\", {\n        total,\n        value: currentPage,\n      })\n    }\n  }, [children, currentPage, format, total, t])\n\n  return {\n    ...rest,\n    children: computedChildren,\n  }\n})\n\nexport interface PaginationStartTriggerProps\n  extends HTMLStyledProps<\"button\"> {}\n\nexport const PaginationStartTrigger = withContext<\n  \"button\",\n  PaginationStartTriggerProps\n>(\"button\", { name: \"startTrigger\", slot: [\"trigger\", \"start\"] })(\n  undefined,\n  (props) => {\n    const { getStartTriggerProps } = usePaginationContext()\n\n    return { asChild: true, ...getStartTriggerProps(props) }\n  },\n)\n\nexport interface PaginationEndTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const PaginationEndTrigger = withContext<\n  \"button\",\n  PaginationEndTriggerProps\n>(\"button\", { name: \"endTrigger\", slot: [\"trigger\", \"end\"] })(\n  undefined,\n  (props) => {\n    const { getEndTriggerProps } = usePaginationContext()\n\n    return { asChild: true, ...getEndTriggerProps(props) }\n  },\n)\n\nexport interface PaginationPrevTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const PaginationPrevTrigger = withContext<\n  \"button\",\n  PaginationPrevTriggerProps\n>(\"button\", { name: \"prevTrigger\", slot: [\"trigger\", \"prev\"] })(\n  undefined,\n  (props) => {\n    const { getPrevTriggerProps } = usePaginationContext()\n\n    return { asChild: true, ...getPrevTriggerProps(props) }\n  },\n)\n\nexport interface PaginationNextTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const PaginationNextTrigger = withContext<\n  \"button\",\n  PaginationNextTriggerProps\n>(\"button\", { name: \"nextTrigger\", slot: [\"trigger\", \"next\"] })(\n  undefined,\n  (props) => {\n    const { getNextTriggerProps } = usePaginationContext()\n\n    return { asChild: true, ...getNextTriggerProps(props) }\n  },\n)\n"
    },
    {
      "name": "use-pagination.ts",
      "content": "\"use client\"\n\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport { useCallback, useMemo } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport {\n  createContext,\n  handlerAll,\n  isNumber,\n  mergeRefs,\n} from \"@yamada-ui/react\"\n\nexport type Page = \"ellipsis\" | number\n\ninterface PaginationContext extends Omit<UsePaginationReturn, \"getRootProps\"> {}\n\nconst [PaginationContext, usePaginationContext] =\n  createContext<PaginationContext>({\n    name: \"PaginationContext\",\n  })\n\nexport { PaginationContext, usePaginationContext }\n\nexport interface UsePaginationProps\n  extends Omit<HTMLProps, \"onChange\" | \"page\"> {\n  /**\n   * The total number of pages in pagination.\n   */\n  total: number\n  /**\n   * Number of elements visible on the left/right edges.\n   *\n   * @default 1\n   */\n  boundaries?: number\n  /**\n   * The initial page of the pagination.\n   * Should be less than `total` and greater than `1`.\n   *\n   * @default 1\n   */\n  defaultPage?: number\n  /**\n   * If `true`, the pagination all item will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * The page of the pagination.\n   * Should be less than `total` and greater than `1`.\n   */\n  page?: number\n  /** Number of siblings displayed on the left/right side of selected page.\n   *\n   * @default 1\n   */\n  siblings?: number\n  /**\n   * The callback invoked when the page changes.\n   */\n  onChange?: (page: number) => void\n}\n\nexport const usePagination = ({\n  boundaries = 1,\n  defaultPage = 1,\n  disabled = false,\n  page,\n  siblings = 1,\n  total,\n  onChange: onChangeProp,\n  ...rest\n}: UsePaginationProps) => {\n  const [currentPage, setCurrentPage] = useControllableState({\n    defaultValue: defaultPage,\n    value: page,\n    onChange: onChangeProp,\n  })\n  const { t } = useI18n(\"pagination\")\n  const range = useMemo((): Page[] => {\n    const minimumTotal = siblings * 2 + 3 + boundaries * 2\n\n    if (minimumTotal >= total) return computedRange(1, total)\n\n    const prevSiblings = Math.max(currentPage - siblings, boundaries)\n    const nextSiblings = Math.min(currentPage + siblings, total - boundaries)\n    const prevDots = prevSiblings > boundaries + 2\n    const nextDots = nextSiblings < total - (boundaries + 1)\n\n    if (!prevDots && nextDots) {\n      const prevPages = siblings * 2 + boundaries + 2\n\n      return [\n        ...computedRange(1, prevPages),\n        \"ellipsis\",\n        ...computedRange(total - (boundaries - 1), total),\n      ]\n    }\n\n    if (prevDots && !nextDots) {\n      const nextPages = boundaries + 1 + 2 * siblings\n\n      return [\n        ...computedRange(1, boundaries),\n        \"ellipsis\",\n        ...computedRange(total - nextPages, total),\n      ]\n    }\n\n    return [\n      ...computedRange(1, boundaries),\n      \"ellipsis\",\n      ...computedRange(prevSiblings, nextSiblings),\n      \"ellipsis\",\n      ...computedRange(total - boundaries + 1, total),\n    ]\n  }, [boundaries, siblings, currentPage, total])\n\n  const onChange = useCallback(\n    (page: number) => setCurrentPage(Math.max(1, Math.min(total, page))),\n    [setCurrentPage, total],\n  )\n\n  const onChangeStart = useCallback(() => setCurrentPage(1), [setCurrentPage])\n\n  const onChangeEnd = useCallback(\n    () => setCurrentPage(total),\n    [setCurrentPage, total],\n  )\n\n  const onChangePrev = useCallback(\n    () => setCurrentPage((prev) => Math.max(1, prev - 1)),\n    [setCurrentPage],\n  )\n\n  const onChangeNext = useCallback(\n    () => setCurrentPage((prev) => Math.min(total, prev + 1)),\n    [setCurrentPage, total],\n  )\n\n  const getRootProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref),\n      \"aria-label\": t(\"Pagination\"),\n      role: \"navigation\",\n    }),\n    [rest, t],\n  )\n\n  const getItemProps: PropGetter<\"button\", { page?: Page }> = useCallback(\n    ({ page, ...props } = {}) => {\n      if (isNumber(page)) {\n        return {\n          type: \"button\",\n          \"aria-current\": currentPage === page ? \"page\" : undefined,\n          \"aria-label\": t(\"Go to page {value}\", { value: page }),\n          disabled,\n          ...props,\n          onClick: handlerAll(props.onClick, () => onChange(page)),\n        }\n      } else {\n        return { ...props, \"data-ellipsis\": \"\" }\n      }\n    },\n    [currentPage, t, onChange, disabled],\n  )\n\n  const getStartTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      type: \"button\",\n      \"aria-label\": t(\"Go to first page\"),\n      disabled: disabled || currentPage === 1,\n      ...props,\n      onClick: handlerAll(props.onClick, onChangeStart),\n    }),\n    [onChangeStart, t, disabled, currentPage],\n  )\n\n  const getEndTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      type: \"button\",\n      \"aria-label\": t(\"Go to last page\"),\n      disabled: disabled || currentPage === total,\n      ...props,\n      onClick: handlerAll(props.onClick, onChangeEnd),\n    }),\n    [onChangeEnd, t, disabled, currentPage, total],\n  )\n\n  const getPrevTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      type: \"button\",\n      \"aria-label\": t(\"Go to previous page\"),\n      disabled: disabled || currentPage === 1,\n      ...props,\n      onClick: handlerAll(props.onClick, onChangePrev),\n    }),\n    [onChangePrev, t, disabled, currentPage],\n  )\n\n  const getNextTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      type: \"button\",\n      \"aria-label\": t(\"Go to next page\"),\n      disabled: disabled || currentPage === total,\n      ...props,\n      onClick: handlerAll(props.onClick, onChangeNext),\n    }),\n    [onChangeNext, t, disabled, currentPage, total],\n  )\n\n  return {\n    currentPage,\n    disabled,\n    range,\n    total,\n    getEndTriggerProps,\n    getItemProps,\n    getNextTriggerProps,\n    getPrevTriggerProps,\n    getRootProps,\n    getStartTriggerProps,\n    onChange,\n    onChangeEnd,\n    onChangeNext,\n    onChangePrev,\n    onChangeStart,\n  }\n}\n\nexport type UsePaginationReturn = ReturnType<typeof usePagination>\n\nconst computedRange = (start: number, end: number) =>\n  Array.from({ length: end - start + 1 }, (_, index) => index + start)\n"
    }
  ]
}
