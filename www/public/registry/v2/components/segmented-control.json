{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["motion", "field"],
    "externals": ["motion@12.18.1"],
    "hooks": ["use-value", "use-controllable-state", "use-descendants"],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./segmented-control.style\"\nexport * as SegmentedControl from \"./namespace\"\nexport {\n  SegmentedControlItem,\n  SegmentedControlPropsContext,\n  SegmentedControlRoot,\n  useSegmentedControlPropsContext,\n} from \"./segmented-control\"\nexport type {\n  SegmentedControlItemProps,\n  SegmentedControlRootProps,\n} from \"./segmented-control\"\nexport * from \"./use-segmented-control\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  SegmentedControlItem as Item,\n  SegmentedControlPropsContext as PropsContext,\n  SegmentedControlRoot as Root,\n  useSegmentedControlPropsContext as usePropsContext,\n} from \"./segmented-control\"\nexport type {\n  SegmentedControlItemProps as ItemProps,\n  SegmentedControlRootProps as RootProps,\n} from \"./segmented-control\"\nexport {\n  SegmentedControlContext as Context,\n  SegmentedControlDescendantsContext as DescendantsContext,\n  useSegmentedControlContext as useContext,\n  useSegmentedControlDescendant as useDescendant,\n  useSegmentedControlDescendants as useDescendants,\n} from \"./use-segmented-control\"\n"
    },
    {
      "name": "segmented-control.style.ts",
      "content": "import { defineComponentSlotStyle, focusRingStyle } from \"@yamada-ui/react\"\n\nexport const segmentedControlStyle = defineComponentSlotStyle({\n  base: {\n    indicator: {\n      bg: \"bg\",\n      boxShadow: \"xs\",\n      boxSize: \"full\",\n      pointerEvents: \"none\",\n      position: \"absolute\",\n      rounded: \"md\",\n      top: \"0\",\n      userSelect: \"none\",\n    },\n    item: {\n      \"&:has(input:focus-visible)\": focusRingStyle.outline,\n      \"& > span\": { zIndex: \"1\" },\n      color: \"fg\",\n      cursor: \"pointer\",\n      display: \"inline-center\",\n      flex: \"1 1 0%\",\n      fontWeight: \"medium\",\n      position: \"relative\",\n      whiteSpace: \"nowrap\",\n      _readOnly: { layerStyle: \"readOnly\", pointerEvents: \"none\" },\n      _disabled: {\n        layerStyle: \"disabled\",\n        \"&[data-root-disabled]\": { opacity: 1 },\n      },\n    },\n    root: {\n      alignItems: \"center\",\n      bg: \"bg.subtle\",\n      display: \"inline-flex\",\n      p: \"1\",\n      rounded: \"lg\",\n      _readOnly: { layerStyle: \"readOnly\" },\n      _disabled: { layerStyle: \"disabled\" },\n    },\n  },\n\n  props: {\n    /**\n     * If `true`, the segmented control will be full rounded.\n     *\n     * @default false\n     */\n    fullRounded: {\n      true: {\n        indicator: {\n          rounded: \"full\",\n        },\n        item: {\n          rounded: \"full\",\n        },\n        root: {\n          rounded: \"full\",\n          _before: {\n            rounded: \"full\",\n          },\n        },\n      },\n    },\n    /**\n     * The orientation of the segmented control.\n     *\n     * @default 'horizontal'\n     */\n    orientation: {\n      horizontal: {\n        item: {\n          h: \"full\",\n        },\n        root: {\n          flexDirection: \"row\",\n          _before: {\n            transitionProperty: \"left, width\",\n          },\n        },\n      },\n      vertical: {\n        item: {\n          w: \"full\",\n        },\n        root: {\n          flexDirection: \"column\",\n          _before: {\n            transitionProperty: \"top, height\",\n          },\n        },\n      },\n    },\n  },\n\n  sizes: {\n    sm: {\n      item: { fontSize: \"sm\", px: \"3\", _vertical: { minH: \"7\" } },\n      root: { _horizontal: { h: \"9\", minW: \"64\" } },\n    },\n    md: {\n      item: { fontSize: \"md\", px: \"3\", _vertical: { minH: \"8\" } },\n      root: { _horizontal: { h: \"10\", minW: \"80\" } },\n    },\n    lg: {\n      item: { fontSize: \"lg\", px: \"4\", _vertical: { minH: \"9\" } },\n      root: { _horizontal: { h: \"11\", minW: \"96\" } },\n    },\n    xl: {\n      item: { fontSize: \"xl\", px: \"5\", _vertical: { minH: \"10\" } },\n      root: { _horizontal: { h: \"12\", minW: \"96\" } },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    orientation: \"horizontal\",\n  },\n})\n\nexport type SegmentedControlStyle = typeof segmentedControlStyle\n"
    },
    {
      "name": "segmented-control.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement, ReactNode } from \"react\"\nimport type {\n  GenericsComponent,\n  HTMLStyledProps,\n  ThemeProps,\n} from \"@yamada-ui/react\"\nimport type { HTMLMotionProps } from \"../motion\"\nimport type { SegmentedControlStyle } from \"./segmented-control.style\"\nimport type {\n  UseSegmentedControlItemProps,\n  UseSegmentedControlProps,\n} from \"./use-segmented-control\"\nimport { LayoutGroup } from \"motion/react\"\nimport { useMemo } from \"react\"\nimport { createSlotComponent, styled } from \"@yamada-ui/react\"\nimport { useValue } from \"../../hooks/use-value\"\nimport { motion } from \"../motion\"\nimport { segmentedControlStyle } from \"./segmented-control.style\"\nimport {\n  SegmentedControlContext,\n  SegmentedControlDescendantsContext,\n  useSegmentedControl,\n  useSegmentedControlItem,\n} from \"./use-segmented-control\"\n\nexport interface SegmentedControlItem extends SegmentedControlItemProps {\n  label?: ReactNode\n}\n\ninterface ComponentContext\n  extends Pick<SegmentedControlRootProps, \"indicatorProps\" | \"itemProps\"> {}\n\nexport interface SegmentedControlRootProps<Y extends string = string>\n  extends Omit<HTMLStyledProps, \"defaultValue\" | \"onChange\">,\n    ThemeProps<SegmentedControlStyle>,\n    Omit<UseSegmentedControlProps<Y>, \"orientation\"> {\n  /**\n   * If provided, generate segmented control buttons but based on items.\n   *\n   * @default []\n   */\n  items?: SegmentedControlItem[]\n  /**\n   * Props for the indicator component.\n   */\n  indicatorProps?: SegmentedControlIndicatorProps\n  /**\n   * Props for the item component.\n   */\n  itemProps?: SegmentedControlItemProps\n}\n\nconst {\n  ComponentContext,\n  PropsContext: SegmentedControlPropsContext,\n  useComponentContext,\n  usePropsContext: useSegmentedControlPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<\n  SegmentedControlRootProps,\n  SegmentedControlStyle,\n  ComponentContext\n>(\"segmented-control\", segmentedControlStyle)\n\nexport { SegmentedControlPropsContext, useSegmentedControlPropsContext }\n\n/**\n * `SegmentedControl` is a component used for allowing users to select one option from multiple choices.\n *\n * @see https://yamada-ui.com/docs/components/segmented-control\n */\nexport const SegmentedControlRoot = withProvider(\n  ({\n    children,\n    items = [],\n    orientation: orientationProp,\n    indicatorProps,\n    itemProps,\n    ...rest\n  }) => {\n    const computedOrientation = useValue(orientationProp)\n    const {\n      id,\n      name,\n      descendants,\n      disabled,\n      orientation,\n      readOnly,\n      setValue,\n      value,\n      getRootProps,\n    } = useSegmentedControl({ orientation: computedOrientation, ...rest })\n    const cloneChildren = useMemo(() => {\n      if (children) {\n        return children\n      } else {\n        return items.map(({ label, ...rest }, index) => (\n          <SegmentedControlItem key={index} {...rest}>\n            {label}\n          </SegmentedControlItem>\n        ))\n      }\n    }, [children, items])\n    const context = useMemo(\n      () => ({ id, name, disabled, orientation, readOnly, setValue, value }),\n      [id, name, disabled, readOnly, orientation, setValue, value],\n    )\n    const componentContext = useMemo(\n      () => ({ indicatorProps, itemProps }),\n      [itemProps, indicatorProps],\n    )\n\n    return (\n      <SegmentedControlContext value={context}>\n        <ComponentContext value={componentContext}>\n          <SegmentedControlDescendantsContext value={descendants}>\n            <LayoutGroup id={id}>\n              <styled.div {...getRootProps()}>{cloneChildren}</styled.div>\n            </LayoutGroup>\n          </SegmentedControlDescendantsContext>\n        </ComponentContext>\n      </SegmentedControlContext>\n    )\n  },\n  \"root\",\n  { transferProps: [\"orientation\"] },\n)() as GenericsComponent<{\n  <Y extends string = string>(props: SegmentedControlRootProps<Y>): ReactElement\n}>\n\nexport interface SegmentedControlItemProps<Y extends string = string>\n  extends HTMLStyledProps<\"label\">,\n    UseSegmentedControlItemProps<Y> {\n  /**\n   * Props for the indicator component.\n   */\n  indicatorProps?: SegmentedControlIndicatorProps\n}\n\nexport const SegmentedControlItem = withContext<\n  \"label\",\n  SegmentedControlItemProps\n>(({ children, indicatorProps, ...rest }) => {\n  const { checked, getInputProps, getLabelProps } =\n    useSegmentedControlItem(rest)\n\n  return (\n    <styled.label {...getLabelProps()}>\n      <styled.input {...getInputProps()} />\n\n      <styled.span>{children}</styled.span>\n\n      {checked ? <SegmentedControlIndicator {...indicatorProps} /> : null}\n    </styled.label>\n  )\n}, \"item\")((props) => {\n  const { indicatorProps, itemProps } = useComponentContext()\n\n  return {\n    ...itemProps,\n    ...props,\n    indicatorProps: {\n      ...indicatorProps,\n      ...itemProps?.indicatorProps,\n      ...props.indicatorProps,\n    },\n  }\n}) as GenericsComponent<{\n  <Y extends string = string>(props: SegmentedControlItemProps<Y>): ReactElement\n}>\n\ninterface SegmentedControlIndicatorProps extends HTMLMotionProps {}\n\nconst SegmentedControlIndicator = withContext<\n  \"div\",\n  SegmentedControlIndicatorProps\n>(({ transition, ...props }) => {\n  return (\n    <motion.div\n      layoutDependency={false}\n      layoutId=\"indicator\"\n      transition={{ duration: 0.2, ...transition }}\n      {...props}\n    />\n  )\n}, \"indicator\")()\n"
    },
    {
      "name": "use-segmented-control.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent } from \"react\"\nimport type { HTMLProps, Orientation, PropGetter } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useId } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { createDescendants } from \"../../hooks/use-descendants\"\nimport {\n  ariaAttr,\n  createContext,\n  dataAttr,\n  handlerAll,\n  mergeRefs,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\n\ninterface SegmentedControlContext\n  extends Omit<UseSegmentedControlReturn, \"descendants\" | \"getRootProps\"> {}\n\nconst [SegmentedControlContext, useSegmentedControlContext] =\n  createContext<SegmentedControlContext>({\n    name: \"SegmentedControlContext\",\n  })\n\nexport { SegmentedControlContext, useSegmentedControlContext }\n\nconst {\n  DescendantsContext: SegmentedControlDescendantsContext,\n  useDescendant: useSegmentedControlDescendant,\n  useDescendants: useSegmentedControlDescendants,\n} = createDescendants<HTMLInputElement>()\n\nexport {\n  SegmentedControlDescendantsContext,\n  useSegmentedControlDescendant,\n  useSegmentedControlDescendants,\n}\n\nexport interface UseSegmentedControlProps<Y extends string = string>\n  extends Omit<HTMLProps, \"onChange\"> {\n  /**\n   * The HTML `name` attribute used for forms.\n   */\n  name?: string\n  /**\n   * The initial value of the segmented control.\n   */\n  defaultValue?: Y\n  /**\n   * If `true`, the segmented control will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * The orientation of the segmented control.\n   *\n   * @default 'horizontal'\n   */\n  orientation?: Orientation\n  /**\n   * If `true`, the segmented control will be readonly.\n   *\n   * @default false\n   */\n  readOnly?: boolean\n  /**\n   * The value of the segmented control.\n   */\n  value?: Y\n  /**\n   * The callback fired when any children radio is checked or unchecked.\n   */\n  onChange?: (value: Y) => void\n}\n\nexport const useSegmentedControl = <Y extends string = string>({\n  id,\n  name,\n  defaultValue,\n  disabled,\n  orientation = \"horizontal\",\n  readOnly,\n  value: valueProp,\n  onChange: onChangeProp,\n  ...rest\n}: UseSegmentedControlProps<Y> = {}) => {\n  const uuid = useId()\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const descendants = useSegmentedControlDescendants()\n\n  id ??= uuid\n  name ??= uuid\n\n  const getRootProps: PropGetter = useCallback(\n    (props) => ({\n      id,\n      \"aria-disabled\": ariaAttr(disabled),\n      \"aria-orientation\": orientation,\n      \"data-disabled\": dataAttr(disabled),\n      \"data-orientation\": orientation,\n      \"data-readonly\": dataAttr(readOnly),\n      role: \"radiogroup\",\n      ...rest,\n      ...props,\n    }),\n    [disabled, id, orientation, readOnly, rest],\n  )\n\n  return {\n    id,\n    name,\n    descendants,\n    disabled,\n    orientation,\n    readOnly,\n    setValue,\n    value,\n    getRootProps,\n  }\n}\n\nexport type UseSegmentedControlReturn = ReturnType<typeof useSegmentedControl>\n\nexport interface UseSegmentedControlItemProps<Y extends string = string>\n  extends HTMLProps<\"label\">,\n    Pick<FieldProps, \"disabled\" | \"readOnly\"> {\n  /**\n   * The value of the segmented control item.\n   */\n  value: Y\n  /**\n   * Props for the input element.\n   */\n  inputProps?: HTMLProps<\"input\">\n}\n\nexport const useSegmentedControlItem = <Y extends string = string>({\n  disabled,\n  readOnly,\n  value,\n  inputProps,\n  ...rest\n}: UseSegmentedControlItemProps<Y>) => {\n  const {\n    name,\n    disabled: rootDisabled,\n    orientation,\n    readOnly: rootReadOnly,\n    setValue,\n    value: selectedValue,\n  } = useSegmentedControlContext()\n  const { register } = useSegmentedControlDescendant({\n    disabled: disabled || readOnly,\n  })\n  const checked = value === selectedValue\n  const trulyDisabled = disabled ?? rootDisabled\n  const trulyReadOnly = readOnly ?? rootReadOnly\n  const interactive = !(trulyReadOnly || trulyDisabled)\n\n  const onChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      setValue(ev.target.value)\n    },\n    [setValue],\n  )\n\n  const getLabelProps: PropGetter<\"label\"> = useCallback(\n    (props) => ({\n      \"aria-disabled\": ariaAttr(trulyDisabled),\n      \"aria-readonly\": ariaAttr(trulyReadOnly),\n      \"data-checked\": dataAttr(checked),\n      \"data-disabled\": dataAttr(trulyDisabled),\n      \"data-orientation\": orientation,\n      \"data-readonly\": dataAttr(trulyReadOnly),\n      \"data-root-disabled\": dataAttr(rootDisabled),\n      \"data-root-readonly\": dataAttr(rootReadOnly),\n      ...props,\n      ...rest,\n    }),\n    [\n      orientation,\n      trulyDisabled,\n      trulyReadOnly,\n      checked,\n      rootDisabled,\n      rootReadOnly,\n      rest,\n    ],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      type: \"radio\",\n      name,\n      style: visuallyHiddenAttributes.style,\n      \"aria-disabled\": ariaAttr(trulyDisabled),\n      \"aria-readonly\": ariaAttr(trulyReadOnly),\n      \"data-checked\": dataAttr(checked),\n      \"data-disabled\": dataAttr(trulyDisabled),\n      \"data-orientation\": orientation,\n      \"data-readonly\": dataAttr(trulyReadOnly),\n      checked,\n      disabled: trulyDisabled || trulyReadOnly,\n      readOnly: trulyReadOnly,\n      tabIndex: interactive ? undefined : -1,\n      value,\n      ...inputProps,\n      ...props,\n      ref: mergeRefs(register, ref),\n      onChange: handlerAll(props.onChange, inputProps?.onChange, onChange),\n    }),\n    [\n      orientation,\n      name,\n      trulyDisabled,\n      trulyReadOnly,\n      checked,\n      interactive,\n      value,\n      inputProps,\n      register,\n      onChange,\n    ],\n  )\n\n  return {\n    checked,\n    getInputProps,\n    getLabelProps,\n  }\n}\n\nexport type UseSegmentedControlItemReturn = ReturnType<\n  typeof useSegmentedControlItem\n>\n"
    }
  ]
}
