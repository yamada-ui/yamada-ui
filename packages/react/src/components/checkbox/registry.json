{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["group", "input", "icon", "field"],
    "externals": [],
    "hooks": ["use-controllable-state"],
    "providers": []
  },
  "dependents": {
    "components": ["checkbox-card", "table"],
    "hooks": [],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "checkbox-group.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement, ReactNode } from \"react\"\nimport type {\n  GenericsComponent,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type { GroupProps } from \"../group\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { CheckboxProps } from \"./checkbox\"\nimport type { CheckboxStyle } from \"./checkbox.style\"\nimport type { UseCheckboxGroupProps } from \"./use-checkbox-group\"\nimport { useMemo } from \"react\"\nimport { Group } from \"../group\"\nimport {\n  Checkbox,\n  CheckboxPropsContext,\n  component,\n  useRootComponentProps,\n} from \"./checkbox\"\nimport { CheckboxGroupContext, useCheckboxGroup } from \"./use-checkbox-group\"\n\nexport interface CheckboxGroupItem<Y extends string = string>\n  extends CheckboxProps<Y> {\n  label: ReactNode\n}\n\nexport interface CheckboxGroupRootProps<Y extends string = string>\n  extends Omit<\n      WithoutThemeProps<GroupProps, CheckboxStyle>,\n      \"defaultValue\" | \"onChange\" | \"value\"\n    >,\n    ThemeProps<CheckboxStyle>,\n    UseCheckboxGroupProps<Y>,\n    UseInputBorderProps,\n    Pick<CheckboxProps, \"checkedIcon\"> {\n  /**\n   * If provided, generate options based on items.\n   *\n   * @default []\n   */\n  items?: CheckboxGroupItem<Y>[]\n}\n\n/**\n * `CheckboxGroup` is a component that groups `Checkbox` components.\n *\n * @see https://yamada-ui.com/docs/components/checkbox\n */\nexport const CheckboxGroupRoot = component<\"div\", CheckboxGroupRootProps>(\n  (props) => {\n    const [\n      ,\n      {\n        colorScheme,\n        size,\n        variant,\n        checkedIcon,\n        children,\n        disabled,\n        errorBorderColor,\n        focusBorderColor,\n        invalid,\n        items = [],\n        readOnly,\n        shape,\n        ...rest\n      },\n    ] = useRootComponentProps(props, \"group\", {\n      transferProps: [\"variant\", \"colorScheme\", \"size\", \"shape\"],\n    })\n    const { max, value, getInputProps, getLabelProps, getRootProps, onChange } =\n      useCheckboxGroup(rest)\n    const computedChildren = useMemo(() => {\n      if (children) return children\n\n      return items.map(({ label, value, ...rest }, index) => (\n        <Checkbox key={value ?? index} value={value} {...rest}>\n          {label}\n        </Checkbox>\n      ))\n    }, [items, children])\n    const context = useMemo(\n      () => ({\n        colorScheme,\n        size,\n        variant,\n        checkedIcon,\n        disabled,\n        errorBorderColor,\n        focusBorderColor,\n        invalid,\n        readOnly,\n        shape,\n      }),\n      [\n        variant,\n        size,\n        colorScheme,\n        shape,\n        disabled,\n        invalid,\n        readOnly,\n        errorBorderColor,\n        focusBorderColor,\n        checkedIcon,\n      ],\n    )\n    const groupContext = useMemo(\n      () => ({ max, value, getInputProps, getLabelProps, onChange }),\n      [max, value, getInputProps, getLabelProps, onChange],\n    )\n\n    return (\n      <CheckboxPropsContext value={context}>\n        <CheckboxGroupContext value={groupContext}>\n          <Group orientation=\"vertical\" {...getRootProps()}>\n            {computedChildren}\n          </Group>\n        </CheckboxGroupContext>\n      </CheckboxPropsContext>\n    )\n  },\n  \"group\",\n)() as GenericsComponent<{\n  <Y extends string = string>(props: CheckboxGroupRootProps<Y>): ReactElement\n}>\n\nexport { Checkbox as CheckboxGroupItem }\n"
    },
    {
      "name": "checkbox.style.ts",
      "content": "import { defineComponentSlotStyle, focusRingStyle } from \"@yamada-ui/react\"\n\nexport const checkboxStyle = defineComponentSlotStyle({\n  base: {\n    group: {},\n    indicator: {\n      alignItems: \"center\",\n      borderColor: \"{indicator-border-color}\",\n      borderWidth: \"2px\",\n      boxSize: \"{indicator-size}\",\n      display: \"inline-flex\",\n      focusRingColor: \"{focus-border-color}\",\n      \"input:focus-visible + &\": focusRingStyle.outline,\n      justifyContent: \"center\",\n      _invalid: {\n        borderColor: \"{error-border-color}\",\n        focusRingColor: \"{error-border-color}\",\n      },\n    },\n    label: {},\n    root: {\n      \"--error-border-color\": \"colors.border.error\",\n      \"--focus-border-color\": \"colorScheme.outline\",\n      \"--indicator-border-color\": \"colors.border.emphasized\",\n      alignItems: \"center\",\n      display: \"flex\",\n      fontSize: \"{label-size}\",\n      gap: \"2\",\n      userSelect: \"none\",\n      _readOnly: { layerStyle: \"readOnly\" },\n      _disabled: { layerStyle: \"disabled\" },\n    },\n  },\n\n  props: {\n    /**\n     * The shape of the component\n     *\n     * @default 'rounded'\n     */\n    shape: {\n      rounded: {\n        indicator: { rounded: \"l1\" },\n      },\n      square: {\n        indicator: { rounded: \"0\" },\n      },\n    },\n  },\n\n  variants: {\n    outline: {\n      indicator: { color: \"colorScheme.outline\" },\n      root: {\n        _checked: { \"--indicator-border-color\": \"colorScheme.outline\" },\n        _indeterminate: { \"--indicator-border-color\": \"colorScheme.outline\" },\n      },\n    },\n    solid: {\n      indicator: {\n        color: \"colorScheme.contrast\",\n        _checked: { bg: \"colorScheme.solid\" },\n        _indeterminate: { bg: \"colorScheme.solid\" },\n      },\n      root: {\n        _checked: { \"--indicator-border-color\": \"colorScheme.solid\" },\n        _indeterminate: { \"--indicator-border-color\": \"colorScheme.solid\" },\n      },\n    },\n    subtle: {\n      indicator: { bg: \"colorScheme.subtle\", color: \"colorScheme.fg\" },\n      root: { \"--indicator-border-color\": \"transparent\" },\n    },\n    surface: {\n      indicator: { bg: \"colorScheme.subtle\", color: \"colorScheme.fg\" },\n      root: { \"--indicator-border-color\": \"colorScheme.muted\" },\n    },\n  },\n\n  sizes: {\n    sm: {\n      indicator: { fontSize: \"xs\" },\n      root: { \"--indicator-size\": \"sizes.3.5\", \"--label-size\": \"fontSizes.sm\" },\n    },\n    md: {\n      indicator: { fontSize: \"sm\" },\n      root: { \"--indicator-size\": \"sizes.4\", \"--label-size\": \"fontSizes.md\" },\n    },\n    lg: {\n      indicator: { fontSize: \"md\" },\n      root: { \"--indicator-size\": \"sizes.5\", \"--label-size\": \"fontSizes.lg\" },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"solid\",\n    shape: \"rounded\",\n  },\n})\n\nexport type CheckboxStyle = typeof checkboxStyle\n"
    },
    {
      "name": "checkbox.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement, ReactNode } from \"react\"\nimport type {\n  GenericsComponent,\n  HTMLStyledProps,\n  ThemeProps,\n  Merge,\n} from \"@yamada-ui/react\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { CheckboxStyle } from \"./checkbox.style\"\nimport type { UseCheckboxProps } from \"./use-checkbox\"\nimport { useMemo } from \"react\"\nimport { createSlotComponent, styled } from \"@yamada-ui/react\"\nimport { CheckIcon, MinusIcon } from \"../icon\"\nimport { useInputBorder } from \"../input\"\nimport { checkboxStyle } from \"./checkbox.style\"\nimport { useCheckbox } from \"./use-checkbox\"\n\nexport interface CheckboxProps<Y extends string = string>\n  extends Merge<HTMLStyledProps<\"label\">, UseCheckboxProps<Y>>,\n    ThemeProps<CheckboxStyle>,\n    UseInputBorderProps {\n  /**\n   * The icon to display in the checkbox when it is checked.\n   */\n  checkedIcon?: ReactNode\n  /**\n   * The icon to display in the checkbox when it is indeterminate.\n   */\n  indeterminateIcon?: ReactNode\n  /**\n   * Props for the indicator component.\n   */\n  indicatorProps?: CheckboxIndicatorProps\n  /**\n   * Props for the input element.\n   */\n  inputProps?: HTMLStyledProps<\"input\">\n  /**\n   * Props for the label component.\n   */\n  labelProps?: CheckboxLabelProps\n  /**\n   * Props for the label element.\n   */\n  rootProps?: HTMLStyledProps<\"label\">\n}\n\nconst {\n  component,\n  PropsContext: CheckboxPropsContext,\n  usePropsContext: useCheckboxPropsContext,\n  withContext,\n  withProvider,\n  useRootComponentProps,\n} = createSlotComponent<CheckboxProps, CheckboxStyle>(\"checkbox\", checkboxStyle)\n\nexport {\n  CheckboxPropsContext,\n  component,\n  useCheckboxPropsContext,\n  useRootComponentProps,\n}\n\n/**\n * `Checkbox` is a component used for allowing users to select multiple values from multiple options.\n *\n * @see https://yamada-ui.com/docs/components/checkbox\n */\nexport const Checkbox = withProvider<\"label\", CheckboxProps>(\n  ({\n    checkedIcon,\n    children,\n    errorBorderColor,\n    focusBorderColor,\n    indeterminateIcon,\n    indicatorProps,\n    inputProps,\n    labelProps,\n    rootProps,\n    ...rest\n  }) => {\n    const {\n      checked,\n      indeterminate,\n      getIndicatorProps,\n      getInputProps,\n      getRootProps,\n    } = useCheckbox(rest)\n    const varProps = useInputBorder({ errorBorderColor, focusBorderColor })\n    const icon = useMemo(() => {\n      if (indeterminate) {\n        return indeterminateIcon || <MinusIcon />\n      } else if (checked) {\n        return checkedIcon || <CheckIcon />\n      } else {\n        return null\n      }\n    }, [indeterminate, indeterminateIcon, checked, checkedIcon])\n    const input = useMemo(() => {\n      return <styled.input {...getInputProps(inputProps)} />\n    }, [getInputProps, inputProps])\n    const indicator = useMemo(() => {\n      return (\n        <CheckboxIndicator {...getIndicatorProps(indicatorProps)}>\n          {icon}\n        </CheckboxIndicator>\n      )\n    }, [getIndicatorProps, indicatorProps, icon])\n\n    return (\n      <styled.label {...getRootProps({ ...varProps, ...rootProps })}>\n        {input}\n        {indicator}\n        {children ? (\n          <CheckboxLabel {...labelProps}>{children}</CheckboxLabel>\n        ) : null}\n      </styled.label>\n    )\n  },\n  \"root\",\n)() as GenericsComponent<{\n  <Y extends string = string>(props: CheckboxProps<Y>): ReactElement\n}>\n\ninterface CheckboxIndicatorProps extends HTMLStyledProps {}\n\nconst CheckboxIndicator = withContext<\"div\", CheckboxIndicatorProps>(\n  \"div\",\n  \"indicator\",\n)()\n\ninterface CheckboxLabelProps extends HTMLStyledProps<\"span\"> {}\n\nconst CheckboxLabel = withContext<\"span\", CheckboxLabelProps>(\"span\", \"label\")()\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./checkbox.style\"\nexport {\n  Checkbox,\n  CheckboxPropsContext,\n  useCheckboxPropsContext,\n} from \"./checkbox\"\nexport type { CheckboxProps } from \"./checkbox\"\nexport { CheckboxGroupItem, CheckboxGroupRoot } from \"./checkbox-group\"\nexport type { CheckboxGroupRootProps } from \"./checkbox-group\"\nexport * as CheckboxGroup from \"./namespace\"\nexport * from \"./use-checkbox\"\nexport * from \"./use-checkbox-group\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  CheckboxPropsContext as PropsContext,\n  useCheckboxPropsContext as usePropsContext,\n} from \"./checkbox\"\nexport type { CheckboxProps as ItemProps } from \"./checkbox\"\nexport {\n  CheckboxGroupItem as Item,\n  CheckboxGroupRoot as Root,\n} from \"./checkbox-group\"\nexport type { CheckboxGroupRootProps as RootProps } from \"./checkbox-group\"\n"
    },
    {
      "name": "use-checkbox-group.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport {\n  ariaAttr,\n  createContext,\n  cx,\n  dataAttr,\n  handlerAll,\n  isNumber,\n  isObject,\n  isString,\n  isUndefined,\n  mergeRefs,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\ninterface CheckboxGroupContext\n  extends Omit<UseCheckboxGroupReturn, \"getRootProps\"> {}\n\nconst [CheckboxGroupContext, useCheckboxGroupContext] =\n  createContext<CheckboxGroupContext>({\n    name: \"CheckboxGroupContext\",\n    strict: false,\n  })\n\nexport { CheckboxGroupContext, useCheckboxGroupContext }\n\nexport interface UseCheckboxGroupProps<Y extends string = string>\n  extends Omit<HTMLProps, \"defaultValue\" | \"onChange\" | \"value\">,\n    FieldProps {\n  /**\n   * The initial value of the checkbox group.\n   *\n   * @default []\n   */\n  defaultValue?: Y[]\n  /**\n   * The maximum number of checkboxes that can be checked.\n   */\n  max?: number\n  /**\n   * The value of the checkbox group.\n   */\n  value?: Y[]\n  /**\n   * The callback fired when any children checkbox is checked or unchecked.\n   */\n  onChange?: (value: Y[]) => void\n}\n\nexport const useCheckboxGroup = <Y extends string = string>(\n  props: UseCheckboxGroupProps<Y> = {},\n) => {\n  const {\n    context: { labelId } = {},\n    props: {\n      defaultValue = [],\n      disabled,\n      max,\n      readOnly,\n      required,\n      value: valueProp,\n      onChange: onChangeProp,\n      ...rest\n    },\n    ariaProps: { \"aria-describedby\": ariaDescribedbyProp, ...ariaProps },\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const interactive = !(readOnly || disabled)\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n\n  const onChange = useCallback(\n    (valueOrEv: ChangeEvent<HTMLInputElement> | Y) => {\n      if (!interactive) return\n\n      if (isObject(valueOrEv)) valueOrEv = valueOrEv.target.value as Y\n\n      setValue((prev) => {\n        if (prev.includes(valueOrEv)) {\n          return prev.filter((prevValue) => prevValue !== valueOrEv)\n        } else if (!isNumber(max) || prev.length < max) {\n          return [...prev, valueOrEv]\n        } else {\n          return prev\n        }\n      })\n    },\n    [interactive, max, setValue],\n  )\n\n  const getRootProps: PropGetter = useCallback(\n    ({\n      ref,\n      \"aria-describedby\": ariaDescribedby,\n      \"aria-labelledby\": ariaLabelledby,\n      ...props\n    } = {}) => ({\n      ...dataProps,\n      \"aria-describedby\": cx(ariaDescribedbyProp, ariaDescribedby),\n      \"aria-labelledby\": cx(labelId, ariaLabelledby),\n      role: \"group\",\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref),\n    }),\n    [ariaDescribedbyProp, dataProps, labelId, rest],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    (props = {}) => {\n      const checked =\n        !isUndefined(value) &&\n        (isString(props.value) || isNumber(props.value)) &&\n        value.includes(props.value as Y)\n      const trulyDisabled = !checked && isNumber(max) && value.length >= max\n\n      return {\n        ...dataProps,\n        ...ariaProps,\n        type: \"checkbox\",\n        style: visuallyHiddenAttributes.style,\n        \"aria-checked\": checked,\n        \"aria-disabled\": ariaAttr(trulyDisabled),\n        \"data-checked\": dataAttr(checked),\n        \"data-disabled\": dataAttr(trulyDisabled),\n        checked,\n        disabled: trulyDisabled,\n        readOnly,\n        required,\n        ...props,\n        onBlur: handlerAll(props.onBlur, eventProps.onBlur),\n        onChange: handlerAll(props.onChange, onChange),\n        onFocus: handlerAll(props.onFocus, eventProps.onFocus),\n      }\n    },\n    [\n      ariaProps,\n      dataProps,\n      eventProps,\n      max,\n      onChange,\n      readOnly,\n      required,\n      value,\n    ],\n  )\n\n  const getLabelProps: PropGetter<\"label\"> = useCallback(\n    (props) => ({\n      ...dataProps,\n      ...props,\n    }),\n    [dataProps],\n  )\n\n  return {\n    max,\n    value,\n    getInputProps,\n    getLabelProps,\n    getRootProps,\n    onChange,\n  }\n}\n\nexport type UseCheckboxGroupReturn = ReturnType<typeof useCheckboxGroup>\n"
    },
    {
      "name": "use-checkbox.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent, ChangeEventHandler, FocusEventHandler } from \"react\"\nimport type { HTMLProps, HTMLRefAttributes, PropGetter } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useId } from \"react\"\nimport { useControllableEventState } from \"../../hooks/use-controllable-state\"\nimport {\n  ariaAttr,\n  cx,\n  dataAttr,\n  handlerAll,\n  isNumber,\n  isUndefined,\n  mergeRefs,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\nimport { useCheckboxGroupContext } from \"./use-checkbox-group\"\n\nexport interface UseCheckboxProps<Y extends string = string>\n  extends Omit<HTMLProps<\"label\">, \"onBlur\" | \"onChange\" | \"onFocus\" | \"ref\">,\n    HTMLRefAttributes<\"input\">,\n    FieldProps {\n  /**\n   * id assigned to input.\n   */\n  id?: string\n  /**\n   * The name of the input field in a checkbox.\n   */\n  name?: string\n  /**\n   * If `true`, the checkbox will be checked.\n   */\n  checked?: boolean\n  /**\n   * If `true`, the checkbox will be initially checked.\n   *\n   * @default false\n   */\n  defaultChecked?: boolean\n  /**\n   * If `true`, the checkbox will be indeterminate.\n   *\n   * @default false\n   */\n  indeterminate?: boolean\n  /**\n   * The value of the checkbox.\n   */\n  value?: Y\n  /**\n   * The callback invoked when the checkbox is blurred.\n   */\n  onBlur?: FocusEventHandler<HTMLInputElement>\n  /**\n   * The callback invoked when the checked state changes.\n   */\n  onChange?: ChangeEventHandler<HTMLInputElement>\n  /**\n   * The callback invoked when the checkbox is focused.\n   */\n  onFocus?: FocusEventHandler<HTMLInputElement>\n}\n\nexport const useCheckbox = <Y extends string = string>({\n  \"aria-describedby\": ariaDescribedbyProp,\n  ...props\n}: UseCheckboxProps<Y> = {}) => {\n  const group = useCheckboxGroupContext()\n  const {\n    max,\n    value: groupValue,\n    getInputProps: getGroupInputProps,\n    getLabelProps,\n  } = group ?? {}\n  const uuid = useId()\n  const {\n    props: {\n      id,\n      ref,\n      name,\n      checked: checkedProp,\n      defaultChecked = false,\n      disabled,\n      indeterminate = false,\n      readOnly,\n      required,\n      value,\n      onChange: onChangeProp,\n      ...rest\n    },\n    ariaProps: { \"aria-describedby\": ariaDescribedby, ...ariaProps },\n    dataProps,\n    eventProps,\n  } = useFieldProps({\n    id: group ? uuid : undefined,\n    ...props,\n    notSupportReadOnly: true,\n  })\n  const resolvedAriaDescribedby = group ? ariaDescribedbyProp : ariaDescribedby\n  const resolvedChecked =\n    !isUndefined(groupValue) && !isUndefined(value)\n      ? groupValue.includes(value)\n      : checkedProp\n  const [checked, setChecked] = useControllableEventState({\n    defaultValue: defaultChecked,\n    value: resolvedChecked,\n    onChange: onChangeProp,\n  })\n  const trulyDisabled =\n    !checked && isNumber(max) && group && group.value.length >= max\n  const interactive = !(readOnly || trulyDisabled)\n\n  const onChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      if (!interactive) return (ev.defaultPrevented = true)\n\n      if (indeterminate) ev.target.checked = true\n\n      setChecked(ev)\n    },\n    [interactive, indeterminate, setChecked],\n  )\n\n  const getRootProps: PropGetter<\"label\"> = useCallback(\n    (props = {}) => {\n      const sharedProps = {\n        ...dataProps,\n        \"data-checked\": dataAttr(checked),\n        \"data-indeterminate\": dataAttr(indeterminate),\n        ...rest,\n        ...props,\n      }\n\n      return getLabelProps?.(sharedProps) ?? sharedProps\n    },\n    [dataProps, checked, indeterminate, rest, getLabelProps],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    ({ \"aria-describedby\": ariaDescribedby, ...props } = {}) => {\n      const sharedProps = {\n        ...dataProps,\n        ...ariaProps,\n        id,\n        type: \"checkbox\",\n        name,\n        style: visuallyHiddenAttributes.style,\n        \"aria-checked\": indeterminate ? (\"mixed\" as const) : checked,\n        \"aria-describedby\": cx(resolvedAriaDescribedby, ariaDescribedby),\n        \"aria-disabled\": ariaAttr(!interactive),\n        \"data-checked\": dataAttr(checked),\n        \"data-indeterminate\": dataAttr(indeterminate),\n        checked,\n        disabled,\n        readOnly,\n        required,\n        value,\n        ...props,\n        ref: mergeRefs(props.ref, ref),\n        onBlur: handlerAll(props.onBlur, eventProps.onBlur),\n        onChange: handlerAll(props.onChange, onChange),\n        onFocus: handlerAll(props.onFocus, eventProps.onFocus),\n      }\n\n      return getGroupInputProps?.(sharedProps) ?? sharedProps\n    },\n    [\n      dataProps,\n      ariaProps,\n      id,\n      name,\n      indeterminate,\n      checked,\n      resolvedAriaDescribedby,\n      interactive,\n      disabled,\n      readOnly,\n      required,\n      value,\n      ref,\n      eventProps,\n      onChange,\n      getGroupInputProps,\n    ],\n  )\n\n  const getIndicatorProps: PropGetter = useCallback(\n    (props = {}) => ({\n      ...dataProps,\n      \"aria-hidden\": \"true\",\n      \"data-checked\": dataAttr(checked),\n      \"data-indeterminate\": dataAttr(indeterminate),\n      ...props,\n    }),\n    [dataProps, checked, indeterminate],\n  )\n\n  return {\n    checked,\n    indeterminate,\n    getIndicatorProps,\n    getInputProps,\n    getRootProps,\n    onChange,\n  }\n}\n\nexport type UseCheckboxReturn = ReturnType<typeof useCheckbox>\n"
    }
  ]
}
