{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": ["scroll-into-view-if-needed@^3.1.0"],
    "hooks": ["use-descendants", "use-disclosure"],
    "providers": []
  },
  "dependents": {
    "components": ["autocomplete", "date-picker", "select"],
    "hooks": [],
    "providers": []
  },
  "section": "hooks",
  "sources": [
    {
      "name": "index.tsx",
      "content": "\"use client\"\n\nimport type {\n  JSXElementConstructor,\n  KeyboardEvent,\n  MouseEvent,\n  ReactNode,\n  RefObject,\n} from \"react\"\nimport type { HTMLProps, PropGetter, SimpleDirection } from \"@yamada-ui/react\"\nimport type { Descendant } from \"../use-descendants\"\nimport type { UseDisclosureProps } from \"../use-disclosure\"\nimport { useCallback, useId, useRef } from \"react\"\nimport scrollIntoView from \"scroll-into-view-if-needed\"\nimport {\n  useEnvironment,\n  ariaAttr,\n  createContext,\n  cx,\n  dataAttr,\n  findChild,\n  getValidChildren,\n  handlerAll,\n  isComposing,\n  isSomeElement,\n  isUndefined,\n  mergeRefs,\n  runKeyAction,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\nimport { createDescendants } from \"../use-descendants\"\nimport { useDisclosure } from \"../use-disclosure\"\n\ninterface ComboboxSharedItem extends Omit<HTMLProps, \"children\" | \"value\"> {\n  label: ReactNode\n}\n\nexport interface ComboboxItemWithValue extends ComboboxSharedItem {\n  query?: string\n  value?: string\n}\n\nexport interface ComboboxItemWithItems extends ComboboxSharedItem {\n  items: ComboboxItemWithValue[]\n}\n\nexport type ComboboxItem = ComboboxItemWithItems | ComboboxItemWithValue\n\nexport interface CreateComboboxItemOptions {\n  Group: JSXElementConstructor<any>\n  Label: JSXElementConstructor<any>\n  Option: JSXElementConstructor<any>\n}\n\nexport const createComboboxItem = (\n  children: ReactNode,\n  { Group, Label, Option }: CreateComboboxItemOptions,\n) => {\n  const validChildren = getValidChildren(children)\n\n  return validChildren\n    .filter(\n      ({ type }) => isSomeElement(type, Option) || isSomeElement(type, Group),\n    )\n    .map(({ type, props }) => {\n      if (isSomeElement(type, Option)) {\n        return { ...props, label: props.children }\n      } else {\n        const validChildren = getValidChildren(props.children)\n        const label = findChild(validChildren, Label)\n\n        return {\n          ...props,\n          items: validChildren\n            .filter(({ type }) => isSomeElement(type, Option))\n            .map(({ props }) => ({ ...props, label: props.children })),\n          label: label?.props.children ?? props.label,\n        }\n      }\n    })\n}\n\nexport interface CreateComboboxChildrenOptions {\n  Group: JSXElementConstructor<any>\n  Option: JSXElementConstructor<any>\n  Empty?: JSXElementConstructor<any>\n}\n\nexport const createComboboxChildren = (\n  items: ComboboxItem[],\n  { Empty, Group, Option }: CreateComboboxChildrenOptions,\n) => {\n  return items.map((item, index) => {\n    if (\"data-empty\" in item && Empty) {\n      const { label, ...rest } = item\n\n      return (\n        <Empty key={index} {...rest}>\n          {label}\n        </Empty>\n      )\n    } else if (\"items\" in item) {\n      const { items = [], label, ...rest } = item\n\n      return (\n        <Group key={index} label={label} {...rest}>\n          {items.map(({ label, ...rest }, index) => (\n            <Option key={index} {...rest}>\n              {label}\n            </Option>\n          ))}\n        </Group>\n      )\n    } else {\n      const { label, ...rest } = item\n\n      return (\n        <Option key={index} {...rest}>\n          {label}\n        </Option>\n      )\n    }\n  })\n}\n\nexport interface ComboboxDescendantProps {\n  id: string\n  closeOnSelect?: boolean\n  value?: string\n}\nexport type ComboboxDescendant = Descendant<\n  HTMLDivElement,\n  ComboboxDescendantProps\n>\n\nconst {\n  DescendantsContext: ComboboxDescendantsContext,\n  useDescendant: useComboboxDescendant,\n  useDescendantRegister: useComboboxDescendantRegister,\n  useDescendants: useComboboxDescendants,\n} = createDescendants<HTMLDivElement, ComboboxDescendantProps>()\n\nexport {\n  ComboboxDescendantsContext,\n  useComboboxDescendant,\n  useComboboxDescendantRegister,\n  useComboboxDescendants,\n}\n\ninterface ComboboxContext\n  extends Pick<\n    UseComboboxReturn,\n    \"onActiveDescendant\" | \"onClose\" | \"onSelect\"\n  > {}\n\nconst [ComboboxContext, useComboboxContext] = createContext<ComboboxContext>({\n  name: \"ComboboxContext\",\n})\n\ninterface ComboboxGroupContext\n  extends Pick<UseComboboxGroupReturn, \"getLabelProps\"> {}\n\nconst [ComboboxGroupContext, useComboboxGroupContext] =\n  createContext<ComboboxGroupContext>({\n    name: \"ComboboxGroupContext\",\n  })\n\nexport {\n  ComboboxContext,\n  ComboboxGroupContext,\n  useComboboxContext,\n  useComboboxGroupContext,\n}\n\nexport interface UseComboboxProps\n  extends Omit<HTMLProps, \"onChange\">,\n    Omit<UseDisclosureProps, \"timing\"> {\n  /**\n   * If `true`, the list element will be closed when value is selected.\n   *\n   * @default true\n   */\n  closeOnSelect?: boolean\n  /**\n   * If `true`, the combobox will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * The value to focus on when the combobox is opened.\n   */\n  initialFocusValue?: string\n  /**\n   * If `true`, the combobox will be opened when click on the field.\n   *\n   * @default true\n   */\n  openOnClick?: boolean\n  /**\n   * If `true`, the combobox will be opened when enter is pressed.\n   *\n   * @default true\n   */\n  openOnEnter?: boolean\n  /**\n   * If `true`, the combobox will be opened when space is pressed.\n   *\n   * @default true\n   */\n  openOnSpace?: boolean\n  /**\n   * If `true`, the combobox will be readonly.\n   *\n   * @default false\n   */\n  readOnly?: boolean\n  /**\n   * The `ref` of the element that should receive focus when selected.\n   */\n  selectFocusRef?: RefObject<HTMLElement | null>\n  /**\n   * If `true`, the item will be selected when space is pressed.\n   *\n   * @default true\n   */\n  selectOnSpace?: boolean\n  /**\n   * The callback invoked when value is selected.\n   */\n  onChange?: (value: string) => void\n}\n\nexport const useCombobox = ({\n  \"aria-label\": ariaLabelProp,\n  \"aria-labelledby\": ariaLabelledbyProp,\n  closeOnSelect: closeOnSelectProp = true,\n  defaultOpen,\n  disabled,\n  initialFocusValue,\n  open: openProp,\n  openOnClick = true,\n  openOnEnter = true,\n  openOnSpace = true,\n  readOnly,\n  selectFocusRef,\n  selectOnSpace = true,\n  onChange: onChangeProp,\n  onClose: onCloseProp,\n  onOpen: onOpenProp,\n  ...rest\n}: UseComboboxProps = {}) => {\n  const { getWindow } = useEnvironment()\n  const interactive = !(readOnly || disabled)\n  const triggerRef = useRef<HTMLDivElement>(null)\n  const contentRef = useRef<HTMLDivElement>(null)\n  const contentId = useId()\n  const descendants = useComboboxDescendants()\n  const { open, onClose, onOpen } = useDisclosure({\n    defaultOpen,\n    open: openProp,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n  })\n  const activeDescendant = useRef<ComboboxDescendant | null>(null)\n\n  const onSelect = useCallback(\n    (value?: string, closeOnSelect = closeOnSelectProp) => {\n      const ref = selectFocusRef ?? triggerRef\n\n      ref.current?.focus()\n\n      if (!interactive || isUndefined(value)) return\n\n      onChangeProp?.(value)\n\n      if (!closeOnSelect) return\n\n      onClose()\n    },\n    [closeOnSelectProp, interactive, onChangeProp, onClose, selectFocusRef],\n  )\n\n  const onScrollIntoView = useCallback(\n    (descendant?: ComboboxDescendant, block: SimpleDirection = \"start\") => {\n      if (!contentRef.current || !descendant) return\n\n      const style = getWindow()?.getComputedStyle(contentRef.current)\n      const padding =\n        block === \"start\" ? style?.paddingBlockStart : style?.paddingBlockEnd\n      const value = parseInt(padding ?? \"0px\")\n\n      scrollIntoView(descendant.node, {\n        behavior: (actions) =>\n          actions.forEach(({ el, top }) => {\n            el.scrollTop = block === \"start\" ? top - value : top + value\n          }),\n        block,\n        boundary: contentRef.current,\n        inline: \"nearest\",\n        scrollMode: \"if-needed\",\n      })\n    },\n    [getWindow],\n  )\n\n  const onActiveDescendant = useCallback(\n    (descendant?: ComboboxDescendant) => {\n      if (!triggerRef.current || !descendant || disabled) return\n\n      triggerRef.current.setAttribute(\"aria-activedescendant\", descendant.id)\n\n      activeDescendant.current = descendant\n\n      descendants.active(descendant)\n    },\n    [descendants, disabled],\n  )\n\n  const onOpenWithActiveDescendant = useCallback(\n    (\n      getFallbackDescendant: () => ComboboxDescendant | undefined,\n      block: SimpleDirection = \"start\",\n    ) => {\n      onOpen()\n\n      setTimeout(() => {\n        if (!initialFocusValue) {\n          const descendant = getFallbackDescendant()\n\n          onActiveDescendant(descendant)\n          onScrollIntoView(descendant, block)\n        } else {\n          const values = descendants.values()\n          const descendant =\n            values.find(({ value }) => initialFocusValue === value) ??\n            getFallbackDescendant()\n\n          onActiveDescendant(descendant)\n          onScrollIntoView(descendant, block)\n        }\n      })\n    },\n    [\n      descendants,\n      initialFocusValue,\n      onActiveDescendant,\n      onOpen,\n      onScrollIntoView,\n    ],\n  )\n\n  const onClick = useCallback(\n    (ev: MouseEvent<HTMLDivElement>) => {\n      if (disabled) return\n\n      ev.preventDefault()\n\n      if (!open) {\n        if (openOnClick)\n          onOpenWithActiveDescendant(descendants.enabledFirstValue)\n      } else {\n        onClose()\n      }\n    },\n    [\n      descendants,\n      disabled,\n      onClose,\n      onOpenWithActiveDescendant,\n      open,\n      openOnClick,\n    ],\n  )\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLDivElement>) => {\n      if (disabled || isComposing(ev)) return\n\n      runKeyAction(\n        ev,\n        {\n          ArrowDown: (ev) => {\n            ev.preventDefault()\n\n            if (!open) {\n              onOpenWithActiveDescendant(descendants.enabledFirstValue)\n            } else if (activeDescendant.current) {\n              const descendant = descendants.enabledNextValue(\n                activeDescendant.current,\n              )\n\n              onActiveDescendant(descendant)\n\n              onScrollIntoView(\n                descendant,\n                descendant?.recurred ? \"start\" : \"end\",\n              )\n            } else {\n              const descendant = descendants.enabledFirstValue()\n\n              onActiveDescendant(descendant)\n\n              onScrollIntoView(descendant)\n            }\n          },\n          ArrowUp: (ev) => {\n            ev.preventDefault()\n\n            if (!open) {\n              onOpenWithActiveDescendant(descendants.enabledLastValue, \"end\")\n            } else if (activeDescendant.current) {\n              const descendant = descendants.enabledPrevValue(\n                activeDescendant.current,\n              )\n\n              onActiveDescendant(descendant)\n\n              onScrollIntoView(\n                descendant,\n                descendant?.recurred ? \"end\" : \"start\",\n              )\n            } else {\n              const descendant = descendants.enabledLastValue()\n\n              onActiveDescendant(descendant)\n\n              onScrollIntoView(descendant, \"end\")\n            }\n          },\n          End: (ev) => {\n            ev.preventDefault()\n\n            if (!open) return\n\n            const descendant = descendants.enabledLastValue()\n\n            onActiveDescendant(descendant)\n\n            onScrollIntoView(descendant, \"end\")\n          },\n          Enter: (ev) => {\n            if (!open) {\n              if (!openOnEnter) return\n\n              ev.preventDefault()\n\n              onOpenWithActiveDescendant(descendants.enabledFirstValue)\n            } else {\n              if (!activeDescendant.current) return\n\n              ev.preventDefault()\n\n              const { closeOnSelect, value } = activeDescendant.current\n\n              onSelect(value, closeOnSelect)\n            }\n          },\n          Home: (ev) => {\n            if (!open) return\n\n            ev.preventDefault()\n\n            const descendant = descendants.enabledFirstValue()\n\n            onActiveDescendant(descendant)\n\n            onScrollIntoView(descendant)\n          },\n          Space: (ev) => {\n            if (!open) {\n              if (!openOnSpace) return\n\n              ev.preventDefault()\n\n              onOpenWithActiveDescendant(descendants.enabledFirstValue)\n            } else {\n              if (!activeDescendant.current || !selectOnSpace) return\n\n              ev.preventDefault()\n\n              const { closeOnSelect, value } = activeDescendant.current\n\n              onSelect(value, closeOnSelect)\n            }\n          },\n        },\n        { preventDefault: false },\n      )\n    },\n    [\n      disabled,\n      open,\n      onOpenWithActiveDescendant,\n      descendants,\n      onActiveDescendant,\n      onScrollIntoView,\n      openOnEnter,\n      onSelect,\n      openOnSpace,\n      selectOnSpace,\n    ],\n  )\n\n  useUpdateEffect(() => {\n    if (open) return\n\n    activeDescendant.current = null\n  }, [open])\n\n  const getTriggerProps: PropGetter = useCallback(\n    ({\n      ref,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledby,\n      ...props\n    } = {}) => ({\n      \"aria-controls\": open ? contentId : undefined,\n      \"aria-disabled\": ariaAttr(!interactive),\n      \"aria-expanded\": open,\n      \"aria-haspopup\": \"listbox\",\n      \"aria-label\": ariaLabel || ariaLabelProp,\n      \"aria-labelledby\": cx(ariaLabelledby, ariaLabelledbyProp),\n      \"data-disabled\": dataAttr(disabled),\n      \"data-readonly\": dataAttr(readOnly),\n      role: \"combobox\",\n      tabIndex: interactive ? 0 : -1,\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref, triggerRef),\n      onClick: handlerAll(props.onClick, rest.onClick, onClick),\n      onKeyDown: handlerAll(props.onKeyDown, rest.onKeyDown, onKeyDown),\n    }),\n    [\n      open,\n      contentId,\n      interactive,\n      ariaLabelledbyProp,\n      disabled,\n      readOnly,\n      ariaLabelProp,\n      rest,\n      onClick,\n      onKeyDown,\n    ],\n  )\n\n  const getContentProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      id: contentId,\n      role: \"listbox\",\n      ...props,\n      ref: mergeRefs(ref, contentRef),\n      onKeyDown: handlerAll(props.onKeyDown),\n    }),\n    [contentId],\n  )\n\n  const getSeparatorProps: PropGetter = useCallback(\n    (props) => ({ role: \"separator\", ...props }),\n    [],\n  )\n\n  return {\n    activeDescendant,\n    descendants,\n    interactive,\n    open,\n    getContentProps,\n    getSeparatorProps,\n    getTriggerProps,\n    onActiveDescendant,\n    onClose,\n    onOpen,\n    onOpenWithActiveDescendant,\n    onScrollIntoView,\n    onSelect,\n  }\n}\n\nexport type UseComboboxReturn = ReturnType<typeof useCombobox>\n\nexport interface UseComboboxGroupProps extends HTMLProps {}\n\nexport const useComboboxGroup = ({\n  \"aria-labelledby\": ariaLabelledbyProp,\n  ...rest\n}: UseComboboxGroupProps = {}) => {\n  const labelId = useId()\n\n  const getGroupProps: PropGetter = useCallback(\n    ({ \"aria-labelledby\": ariaLabelledby, ...props } = {}) => ({\n      \"aria-labelledby\": cx(ariaLabelledbyProp, ariaLabelledby, labelId),\n      role: \"group\",\n      ...rest,\n      ...props,\n    }),\n    [ariaLabelledbyProp, labelId, rest],\n  )\n\n  const getLabelProps: PropGetter<\"span\"> = useCallback(\n    (props) => ({ id: labelId, role: \"presentation\", ...props }),\n    [labelId],\n  )\n\n  return { getGroupProps, getLabelProps }\n}\n\nexport type UseComboboxGroupReturn = ReturnType<typeof useComboboxGroup>\n\nexport interface UseComboboxItemProps extends HTMLProps {\n  /**\n   * If `true`, the item will be closed when selected.\n   */\n  closeOnSelect?: boolean\n  /**\n   * If `true`, the item will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * If `true`, the item will be selected.\n   */\n  selected?: boolean\n  /**\n   * The value of the item.\n   */\n  value?: string\n}\n\nexport const useComboboxItem = ({\n  id,\n  \"aria-disabled\": ariaDisabled,\n  \"data-disabled\": dataDisabled,\n  closeOnSelect,\n  disabled = false,\n  selected = false,\n  value,\n  ...rest\n}: UseComboboxItemProps = {}) => {\n  const uuid = useId()\n  const itemRef = useRef<HTMLDivElement>(null)\n  const { onActiveDescendant, onClose, onSelect } = useComboboxContext()\n\n  id ??= uuid\n\n  const { descendants, register } = useComboboxDescendant({\n    id,\n    closeOnSelect,\n    disabled,\n    value,\n  })\n\n  const onActive = useCallback(() => {\n    if (disabled) return\n\n    const current = descendants.value(itemRef.current)\n\n    onActiveDescendant(current)\n  }, [descendants, disabled, onActiveDescendant])\n\n  const onClick = useCallback(\n    (ev: MouseEvent<HTMLDivElement>) => {\n      ev.preventDefault()\n\n      if (disabled) return\n\n      onSelect(value, closeOnSelect)\n    },\n    [closeOnSelect, disabled, onSelect, value],\n  )\n\n  const getItemProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      id,\n      \"aria-disabled\": ariaDisabled ?? ariaAttr(disabled),\n      \"aria-selected\": selected,\n      \"data-disabled\": dataDisabled ?? dataAttr(disabled),\n      \"data-selected\": dataAttr(selected),\n      \"data-value\": value,\n      role: \"option\",\n      tabIndex: -1,\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref, itemRef, register),\n      onClick: handlerAll(props.onClick, rest.onClick, onClick),\n      onMouseMove: handlerAll(props.onMouseMove, rest.onMouseMove, onActive),\n    }),\n    [\n      id,\n      ariaDisabled,\n      disabled,\n      selected,\n      dataDisabled,\n      value,\n      rest,\n      register,\n      onClick,\n      onActive,\n    ],\n  )\n\n  const getIndicatorProps: PropGetter = useCallback(\n    ({ style, ...props } = {}) => ({\n      style: { opacity: selected ? 1 : 0, ...style },\n      ...props,\n    }),\n    [selected],\n  )\n\n  return {\n    descendants,\n    disabled,\n    selected,\n    getIndicatorProps,\n    getItemProps,\n    onActiveDescendant,\n    onClose,\n  }\n}\n"
    }
  ]
}
