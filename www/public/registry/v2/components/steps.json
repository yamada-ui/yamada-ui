{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["icon"],
    "externals": [],
    "hooks": [
      "use-lazy-mount",
      "use-value",
      "use-controllable-state",
      "use-descendants"
    ],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./steps.style\"\nexport * as Steps from \"./namespace\"\nexport type {\n  StepsDescriptionProps,\n  StepsIndicatorProps,\n  StepsItemProps,\n  StepsListProps,\n  StepsNextTriggerProps,\n  StepsNumberProps,\n  StepsPrevTriggerProps,\n  StepsRootProps,\n  StepsSeparatorProps,\n  StepsTitleProps,\n} from \"./steps\"\nexport {\n  StepsDescription,\n  StepsIndicator,\n  StepsItem,\n  StepsList,\n  StepsNextTrigger,\n  StepsNumber,\n  StepsPrevTrigger,\n  StepsPropsContext,\n  StepsRoot,\n  StepsSeparator,\n  StepsTitle,\n  useStepsPropsContext,\n} from \"./steps\"\nexport * from \"./use-steps\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export type {\n  StepsCompletedContentProps as CompletedContentProps,\n  StepsContentProps as ContentProps,\n  StepsContentsProps as ContentsProps,\n  StepsDescriptionProps as DescriptionProps,\n  StepsIndicatorProps as IndicatorProps,\n  StepsItemProps as ItemProps,\n  StepsListProps as ListProps,\n  StepsNextTriggerProps as NextTriggerProps,\n  StepsNumberProps as NumberProps,\n  StepsPrevTriggerProps as PrevTriggerProps,\n  StepsRootProps as RootProps,\n  StepsSeparatorProps as SeparatorProps,\n  StepsTitleProps as TitleProps,\n} from \"./steps\"\nexport {\n  StepsCompletedContent as CompletedContent,\n  StepsContent as Content,\n  StepsContents as Contents,\n  StepsDescription as Description,\n  StepsIndicator as Indicator,\n  StepsItem as Item,\n  StepsList as List,\n  StepsNextTrigger as NextTrigger,\n  StepsNumber as Number,\n  StepsPrevTrigger as PrevTrigger,\n  StepsPropsContext as PropsContext,\n  StepsRoot as Root,\n  StepsSeparator as Separator,\n  StepsTitle as Title,\n  useStepsPropsContext as usePropsContext,\n} from \"./steps\"\nexport type { StepsItemContext as ItemContext } from \"./use-steps\"\nexport {\n  StepsContext as Context,\n  StepsDescendantsContext as DescendantsContext,\n  useStepsContext as useContext,\n  useStepsDescendant as useDescendant,\n  useStepsDescendants as useDescendants,\n  useStepsItemContext as useItemContext,\n} from \"./use-steps\"\n"
    },
    {
      "name": "steps.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const stepsStyle = defineComponentSlotStyle({\n  base: {\n    description: {\n      color: \"fg.muted\",\n    },\n    indicator: {\n      alignItems: \"center\",\n      boxSize: \"{size}\",\n      display: \"flex\",\n      flexShrink: \"0\",\n      fontWeight: \"medium\",\n      justifyContent: \"center\",\n      rounded: \"full\",\n      transitionDuration: \"moderate\",\n      transitionProperty: \"common\",\n    },\n    item: {\n      display: \"flex\",\n      flex: \"1 0 0\",\n      position: \"relative\",\n      _last: {\n        \"& [role=separator]\": {\n          display: \"none\",\n        },\n        flex: \"initial\",\n      },\n    },\n    list: {\n      display: \"flex\",\n      gap: \"3\",\n      justifyContent: \"space-between\",\n    },\n    root: {\n      display: \"flex\",\n      gap: \"4\",\n      w: \"full\",\n    },\n    separator: {\n      bg: \"border\",\n      flex: \"1\",\n      transitionDuration: \"moderate\",\n      transitionProperty: \"common\",\n    },\n    title: {\n      fontWeight: \"medium\",\n    },\n  },\n\n  props: {\n    /**\n     * The orientation of the steps.\n     *\n     * @default 'horizontal'\n     */\n    orientation: {\n      horizontal: {\n        item: {\n          alignItems: \"center\",\n          flexDirection: \"row\",\n        },\n        list: {\n          alignItems: \"center\",\n          flexDirection: \"row\",\n          w: \"full\",\n        },\n        root: {\n          flexDirection: \"column\",\n        },\n        separator: {\n          h: \"{thickness}\",\n          w: \"full\",\n        },\n      },\n      vertical: {\n        content: {\n          flex: \"1\",\n        },\n        item: {\n          alignItems: \"flex-start\",\n        },\n        list: {\n          alignItems: \"flex-start\",\n          flexDirection: \"column\",\n        },\n        root: {\n          flexDirection: \"row\",\n        },\n        separator: {\n          h: \"full\",\n          insetBlockStart: \"calc({size} + {gap})\",\n          insetInlineStart: \"calc(({size} / 2) - ({thickness} / 2))\",\n          maxH: `calc(full - {size} - {gap})`,\n          position: \"absolute\",\n          w: \"{thickness}\",\n        },\n      },\n    },\n  },\n\n  variants: {\n    solid: {\n      indicator: {\n        _complete: {\n          layerStyle: \"solid\",\n        },\n        _current: {\n          bg: \"colorScheme.muted\",\n          color: \"colorScheme.fg\",\n        },\n        _incomplete: {\n          bg: \"bg.subtle\",\n          color: \"fg.emphasized\",\n        },\n      },\n      separator: {\n        _complete: {\n          bg: \"colorScheme.solid\",\n        },\n      },\n    },\n    subtle: {\n      indicator: {\n        _complete: {\n          bg: \"colorScheme.emphasized\",\n          color: \"colorScheme.fg\",\n        },\n        _current: {\n          bg: \"colorScheme.muted\",\n          color: \"colorScheme.fg\",\n        },\n        _incomplete: {\n          bg: \"bg.subtle\",\n          color: \"fg.emphasized\",\n        },\n      },\n      separator: {\n        _complete: {\n          bg: \"colorScheme.emphasized\",\n        },\n      },\n    },\n  },\n\n  sizes: {\n    sm: {\n      indicator: {\n        fontSize: \"md\",\n      },\n      item: {\n        \"--gap\": \"sizes.3\",\n        \"--size\": \"sizes.8\",\n        \"--thickness\": \"sizes.0.5\",\n        fontSize: \"xs\",\n        gap: \"3\",\n      },\n    },\n    md: {\n      indicator: {\n        fontSize: \"md\",\n      },\n      item: {\n        \"--gap\": \"sizes.3\",\n        \"--size\": \"sizes.10\",\n        \"--thickness\": \"sizes.0.5\",\n        fontSize: \"sm\",\n        gap: \"3\",\n      },\n    },\n    lg: {\n      indicator: {\n        fontSize: \"lg\",\n      },\n      item: {\n        \"--gap\": \"sizes.3\",\n        \"--size\": \"sizes.12\",\n        \"--thickness\": \"sizes.0.5\",\n        gap: \"3\",\n      },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"solid\",\n    orientation: \"horizontal\",\n  },\n})\n\nexport type StepsStyle = typeof stepsStyle\n"
    },
    {
      "name": "steps.tsx",
      "content": "\"use client\"\n\nimport type { FC, PropsWithChildren, ReactNode } from \"react\"\nimport type { HTMLStyledProps, ThemeProps } from \"@yamada-ui/react\"\nimport type { UseLazyMountProps } from \"../../hooks/use-lazy-mount\"\nimport type { StepsStyle } from \"./steps.style\"\nimport type { UseStepsItemProps, UseStepsProps } from \"./use-steps\"\nimport { Children, useMemo } from \"react\"\nimport {\n  createSlotComponent,\n  styled,\n  isNull,\n  isUndefined,\n  useFindChild,\n  useValidChildren,\n} from \"@yamada-ui/react\"\nimport { useLazyMount } from \"../../hooks/use-lazy-mount\"\nimport { useValue } from \"../../hooks/use-value\"\nimport { CheckIcon } from \"../icon\"\nimport { stepsStyle } from \"./steps.style\"\nimport {\n  StepsContext,\n  StepsDescendantsContext,\n  StepsItemContext,\n  useSteps,\n  useStepsContext,\n  useStepsItem,\n  useStepsItemContext,\n} from \"./use-steps\"\n\ninterface ComponentContext\n  extends Pick<StepsRootProps, \"items\" | \"lazy\" | \"lazyBehavior\"> {}\n\nexport interface StepsItem\n  extends Omit<StepsItemProps, \"content\" | \"index\" | \"title\">,\n    Pick<StepsIndicatorProps, \"complete\" | \"current\" | \"incomplete\"> {\n  /**\n   * The content for step element.\n   */\n  content?: ReactNode\n  /**\n   * The description for step element.\n   */\n  description?: ReactNode\n  /**\n   * If true, display the step separator.\n   *\n   * @default true\n   */\n  hasSeparator?: boolean\n  /**\n   * The title for step element.\n   */\n  title?: string\n  /**\n   * Props for step content element.\n   */\n  contentProps?: StepsContentProps\n  /**\n   * Props for step description element.\n   */\n  descriptionProps?: StepsDescriptionProps\n  /**\n   * Props for step indicator element.\n   */\n  indicatorProps?: StepsIndicatorProps\n  /**\n   * Props for step separator element.\n   */\n  separatorProps?: StepsSeparatorProps\n  /**\n   * Props for step title element.\n   */\n  titleProps?: StepsTitleProps\n}\n\nexport interface StepsRootProps\n  extends Omit<HTMLStyledProps, \"onChange\">,\n    Omit<UseStepsProps, \"count\" | \"orientation\">,\n    Pick<UseLazyMountProps, \"lazy\" | \"lazyBehavior\">,\n    ThemeProps<StepsStyle> {\n  /**\n   * If provided, generate step components based on steps.\n   */\n  items?: StepsItem[]\n}\n\nconst {\n  ComponentContext,\n  PropsContext: StepsPropsContext,\n  useComponentContext,\n  usePropsContext: useStepsPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<StepsRootProps, StepsStyle, ComponentContext>(\n  \"steps\",\n  stepsStyle,\n)\n\nexport { StepsPropsContext, useStepsPropsContext }\n\n/**\n * `Steps` is a component that displays the progress of a multi-step process.\n *\n * @see https://yamada-ui.com/docs/components/steps\n */\nexport const StepsRoot = withProvider<\"div\", StepsRootProps, \"orientation\">(\n  ({\n    children,\n    items = [],\n    lazy,\n    lazyBehavior,\n    orientation: orientationProp,\n    ...rest\n  }) => {\n    const computedOrientation = useValue(orientationProp)\n    const validChildren = useValidChildren(children)\n    const stepsList = useFindChild<StepsListProps>(validChildren, StepsList)\n    const {\n      id,\n      count,\n      descendants,\n      getStatus,\n      index,\n      orientation,\n      setIndex,\n      getContentProps,\n      getListProps,\n      getNextTriggerProps,\n      getPrevTriggerProps,\n      getRootProps,\n      onNext,\n      onPrev,\n    } = useSteps({\n      count: items.length || Children.count(stepsList?.props.children),\n      orientation: computedOrientation,\n      ...rest,\n    })\n    const componentContext = useMemo(\n      () => ({ items, lazy, lazyBehavior }),\n      [items, lazy, lazyBehavior],\n    )\n    const stepsContext = useMemo(\n      () => ({\n        id,\n        count,\n        getStatus,\n        index,\n        orientation,\n        setIndex,\n        getContentProps,\n        getListProps,\n        getNextTriggerProps,\n        getPrevTriggerProps,\n        onNext,\n        onPrev,\n      }),\n      [\n        id,\n        count,\n        index,\n        orientation,\n        setIndex,\n        getStatus,\n        onNext,\n        onPrev,\n        getListProps,\n        getNextTriggerProps,\n        getPrevTriggerProps,\n        getContentProps,\n      ],\n    )\n\n    return (\n      <StepsDescendantsContext value={descendants}>\n        <StepsContext value={stepsContext}>\n          <ComponentContext value={componentContext}>\n            <styled.div {...getRootProps()}>{children}</styled.div>\n          </ComponentContext>\n        </StepsContext>\n      </StepsDescendantsContext>\n    )\n  },\n  \"root\",\n  { transferProps: [\"orientation\"] },\n)()\n\nexport interface StepsListProps extends HTMLStyledProps<\"ol\"> {}\n\nexport const StepsList = withContext<\"ol\", StepsListProps>(\n  ({ children, ...rest }) => {\n    const { items } = useComponentContext()\n    const { getListProps } = useStepsContext()\n    const computedChildren = useMemo(() => {\n      if (children) {\n        return children\n      } else {\n        return items?.map(\n          (\n            {\n              complete,\n              content: _content,\n              current,\n              description,\n              hasSeparator = true,\n              incomplete,\n              title,\n              contentProps: _contentProps,\n              descriptionProps,\n              indicatorProps,\n              separatorProps,\n              titleProps,\n              ...rest\n            },\n            index,\n          ) => (\n            <StepsItem key={index} index={index} title={title} {...rest}>\n              <StepsIndicator\n                complete={complete}\n                current={current}\n                incomplete={incomplete}\n                {...indicatorProps}\n              />\n\n              <styled.div>\n                {title ? (\n                  <StepsTitle {...titleProps}>{title}</StepsTitle>\n                ) : null}\n                {description ? (\n                  <StepsDescription {...descriptionProps}>\n                    {description}\n                  </StepsDescription>\n                ) : null}\n              </styled.div>\n\n              {hasSeparator ? <StepsSeparator {...separatorProps} /> : null}\n            </StepsItem>\n          ),\n        )\n      }\n    }, [children, items])\n\n    return <styled.ol {...getListProps(rest)}>{computedChildren}</styled.ol>\n  },\n  \"list\",\n)()\n\nexport interface StepsItemProps\n  extends HTMLStyledProps<\"li\">,\n    UseStepsItemProps {}\n\nexport const StepsItem = withContext<\"li\", StepsItemProps>((props) => {\n  const {\n    first,\n    index,\n    last,\n    status,\n    getDescriptionProps,\n    getIndicatorProps,\n    getRootProps,\n    getSeparatorProps,\n    getTitleProps,\n  } = useStepsItem(props)\n  const context = useMemo(\n    () => ({\n      first,\n      index,\n      last,\n      status,\n      getDescriptionProps,\n      getIndicatorProps,\n      getSeparatorProps,\n      getTitleProps,\n    }),\n    [\n      first,\n      index,\n      last,\n      status,\n      getTitleProps,\n      getDescriptionProps,\n      getSeparatorProps,\n      getIndicatorProps,\n    ],\n  )\n\n  return (\n    <StepsItemContext value={context}>\n      <styled.li {...getRootProps()} />\n    </StepsItemContext>\n  )\n}, \"item\")()\n\nexport interface StepsIndicatorProps extends HTMLStyledProps {\n  /**\n   * The element for the complete indicator.\n   *\n   * @default <CheckIcon />\n   */\n  complete?: ReactNode\n  /**\n   * The element for the current indicator.\n   *\n   * @default <StepsNumber />\n   */\n  current?: ReactNode\n  /**\n   * The element for the incomplete indicator.\n   *\n   * @default <StepsNumber />\n   */\n  incomplete?: ReactNode\n}\n\nexport const StepsIndicator = withContext<\"div\", StepsIndicatorProps>(\n  ({\n    complete = <CheckIcon />,\n    current = <StepsNumber />,\n    incomplete = <StepsNumber />,\n    ...rest\n  }) => {\n    const { status, getIndicatorProps } = useStepsItemContext()\n    const components = useMemo(\n      () => ({ complete, current, incomplete }),\n      [complete, current, incomplete],\n    )\n\n    return (\n      <styled.div {...getIndicatorProps(rest)}>{components[status]}</styled.div>\n    )\n  },\n  \"indicator\",\n)()\n\nexport interface StepsNumberProps extends HTMLStyledProps<\"span\"> {}\n\nexport const StepsNumber = withContext<\"span\", StepsNumberProps>(\n  \"span\",\n  \"number\",\n)(undefined, ({ children, ...rest }) => {\n  const { index } = useStepsItemContext()\n\n  return { ...rest, children: children ?? index + 1 }\n})\n\nexport interface StepsTitleProps extends HTMLStyledProps {}\n\nexport const StepsTitle = withContext<\"h3\", StepsTitleProps>(\"h3\", \"title\")(\n  undefined,\n  (props) => {\n    const { getTitleProps } = useStepsItemContext()\n\n    return getTitleProps(props)\n  },\n)\n\nexport interface StepsDescriptionProps extends HTMLStyledProps<\"p\"> {}\n\nexport const StepsDescription = withContext<\"p\", StepsDescriptionProps>(\n  \"p\",\n  \"description\",\n)(undefined, (props) => {\n  const { getDescriptionProps } = useStepsItemContext()\n\n  return getDescriptionProps(props)\n})\n\nexport interface StepsSeparatorProps extends HTMLStyledProps {}\n\nexport const StepsSeparator = withContext<\"div\", StepsSeparatorProps>(\n  \"div\",\n  \"separator\",\n)(undefined, (props) => {\n  const { getSeparatorProps } = useStepsItemContext()\n\n  return getSeparatorProps(props)\n})\n\nexport interface StepsContentsProps extends PropsWithChildren {}\n\nexport const StepsContents: FC<StepsContentsProps> = ({ children }) => {\n  const { items } = useComponentContext()\n\n  return useMemo(() => {\n    if (children) {\n      return children\n    } else {\n      return items?.map(({ content, contentProps }, index) =>\n        isUndefined(content) || isNull(content) ? null : (\n          <StepsContent key={index} index={index} {...contentProps}>\n            {content}\n          </StepsContent>\n        ),\n      )\n    }\n  }, [children, items])\n}\n\nexport interface StepsContentProps extends HTMLStyledProps {\n  /**\n   * The index of the step content.\n   */\n  index: number\n}\n\nexport const StepsContent = withContext<\"div\", StepsContentProps>(\n  \"div\",\n  \"content\",\n)(undefined, ({ index, ...rest }) => {\n  const { lazy, lazyBehavior } = useComponentContext()\n  const { index: selectedIndex, getContentProps } = useStepsContext()\n  const mounted = index === selectedIndex\n  const children = useLazyMount({\n    lazy,\n    lazyBehavior,\n    mounted,\n    ...rest,\n  })\n\n  return { ...getContentProps({ index, ...rest }), children }\n})\n\nexport interface StepsCompletedContentProps extends HTMLStyledProps {}\n\nexport const StepsCompletedContent = withContext<\n  \"div\",\n  StepsCompletedContentProps\n>(\"div\", { name: \"CompletedContent\", slot: [\"content\", \"completed\"] })(\n  undefined,\n  (props) => {\n    const { lazy, lazyBehavior } = useComponentContext()\n    const { count, index: selectedIndex, getContentProps } = useStepsContext()\n    const mounted = count !== 0 && count === selectedIndex\n    const children = useLazyMount({\n      lazy,\n      lazyBehavior,\n      mounted,\n      ...props,\n    })\n\n    return { ...getContentProps(props), children }\n  },\n)\n\nexport interface StepsPrevTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const StepsPrevTrigger = withContext<\"button\", StepsPrevTriggerProps>(\n  \"button\",\n  { name: \"PrevTrigger\", slot: [\"trigger\", \"prev\"] },\n)((props) => {\n  const { getPrevTriggerProps } = useStepsContext()\n\n  return { asChild: true, ...getPrevTriggerProps(props) }\n})\n\nexport interface StepsNextTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const StepsNextTrigger = withContext<\"button\", StepsNextTriggerProps>(\n  \"button\",\n  { name: \"NextTrigger\", slot: [\"trigger\", \"next\"] },\n)((props) => {\n  const { getNextTriggerProps } = useStepsContext()\n\n  return { asChild: true, ...getNextTriggerProps(props) }\n})\n"
    },
    {
      "name": "use-steps.ts",
      "content": "\"use client\"\n\nimport type { HTMLProps, Orientation, PropGetter } from \"@yamada-ui/react\"\nimport { useCallback, useId } from \"react\"\nimport {\n  useEnvironment,\n  createContext,\n  cx,\n  dataAttr,\n  handlerAll,\n  mergeRefs,\n} from \"@yamada-ui/react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { createDescendants } from \"../../hooks/use-descendants\"\n\nexport type StepStatusScheme = \"complete\" | \"current\" | \"incomplete\"\n\nconst {\n  DescendantsContext: StepsDescendantsContext,\n  useDescendant: useStepsDescendant,\n  useDescendants: useStepsDescendants,\n} = createDescendants<HTMLLIElement>()\n\nexport { StepsDescendantsContext, useStepsDescendant, useStepsDescendants }\n\ninterface StepsContext\n  extends Omit<UseStepsReturn, \"descendants\" | \"getRootProps\"> {}\n\nconst [StepsContext, useStepsContext] = createContext<StepsContext>({\n  name: \"StepsContext\",\n})\n\nexport { StepsContext, useStepsContext }\n\ninterface StepsItemContext extends Omit<UseStepsItemReturn, \"getRootProps\"> {}\n\nconst [StepsItemContext, useStepsItemContext] = createContext<StepsItemContext>(\n  {\n    name: \"StepsItemContext\",\n  },\n)\n\nexport { StepsItemContext, useStepsItemContext }\n\nexport interface UseStepsProps extends Omit<HTMLProps, \"onChange\"> {\n  /**\n   * The total number of steps.\n   */\n  count?: number\n  /**\n   * The initial index of the active step.\n   *\n   * @default 0\n   */\n  defaultIndex?: number\n  /**\n   * The index of the active step.\n   */\n  index?: number\n  /**\n   * The orientation of the steps.\n   *\n   * @default 'horizontal'\n   */\n  orientation?: Orientation\n  /**\n   * The callback function that is called when the active step index is changed.\n   */\n  onChange?: (index: number) => void\n}\n\nexport const useSteps = ({\n  count = 0,\n  defaultIndex = 0,\n  index: indexProp,\n  orientation = \"horizontal\",\n  onChange,\n  ...rest\n}: UseStepsProps = {}) => {\n  const descendants = useStepsDescendants()\n  const [index, setIndex] = useControllableState({\n    defaultValue: defaultIndex,\n    value: indexProp,\n    onChange,\n  })\n  const id = useId()\n\n  const getStatus = useCallback(\n    (indexProp: number): StepStatusScheme => {\n      if (indexProp < index) {\n        return \"complete\"\n      } else if (indexProp > index) {\n        return \"incomplete\"\n      } else {\n        return \"current\"\n      }\n    },\n    [index],\n  )\n\n  const onPrev = useCallback(\n    () => setIndex((index) => Math.max(0, index - 1)),\n    [setIndex],\n  )\n\n  const onNext = useCallback(() => {\n    setIndex((index) => Math.min(count, index + 1))\n  }, [count, setIndex])\n\n  const getRootProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref),\n    }),\n    [rest],\n  )\n\n  const getListProps: PropGetter<\"ol\"> = useCallback(\n    (props) => {\n      return {\n        \"data-orientation\": orientation,\n        ...props,\n      }\n    },\n    [orientation],\n  )\n\n  const getContentProps: PropGetter<\"div\", { index?: number }> = useCallback(\n    ({ index: indexProp = count, ...props } = {}) => ({\n      id: `${id}-${indexProp}`,\n      hidden: indexProp !== index,\n      tabIndex: 0,\n      ...props,\n    }),\n    [count, id, index],\n  )\n\n  const getPrevTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      disabled: index === 0,\n      ...props,\n      onClick: handlerAll(props.onClick, onPrev),\n    }),\n    [onPrev, index],\n  )\n\n  const getNextTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => {\n      return {\n        disabled: count <= index,\n        ...props,\n        onClick: handlerAll(props.onClick, onNext),\n      }\n    },\n    [count, index, onNext],\n  )\n\n  return {\n    id,\n    count,\n    descendants,\n    getStatus,\n    index,\n    orientation,\n    setIndex,\n    getContentProps,\n    getListProps,\n    getNextTriggerProps,\n    getPrevTriggerProps,\n    getRootProps,\n    onNext,\n    onPrev,\n  }\n}\n\nexport type UseStepsReturn = ReturnType<typeof useSteps>\n\nexport interface UseStepsItemProps extends HTMLProps<\"li\"> {\n  /**\n   * The index of the step.\n   */\n  index: number\n}\n\nexport const useStepsItem = ({\n  \"aria-labelledby\": ariaLabelledbyProp,\n  index,\n  ...rest\n}: UseStepsItemProps) => {\n  const { descendants, register } = useStepsDescendant()\n  const { id, getStatus, orientation } = useStepsContext()\n  const status = getStatus(index)\n  const current = status === \"current\"\n  const first = index === 0\n  const last = index === descendants.lastValue()?.index\n  const statusDataAttr = `data-${status}`\n  const { getDocument } = useEnvironment()\n\n  const getRootProps: PropGetter<\"li\"> = useCallback(\n    ({ ref, \"aria-labelledby\": ariaLabelledby, ...props } = {}) => {\n      const hasContent = !!getDocument()?.getElementById(`${id}-${index}`)\n\n      return {\n        \"aria-current\": current ? \"step\" : undefined,\n        \"aria-labelledby\": cx(\n          ariaLabelledbyProp,\n          ariaLabelledby,\n          hasContent ? `${id}-${index}` : undefined,\n        ),\n        \"data-orientation\": orientation,\n        [statusDataAttr]: dataAttr(true),\n        ...rest,\n        ...props,\n        ref: mergeRefs(ref, register),\n      }\n    },\n    [\n      ariaLabelledbyProp,\n      getDocument,\n      id,\n      index,\n      current,\n      orientation,\n      statusDataAttr,\n      rest,\n      register,\n    ],\n  )\n\n  const getTitleProps: PropGetter<\"h3\"> = useCallback(\n    (props) => ({\n      [statusDataAttr]: dataAttr(true),\n      ...props,\n    }),\n    [statusDataAttr],\n  )\n\n  const getDescriptionProps: PropGetter<\"p\"> = useCallback(\n    (props) => ({\n      [statusDataAttr]: dataAttr(true),\n      ...props,\n    }),\n    [statusDataAttr],\n  )\n\n  const getIndicatorProps: PropGetter = useCallback(\n    (props) => ({\n      [statusDataAttr]: dataAttr(true),\n      ...props,\n    }),\n    [statusDataAttr],\n  )\n\n  const getSeparatorProps: PropGetter = useCallback(\n    (props) => ({\n      \"data-orientation\": orientation,\n      role: \"separator\",\n      [statusDataAttr]: dataAttr(true),\n      ...props,\n    }),\n    [orientation, statusDataAttr],\n  )\n\n  return {\n    first,\n    index,\n    last,\n    status,\n    getDescriptionProps,\n    getIndicatorProps,\n    getRootProps,\n    getSeparatorProps,\n    getTitleProps,\n  }\n}\n\nexport type UseStepsItemReturn = ReturnType<typeof useStepsItem>\n"
    }
  ]
}
