{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "dependents": {
    "components": [
      "accordion",
      "calendar",
      "menu",
      "pin-input",
      "segmented-control",
      "steps",
      "tabs"
    ],
    "hooks": ["use-combobox"],
    "providers": []
  },
  "section": "hooks",
  "sources": [
    {
      "name": "index.ts",
      "content": "\"use client\"\n\nimport type { RefCallback } from \"react\"\nimport { useRef } from \"react\"\nimport {\n  createContext,\n  isNumber,\n  isTruthyDataAttr,\n  mergeRefs,\n  runIfFn,\n  useSafeLayoutEffect,\n} from \"@yamada-ui/react\"\n\nconst sortNodes = (nodes: Node[]) =>\n  nodes.sort((a, b) => {\n    const compare = a.compareDocumentPosition(b)\n\n    if (\n      compare & Node.DOCUMENT_POSITION_FOLLOWING ||\n      compare & Node.DOCUMENT_POSITION_CONTAINED_BY\n    )\n      return -1\n\n    if (\n      compare & Node.DOCUMENT_POSITION_PRECEDING ||\n      compare & Node.DOCUMENT_POSITION_CONTAINS\n    )\n      return 1\n\n    if (\n      compare & Node.DOCUMENT_POSITION_DISCONNECTED ||\n      compare & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\n    ) {\n      console.warn(\"Cannot sort the given nodes.\")\n      return 0\n    } else {\n      return 0\n    }\n  })\n\nconst getNextIndex = (current: number, max: number, loop: boolean) => {\n  let next = current + 1\n\n  if (loop && next >= max) next = 0\n\n  return next\n}\n\nconst getPrevIndex = (current: number, max: number, loop: boolean) => {\n  let next = current - 1\n\n  if (loop && next < 0) next = max\n\n  return next\n}\n\nexport type DescendantProps<Y extends HTMLElement = HTMLElement, M = {}> = M & {\n  disabled?: ((node: Y) => boolean) | boolean\n}\n\nexport type Descendant<\n  Y extends HTMLElement = HTMLElement,\n  M = {},\n> = DescendantProps<Y, M> & {\n  index: number\n  node: Y\n  recurred?: boolean\n}\n\nconst descendantManager = <Y extends HTMLElement = HTMLElement, M = {}>() => {\n  const descendants = new Map<Y, Descendant<Y, M>>()\n\n  const setIndexes = (next: Node[]) => {\n    descendants.forEach((descendant) => {\n      const index = next.indexOf(descendant.node)\n\n      descendant.index = index\n      descendant.node.dataset.index = descendant.index.toString()\n    })\n  }\n\n  const set = (node: null | Y, props?: DescendantProps<Y, M>) => {\n    if (!node || descendants.has(node)) return\n\n    const keys = Array.from(descendants.keys()).concat(node)\n    const sorted = sortNodes(keys)\n\n    const descendant = { ...props, index: -1, node } as Descendant<Y, M>\n\n    descendants.set(node, descendant)\n\n    setIndexes(sorted)\n  }\n\n  const destroy = () => descendants.clear()\n\n  const register = (props?: DescendantProps<Y, M>): RefCallback<Y> => {\n    return (node: null | Y) => set(node, props)\n  }\n\n  const unregister = (node?: null | Y) => {\n    if (node == null) return\n\n    descendants.delete(node)\n\n    const sorted = sortNodes(Array.from(descendants.keys()))\n\n    setIndexes(sorted)\n  }\n\n  const count = () => values().length\n\n  const enabledCount = () => enabledValues().length\n\n  const active = (\n    target?: Descendant<Y, M> | null | Y,\n    options?: FocusOptions,\n  ) => {\n    if (!target) return\n\n    if (!(target instanceof Node)) target = target.node\n\n    if (isTruthyDataAttr(target.dataset.activedescendant)) return\n\n    const descendants = values()\n\n    descendants.forEach(({ node }) => {\n      delete node.dataset.activedescendant\n    })\n\n    target.dataset.activedescendant = \"\"\n\n    if (options) target.focus(options)\n  }\n\n  const indexOf = (target?: Descendant<Y, M> | null | Y) => {\n    if (!target) return -1\n\n    if (target instanceof Node) {\n      return descendants.get(target)?.index ?? -1\n    } else {\n      return descendants.get(target.node)?.index ?? -1\n    }\n  }\n\n  const enabledIndexOf = (target?: Descendant<Y, M> | null | Y) => {\n    if (!target) return -1\n\n    if (target instanceof Node) {\n      return enabledValues().findIndex(({ node }) => node.isSameNode(target))\n    } else {\n      return enabledValues().findIndex(({ node }) =>\n        node.isSameNode(target.node),\n      )\n    }\n  }\n\n  const values = () =>\n    Array.from(descendants.values()).sort((a, b) => a.index - b.index)\n\n  const enabledValues = () =>\n    values().filter(({ disabled, node }) => !runIfFn(disabled, node))\n\n  const value = (indexOrNode: null | number | Y) => {\n    if (!count() || indexOrNode == null) return undefined\n\n    return isNumber(indexOrNode)\n      ? values()[indexOrNode]\n      : descendants.get(indexOrNode)\n  }\n\n  const enabledValue = (index: number) => {\n    if (!enabledCount()) return undefined\n\n    return enabledValues()[index]\n  }\n\n  const firstValue = () => value(0)\n\n  const enabledFirstValue = () => enabledValue(0)\n\n  const lastValue = () => value(count() - 1)\n\n  const enabledLastValue = () => enabledValue(enabledCount() - 1)\n\n  const prevValue = (\n    indexOrNode: Descendant<Y, M> | null | number | Y,\n    loop = true,\n  ) => {\n    if (!count()) return undefined\n\n    const currentIndex = isNumber(indexOrNode)\n      ? indexOrNode\n      : indexOf(indexOrNode)\n\n    if (currentIndex === -1) return undefined\n\n    const prevIndex = getPrevIndex(currentIndex, count() - 1, loop)\n\n    return value(prevIndex)\n  }\n\n  const enabledPrevValue = (\n    indexOrNode: Descendant<Y, M> | null | number | Y,\n    loop = true,\n  ) => {\n    if (!enabledCount()) return undefined\n\n    let index = isNumber(indexOrNode) ? indexOrNode : indexOf(indexOrNode)\n    let enabledValue = null\n    let recurred = false\n\n    while (enabledValue == null) {\n      index--\n\n      if (index < 0) {\n        if (!loop) return\n\n        index = count() - 1\n        recurred = true\n      }\n\n      const descendant = value(index)\n\n      enabledValue =\n        descendant && !runIfFn(descendant.disabled, descendant.node)\n          ? descendant\n          : null\n    }\n\n    if (recurred) enabledValue.recurred = recurred\n\n    return enabledValue\n  }\n\n  const nextValue = (\n    indexOrNode: Descendant<Y, M> | null | number | Y,\n    loop = true,\n  ) => {\n    if (!count()) return undefined\n\n    const currentIndex = isNumber(indexOrNode)\n      ? indexOrNode\n      : indexOf(indexOrNode)\n\n    if (currentIndex === -1) return undefined\n\n    const nextIndex = getNextIndex(currentIndex, count(), loop)\n\n    return value(nextIndex)\n  }\n\n  const enabledNextValue = (\n    indexOrNode: Descendant<Y, M> | null | number | Y,\n    loop = true,\n  ) => {\n    if (!enabledCount()) return undefined\n\n    let index = isNumber(indexOrNode) ? indexOrNode : indexOf(indexOrNode)\n    let enabledValue = null\n    let recurred = false\n\n    while (enabledValue == null) {\n      index++\n\n      if (index >= count()) {\n        if (!loop) return\n\n        index = 0\n        recurred = true\n      }\n\n      const descendant = value(index)\n\n      enabledValue =\n        descendant && !runIfFn(descendant.disabled, descendant.node)\n          ? descendant\n          : null\n    }\n\n    if (recurred) enabledValue.recurred = recurred\n\n    return enabledValue\n  }\n\n  return {\n    active,\n    count,\n    destroy,\n    enabledCount,\n    enabledFirstValue,\n    enabledIndexOf,\n    enabledLastValue,\n    enabledNextValue,\n    enabledPrevValue,\n    enabledValue,\n    enabledValues,\n    firstValue,\n    indexOf,\n    lastValue,\n    nextValue,\n    prevValue,\n    register,\n    unregister,\n    value,\n    values,\n  }\n}\n\nexport type Descendants<Y extends HTMLElement, M = {}> = ReturnType<\n  typeof descendantManager<Y, M>\n>\n\nexport type CreateDescendantRegister<Y extends HTMLElement, M = {}> = (\n  props?: DescendantProps<Y, M>,\n) => RefCallback<Y>\n\n/**\n * `useDescendants` is a custom hook that manages descendants.\n *\n * @see https://yamada-ui.com/hooks/use-descendants\n */\nexport const createDescendants = <\n  Y extends HTMLElement = HTMLElement,\n  M = {},\n>() => {\n  const [DescendantsContext, useDescendantsContext] = createContext<\n    Descendants<Y, M>\n  >({\n    name: \"DescendantsContext\",\n  })\n\n  const useDescendantRegister = (descendants?: Descendants<Y, M>) => {\n    const ref = useRef<Y>(null)\n\n    useSafeLayoutEffect(() => {\n      return () => {\n        if (ref.current) descendants?.unregister(ref.current)\n      }\n    }, [])\n\n    return (props?: DescendantProps<Y, M>): RefCallback<Y> =>\n      mergeRefs(ref, descendants?.register(props))\n  }\n\n  const useDescendants = () => {\n    const descendants = useRef(descendantManager<Y, M>())\n\n    useSafeLayoutEffect(() => {\n      return () => descendants.current.destroy()\n    })\n\n    return descendants.current\n  }\n\n  const useDescendant = (props?: DescendantProps<Y, M>) => {\n    const descendants = useDescendantsContext()\n    const createRegister = useDescendantRegister(descendants)\n\n    return {\n      descendants,\n      register: createRegister(props),\n    }\n  }\n\n  return {\n    DescendantsContext,\n    useDescendant,\n    useDescendantRegister,\n    useDescendants,\n    useDescendantsContext,\n  }\n}\n"
    }
  ]
}
