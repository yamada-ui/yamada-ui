{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "dependents": { "components": [], "hooks": ["use-value"], "providers": [] },
  "section": "hooks",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./use-breakpoint\"\nexport * from \"./use-breakpoint-effect\"\nexport * from \"./use-breakpoint-state\"\nexport * from \"./use-breakpoint-value\"\nexport * from \"./use-update-breakpoint-effect\"\n"
    },
    {
      "name": "use-breakpoint-effect.ts",
      "content": "\"use client\"\n\nimport type { DependencyList } from \"react\"\nimport type { Breakpoint } from \"@yamada-ui/react\"\nimport { useEffect } from \"react\"\nimport { useBreakpoint } from \"./use-breakpoint\"\n\n/**\n * `useBreakpointEffect` is a custom hook that executes a specific callback function when the breakpoint changes.\n *\n * @see https://yamada-ui.com/hooks/use-breakpoint-effect\n */\nexport const useBreakpointEffect = (\n  callback: (breakpoint: Breakpoint) => void,\n  deps: DependencyList,\n) => {\n  const breakpoint = useBreakpoint()\n\n  useEffect(() => {\n    callback(breakpoint)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [breakpoint, ...deps])\n}\n"
    },
    {
      "name": "use-breakpoint-state.ts",
      "content": "\"use client\"\n\nimport type { ResponsiveObject } from \"@yamada-ui/react\"\nimport { useState } from \"react\"\nimport { useBreakpointValue } from \"./use-breakpoint-value\"\n\n/**\n * `useBreakpointState` is a custom hook that takes a responsive object as an initial state and returns a state corresponding to the current breakpoint.\n *\n * @see https://yamada-ui.com/hooks/use-breakpoint-state\n */\nexport const useBreakpointState = <Y,>(\n  initialState: ResponsiveObject<Y, false>,\n) => {\n  const state = useBreakpointValue(initialState)\n\n  return useState(state)\n}\n"
    },
    {
      "name": "use-breakpoint-value.ts",
      "content": "import type { Breakpoint, ResponsiveObject, System } from \"@yamada-ui/react\"\nimport { useMemo } from \"react\"\nimport { useSystem } from \"@yamada-ui/react\"\nimport { useBreakpoint } from \"./use-breakpoint\"\n\n/**\n * `useBreakpointValue` is a custom hook that returns the value of the current breakpoint from the provided object.\n * This hook monitors changes in the window size and returns the appropriate value.\n *\n * @see https://yamada-ui.com/hooks/use-breakpoint-value\n */\nexport const useBreakpointValue = <Y,>(\n  values: ResponsiveObject<Y, false>,\n): Y => {\n  const system = useSystem()\n  const breakpoint = useBreakpoint()\n\n  return useMemo(\n    () => getBreakpointValue<Y>(values)(system, breakpoint),\n    [values, system, breakpoint],\n  )\n}\n\nexport const getBreakpointValue =\n  <Y,>(values: ResponsiveObject<Y, false> = {}) =>\n  (system: System, breakpoint: Breakpoint): Y => {\n    const breakpoints = system.breakpoints.keys\n\n    if (!breakpoints.length) {\n      console.warn(\"getBreakpointValue: `breakpoints` is undefined.\")\n    }\n\n    const currentIndex = breakpoints.indexOf(breakpoint)\n\n    for (let i = currentIndex; 0 < i; i--) {\n      const nextBreakpoint = breakpoints[i]\n\n      if (nextBreakpoint && values.hasOwnProperty(nextBreakpoint)) {\n        return values[nextBreakpoint] as Y\n      }\n    }\n\n    return values.base as Y\n  }\n"
    },
    {
      "name": "use-breakpoint.ts",
      "content": "\"use client\"\n\nimport type { Breakpoint } from \"@yamada-ui/react\"\nimport { useCallback, useMemo, useRef, useSyncExternalStore } from \"react\"\nimport {\n  useEnvironment,\n  useSystem,\n  createdDom,\n  isUndefined,\n  noop,\n} from \"@yamada-ui/react\"\n\n/**\n * `useBreakpoint` is a custom hook that returns the current breakpoint.\n * This hook monitors changes in the window size and returns the appropriate value.\n *\n * @see https://yamada-ui.com/hooks/use-breakpoint\n */\nexport const useBreakpoint = () => {\n  const animationFrameId = useRef(0)\n  const { breakpoints, config } = useSystem()\n  const { getWindow } = useEnvironment()\n  const {\n    containerRef,\n    direction = \"down\",\n    identifier = \"@media screen\",\n  } = config.breakpoint ?? {}\n  const hasContainer = !!containerRef\n\n  const queries = useMemo(() => {\n    return breakpoints.queries.map(\n      ({ breakpoint, maxW, minMaxQuery, minW }) => {\n        const searchValue =\n          identifier === \"@media screen\"\n            ? \"@media screen and \"\n            : `${identifier} `\n        const query = minMaxQuery?.replace(searchValue, \"\") ?? \"\"\n\n        return {\n          breakpoint,\n          maxW,\n          minW,\n          query,\n        }\n      },\n    )\n  }, [breakpoints, identifier])\n\n  const hasQueries = !!queries.length\n\n  const getBreakpoint = useCallback(\n    (width?: number) => {\n      if (isUndefined(width)) {\n        const win = getWindow()\n\n        if (hasContainer || !hasQueries) return \"base\"\n\n        for (const { breakpoint, query } of queries) {\n          const mql = win?.matchMedia(query)\n\n          if (mql?.matches) return breakpoint\n        }\n      } else {\n        for (const { breakpoint, maxW, minW } of queries) {\n          if (direction !== \"up\") {\n            if ((minW ?? 0) <= width) return breakpoint\n          } else {\n            if (width <= (maxW ?? Infinity)) return breakpoint\n          }\n        }\n      }\n\n      return \"base\"\n    },\n    [direction, getWindow, hasContainer, hasQueries, queries],\n  )\n\n  const breakpointRef = useRef<Breakpoint>(getBreakpoint())\n\n  const subscribe = useCallback(\n    (listener: () => void) => {\n      if (!hasContainer || !hasQueries) {\n        const observer = queries.map(({ breakpoint, query }): (() => void) => {\n          const mql = getWindow()?.matchMedia(query)\n\n          const onChange = (e: MediaQueryListEvent) => {\n            if (e.matches) breakpointRef.current = breakpoint\n\n            listener()\n          }\n\n          mql?.addEventListener(\"change\", onChange)\n\n          return () => {\n            mql?.removeEventListener(\"change\", onChange)\n          }\n        })\n\n        return () => {\n          observer.forEach((unobserve) => unobserve())\n        }\n      } else if (createdDom()) {\n        const observer = new ResizeObserver(([entry]) => {\n          if (!entry) return\n\n          cancelAnimationFrame(animationFrameId.current)\n\n          const { width } = entry.contentRect\n\n          breakpointRef.current = getBreakpoint(width)\n\n          animationFrameId.current = requestAnimationFrame(listener)\n        })\n\n        if (containerRef.current) observer.observe(containerRef.current)\n\n        return () => {\n          observer.disconnect()\n\n          if (process.env.NODE_ENV !== \"test\")\n            cancelAnimationFrame(animationFrameId.current)\n        }\n      } else {\n        return noop\n      }\n    },\n    [containerRef, getBreakpoint, getWindow, hasContainer, hasQueries, queries],\n  )\n\n  const getSnapshot = useCallback(() => {\n    return breakpointRef.current\n  }, [])\n\n  const breakpoint = useSyncExternalStore(subscribe, getSnapshot, getSnapshot)\n\n  return breakpoint\n}\n"
    },
    {
      "name": "use-update-breakpoint-effect.ts",
      "content": "import type { DependencyList } from \"react\"\nimport type { Breakpoint } from \"@yamada-ui/react\"\nimport { useUpdateEffect } from \"@yamada-ui/react\"\nimport { useBreakpoint } from \"./use-breakpoint\"\n\n/**\n * `useUpdateBreakpointEffect` is a custom hook that skips the side effect on the initial render and executes a specific callback function when the breakpoint changes.\n *\n * @see https://yamada-ui.com/hooks/use-update-breakpoint-effect\n */\nexport const useUpdateBreakpointEffect = (\n  callback: (breakpoint: Breakpoint) => void,\n  deps: DependencyList,\n) => {\n  const breakpoint = useBreakpoint()\n\n  useUpdateEffect(() => {\n    callback(breakpoint)\n  }, [breakpoint, ...deps])\n}\n"
    }
  ]
}
