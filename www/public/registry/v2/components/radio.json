{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["group", "input", "field"],
    "externals": [],
    "hooks": ["use-controllable-state"],
    "providers": []
  },
  "dependents": { "components": ["radio-card"], "hooks": [], "providers": [] },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./radio.style\"\nexport * as RadioGroup from \"./namespace\"\nexport { Radio, RadioPropsContext, useRadioPropsContext } from \"./radio\"\nexport type { RadioProps } from \"./radio\"\nexport { RadioGroupRoot } from \"./radio-group\"\nexport type { RadioGroupRootProps } from \"./radio-group\"\nexport * from \"./use-radio\"\nexport * from \"./use-radio-group\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  Radio as Item,\n  RadioPropsContext as PropsContext,\n  useRadioPropsContext as usePropsContext,\n} from \"./radio\"\nexport type { RadioProps as ItemProps } from \"./radio\"\nexport { RadioGroupRoot as Root } from \"./radio-group\"\nexport type { RadioGroupRootProps as RootProps } from \"./radio-group\"\n"
    },
    {
      "name": "radio-group.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement, ReactNode } from \"react\"\nimport type {\n  GenericsComponent,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type { GroupProps } from \"../group\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { RadioProps } from \"./radio\"\nimport type { RadioStyle } from \"./radio.style\"\nimport type { UseRadioGroupProps } from \"./use-radio-group\"\nimport { useMemo } from \"react\"\nimport { Group } from \"../group\"\nimport {\n  component,\n  Radio,\n  RadioPropsContext,\n  useRootComponentProps,\n} from \"./radio\"\nimport { RadioGroupContext, useRadioGroup } from \"./use-radio-group\"\n\nexport interface RadioItem<Y extends string = string> extends RadioProps<Y> {\n  label: ReactNode\n}\n\nexport interface RadioGroupRootProps<Y extends string = string>\n  extends Omit<\n      WithoutThemeProps<GroupProps, RadioStyle>,\n      \"defaultValue\" | \"onChange\" | \"value\"\n    >,\n    ThemeProps<RadioStyle>,\n    UseRadioGroupProps<Y>,\n    UseInputBorderProps {\n  /**\n   * If provided, generate options based on items.\n   *\n   * @default '[]'\n   */\n  items?: RadioItem<Y>[]\n}\n\n/**\n * `RadioGroup` is a component that groups `Radio` components.\n *\n * @see https://yamada-ui.com/components/radio\n */\nexport const RadioGroupRoot = component<\"div\", RadioGroupRootProps>((props) => {\n  const [\n    ,\n    {\n      colorScheme,\n      size,\n      variant,\n      children,\n      disabled,\n      errorBorderColor,\n      focusBorderColor,\n      invalid,\n      items = [],\n      readOnly,\n      shape,\n      ...rest\n    },\n  ] = useRootComponentProps(props, \"group\", {\n    transferProps: [\"variant\", \"colorScheme\", \"size\", \"shape\"],\n  })\n  const { name, value, getInputProps, getLabelProps, getRootProps, onChange } =\n    useRadioGroup(rest)\n  const computedChildren = useMemo(() => {\n    if (children) return children\n\n    return items.map(({ label, value, ...rest }, index) => (\n      <Radio key={value ?? index} value={value} {...rest}>\n        {label}\n      </Radio>\n    ))\n  }, [items, children])\n  const context = useMemo(\n    () => ({\n      colorScheme,\n      size,\n      variant,\n      disabled,\n      errorBorderColor,\n      focusBorderColor,\n      invalid,\n      readOnly,\n      shape,\n    }),\n    [\n      variant,\n      size,\n      colorScheme,\n      shape,\n      disabled,\n      invalid,\n      readOnly,\n      errorBorderColor,\n      focusBorderColor,\n    ],\n  )\n  const groupContext = useMemo(\n    () => ({ name, value, getInputProps, getLabelProps, onChange }),\n    [name, value, getInputProps, getLabelProps, onChange],\n  )\n\n  return (\n    <RadioPropsContext value={context}>\n      <RadioGroupContext value={groupContext}>\n        <Group orientation=\"vertical\" {...getRootProps()}>\n          {computedChildren}\n        </Group>\n      </RadioGroupContext>\n    </RadioPropsContext>\n  )\n}, \"group\")() as GenericsComponent<{\n  <Y extends string = string>(props: RadioGroupRootProps<Y>): ReactElement\n}>\n"
    },
    {
      "name": "radio.style.ts",
      "content": "import { defineComponentSlotStyle, focusRingStyle } from \"@yamada-ui/react\"\n\nexport const radioStyle = defineComponentSlotStyle({\n  base: {\n    group: {},\n    indicator: {\n      alignItems: \"center\",\n      borderColor: \"{indicator-border-color}\",\n      borderWidth: \"2px\",\n      boxSize: \"{indicator-size}\",\n      display: \"inline-flex\",\n      focusRingColor: \"{focus-border-color}\",\n      \"input:focus-visible + &\": focusRingStyle.outline,\n      justifyContent: \"center\",\n      _before: { display: \"block\" },\n      _invalid: {\n        borderColor: \"{error-border-color}\",\n        focusRingColor: \"{error-border-color}\",\n      },\n    },\n    label: {},\n    root: {\n      \"--error-border-color\": \"colors.border.error\",\n      \"--focus-border-color\": \"colorScheme.outline\",\n      \"--indicator-border-color\": \"colors.border.emphasized\",\n      alignItems: \"center\",\n      display: \"flex\",\n      fontSize: \"{label-size}\",\n      gap: \"2\",\n      userSelect: \"none\",\n      _readOnly: { layerStyle: \"readOnly\" },\n      _disabled: { layerStyle: \"disabled\" },\n    },\n  },\n\n  props: {\n    /**\n     * The shape of the component\n     *\n     * @default 'circle'\n     */\n    shape: {\n      circle: { indicator: { rounded: \"full\", _before: { rounded: \"full\" } } },\n      rounded: {\n        indicator: {\n          rounded: \"l1\",\n          _before: { rounded: \"calc({radii.l1} / 2)\" },\n        },\n      },\n      square: {\n        indicator: { rounded: \"0\", _before: { rounded: \"0\" } },\n      },\n    },\n  },\n\n  variants: {\n    base: {\n      indicator: { _checked: { _before: { bg: \"colorScheme.solid\" } } },\n    },\n    outline: {\n      indicator: { _checked: { _before: { bg: \"colorScheme.outline\" } } },\n      root: { _checked: { \"--indicator-border-color\": \"colorScheme.outline\" } },\n    },\n    solid: {},\n    subtle: {\n      indicator: { bg: \"colorScheme.subtle\" },\n      root: { \"--indicator-border-color\": \"transparent\" },\n    },\n    surface: {\n      indicator: { bg: \"colorScheme.subtle\" },\n      root: { \"--indicator-border-color\": \"colorScheme.muted\" },\n    },\n  },\n\n  sizes: {\n    sm: {\n      indicator: { _before: { boxSize: \"1.5\" } },\n      root: { \"--indicator-size\": \"sizes.3.5\", \"--label-size\": \"fontSizes.sm\" },\n    },\n    md: {\n      indicator: { _before: { boxSize: \"2\" } },\n      root: { \"--indicator-size\": \"sizes.4\", \"--label-size\": \"fontSizes.md\" },\n    },\n    lg: {\n      indicator: { _before: { boxSize: \"3\" } },\n      root: { \"--indicator-size\": \"sizes.5\", \"--label-size\": \"fontSizes.lg\" },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"solid\",\n    shape: \"circle\",\n  },\n})\n\nexport type RadioStyle = typeof radioStyle\n"
    },
    {
      "name": "radio.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement } from \"react\"\nimport type {\n  GenericsComponent,\n  HTMLProps,\n  HTMLStyledProps,\n  ThemeProps,\n  Merge,\n} from \"@yamada-ui/react\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { RadioStyle } from \"./radio.style\"\nimport type { UseRadioProps } from \"./use-radio\"\nimport { useMemo } from \"react\"\nimport { createSlotComponent, styled, cast } from \"@yamada-ui/react\"\nimport { useInputBorder } from \"../input\"\nimport { radioStyle } from \"./radio.style\"\nimport { useRadio } from \"./use-radio\"\n\nexport interface RadioProps<Y extends string = string>\n  extends Merge<HTMLStyledProps<\"label\">, UseRadioProps<Y>>,\n    ThemeProps<RadioStyle>,\n    UseInputBorderProps {\n  /**\n   * Props for the indicator component.\n   */\n  indicatorProps?: RadioIndicatorProps\n  /**\n   * Props for the input element.\n   */\n  inputProps?: HTMLStyledProps<\"input\">\n  /**\n   * Props for the label component.\n   */\n  labelProps?: RadioLabelProps\n  /**\n   * Props for the label element.\n   */\n  rootProps?: HTMLStyledProps<\"label\">\n}\n\nconst {\n  component,\n  PropsContext: RadioPropsContext,\n  usePropsContext: useRadioPropsContext,\n  withContext,\n  withProvider,\n  useRootComponentProps,\n} = createSlotComponent<RadioProps, RadioStyle>(\"radio\", radioStyle)\n\nexport {\n  component,\n  RadioPropsContext,\n  useRadioPropsContext,\n  useRootComponentProps,\n}\n\n/**\n * `Radio` is a component used for allowing users to select one option from multiple choices.\n *\n * @see https://yamada-ui.com/components/radio\n */\nexport const Radio = withProvider<\"label\", RadioProps>(\n  ({\n    children,\n    errorBorderColor,\n    focusBorderColor,\n    indicatorProps,\n    inputProps,\n    labelProps,\n    rootProps,\n    ...rest\n  }) => {\n    const { getIndicatorProps, getInputProps, getRootProps } = useRadio(rest)\n    const varProps = useInputBorder({ errorBorderColor, focusBorderColor })\n    const input = useMemo(() => {\n      return <styled.input {...getInputProps(inputProps)} />\n    }, [getInputProps, inputProps])\n    const indicator = useMemo(() => {\n      return <RadioIndicator {...getIndicatorProps(indicatorProps)} />\n    }, [getIndicatorProps, indicatorProps])\n\n    if (children) {\n      return (\n        <styled.label {...getRootProps({ ...varProps, ...rootProps })}>\n          {input}\n          {indicator}\n          <RadioLabel {...labelProps}>{children}</RadioLabel>\n        </styled.label>\n      )\n    } else {\n      return (\n        <styled.div\n          {...cast<HTMLProps>(getRootProps({ ...varProps, ...rootProps }))}\n        >\n          {input}\n          {indicator}\n        </styled.div>\n      )\n    }\n  },\n  \"root\",\n)() as GenericsComponent<{\n  <Y extends string = string>(props: RadioProps<Y>): ReactElement\n}>\n\ninterface RadioIndicatorProps extends HTMLStyledProps {}\n\nconst RadioIndicator = withContext<\"div\", RadioIndicatorProps>(\n  \"div\",\n  \"indicator\",\n)()\n\ninterface RadioLabelProps extends HTMLStyledProps<\"span\"> {}\n\nconst RadioLabel = withContext<\"span\", RadioLabelProps>(\"span\", \"label\")()\n"
    },
    {
      "name": "use-radio-group.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useId } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport {\n  createContext,\n  cx,\n  dataAttr,\n  handlerAll,\n  isObject,\n  isUndefined,\n  mergeRefs,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\ninterface RadioGroupContext extends Omit<UseRadioGroupReturn, \"getRootProps\"> {}\n\nconst [RadioGroupContext, useRadioGroupContext] =\n  createContext<RadioGroupContext>({\n    name: \"RadioGroupContext\",\n    strict: false,\n  })\n\nexport { RadioGroupContext, useRadioGroupContext }\n\nexport interface UseRadioGroupProps<Y extends string = string>\n  extends Omit<HTMLProps, \"defaultValue\" | \"onChange\" | \"value\">,\n    FieldProps {\n  /**\n   * The initial value of the radio group.\n   */\n  defaultValue?: Y\n  /**\n   * The value of the radio group.\n   */\n  value?: Y\n  /**\n   * The callback fired when any children radio is checked or unchecked.\n   */\n  onChange?: (value: Y) => void\n}\n\nexport const useRadioGroup = <Y extends string = string>(\n  props: UseRadioGroupProps<Y> = {},\n) => {\n  const uuid = useId()\n  const {\n    context: { labelId } = {},\n    props: {\n      id = uuid,\n      defaultValue,\n      disabled,\n      readOnly,\n      required,\n      value: valueProp,\n      onChange: onChangeProp,\n      ...rest\n    },\n    ariaProps: { \"aria-describedby\": ariaDescribedbyProp, ...ariaProps },\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const interactive = !(readOnly || disabled)\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n\n  const onChange = useCallback(\n    (valueOrEv: ChangeEvent<HTMLInputElement> | Y) => {\n      if (!interactive) return\n\n      if (isObject(valueOrEv)) {\n        setValue(valueOrEv.target.value as Y)\n      } else {\n        setValue(valueOrEv)\n      }\n    },\n    [interactive, setValue],\n  )\n\n  const getRootProps: PropGetter = useCallback(\n    ({\n      ref,\n      \"aria-describedby\": ariaDescribedby,\n      \"aria-labelledby\": ariaLabelledby,\n      ...props\n    } = {}) => ({\n      ...dataProps,\n      id,\n      \"aria-describedby\": cx(ariaDescribedbyProp, ariaDescribedby),\n      \"aria-labelledby\": cx(labelId, ariaLabelledby),\n      role: \"radiogroup\",\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref),\n    }),\n    [ariaDescribedbyProp, dataProps, id, labelId, rest],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    (props = {}) => {\n      const checked = !isUndefined(value) && value === props.value\n\n      return {\n        ...dataProps,\n        ...ariaProps,\n        type: \"radio\",\n        name: id,\n        style: visuallyHiddenAttributes.style,\n        \"aria-checked\": checked,\n        \"data-checked\": dataAttr(checked),\n        checked,\n        disabled,\n        readOnly,\n        required,\n        ...props,\n        onBlur: handlerAll(props.onBlur, eventProps.onBlur),\n        onChange: handlerAll(props.onChange, onChange),\n        onFocus: handlerAll(props.onFocus, eventProps.onFocus),\n      }\n    },\n    [\n      ariaProps,\n      dataProps,\n      disabled,\n      eventProps,\n      id,\n      onChange,\n      readOnly,\n      required,\n      value,\n    ],\n  )\n\n  const getLabelProps: PropGetter<\"label\"> = useCallback(\n    (props) => ({\n      ...dataProps,\n      ...props,\n    }),\n    [dataProps],\n  )\n\n  return {\n    name: id,\n    value,\n    getInputProps,\n    getLabelProps,\n    getRootProps,\n    onChange,\n  }\n}\n\nexport type UseRadioGroupReturn = ReturnType<typeof useRadioGroup>\n"
    },
    {
      "name": "use-radio.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent, ChangeEventHandler, FocusEventHandler } from \"react\"\nimport type { HTMLProps, HTMLRefAttributes, PropGetter } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useId } from \"react\"\nimport { useControllableEventState } from \"../../hooks/use-controllable-state\"\nimport {\n  cx,\n  dataAttr,\n  handlerAll,\n  isUndefined,\n  mergeRefs,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\nimport { useRadioGroupContext } from \"./use-radio-group\"\n\nexport interface UseRadioProps<Y extends string = string>\n  extends Omit<HTMLProps<\"label\">, \"onBlur\" | \"onChange\" | \"onFocus\" | \"ref\">,\n    HTMLRefAttributes<\"input\">,\n    FieldProps {\n  /**\n   * id assigned to input.\n   */\n  id?: string\n  /**\n   * The name of the input field in a radio.\n   */\n  name?: string\n  /**\n   * If `true`, the radio will be checked.\n   */\n  checked?: boolean\n  /**\n   * If `true`, the radio will be initially checked.\n   *\n   * @default false\n   */\n  defaultChecked?: boolean\n  /**\n   * The value of the radio.\n   */\n  value?: Y\n  /**\n   * The callback invoked when the radio is blurred.\n   */\n  onBlur?: FocusEventHandler<HTMLInputElement>\n  /**\n   * The callback invoked when the checked state changes.\n   */\n  onChange?: ChangeEventHandler<HTMLInputElement>\n  /**\n   * The callback invoked when the radio is focused.\n   */\n  onFocus?: FocusEventHandler<HTMLInputElement>\n}\n\nexport const useRadio = <Y extends string = string>({\n  \"aria-describedby\": ariaDescribedbyProp,\n  ...props\n}: UseRadioProps<Y> = {}) => {\n  const group = useRadioGroupContext()\n  const {\n    name: groupName,\n    value: groupValue,\n    getInputProps: getGroupInputProps,\n    getLabelProps,\n  } = group ?? {}\n  const uuid = useId()\n  const {\n    props: {\n      id,\n      ref,\n      name = groupName,\n      checked: checkedProp,\n      defaultChecked = false,\n      disabled,\n      readOnly,\n      required,\n      value,\n      onChange: onChangeProp,\n      ...rest\n    },\n    ariaProps: { \"aria-describedby\": ariaDescribedby, ...ariaProps },\n    dataProps,\n    eventProps,\n  } = useFieldProps({\n    id: group ? uuid : undefined,\n    ...props,\n    notSupportReadOnly: true,\n  })\n  const interactive = !(readOnly || disabled)\n  const resolvedAriaDescribedby = group ? ariaDescribedbyProp : ariaDescribedby\n  const resolvedChecked =\n    !isUndefined(groupValue) && !isUndefined(value)\n      ? groupValue === value\n      : checkedProp\n  const [checked, setChecked] = useControllableEventState({\n    defaultValue: defaultChecked,\n    value: resolvedChecked,\n    onChange: onChangeProp,\n  })\n\n  const onChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      if (!interactive) return (ev.defaultPrevented = true)\n\n      setChecked(ev)\n    },\n    [setChecked, interactive],\n  )\n\n  const getRootProps: PropGetter<\"label\"> = useCallback(\n    (props = {}) => {\n      const sharedProps = {\n        ...dataProps,\n        \"data-checked\": dataAttr(checked),\n        ...rest,\n        ...props,\n      }\n\n      return getLabelProps?.(sharedProps) ?? sharedProps\n    },\n    [dataProps, getLabelProps, checked, rest],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    ({ \"aria-describedby\": ariaDescribedby, ...props } = {}) => {\n      const sharedProps = {\n        ...dataProps,\n        ...ariaProps,\n        id,\n        type: \"radio\",\n        name,\n        style: visuallyHiddenAttributes.style,\n        \"aria-checked\": checked,\n        \"aria-describedby\": cx(resolvedAriaDescribedby, ariaDescribedby),\n        \"data-checked\": dataAttr(checked),\n        checked,\n        disabled,\n        readOnly,\n        required,\n        value,\n        ...props,\n        ref: mergeRefs(props.ref, ref),\n        onBlur: handlerAll(props.onBlur, eventProps.onBlur),\n        onChange: handlerAll(props.onChange, onChange),\n        onFocus: handlerAll(props.onFocus, eventProps.onFocus),\n      }\n\n      return getGroupInputProps?.(sharedProps) ?? sharedProps\n    },\n    [\n      id,\n      name,\n      checked,\n      resolvedAriaDescribedby,\n      disabled,\n      readOnly,\n      required,\n      value,\n      dataProps,\n      ariaProps,\n      ref,\n      eventProps,\n      onChange,\n      getGroupInputProps,\n    ],\n  )\n\n  const getIndicatorProps: PropGetter = useCallback(\n    (props = {}) => ({\n      ...dataProps,\n      \"aria-hidden\": \"true\",\n      \"data-checked\": dataAttr(checked),\n      ...props,\n    }),\n    [dataProps, checked],\n  )\n\n  return {\n    checked,\n    getIndicatorProps,\n    getInputProps,\n    getRootProps,\n    onChange,\n  }\n}\n\nexport type UseRadioReturn = ReturnType<typeof useRadio>\n"
    }
  ]
}
