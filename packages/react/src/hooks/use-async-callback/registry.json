{
  "dependencies": {
    "components": ["loading"],
    "externals": [],
    "hooks": ["use-processing"],
    "providers": []
  },
  "section": "hooks",
  "sources": [
    {
      "name": "index.ts",
      "content": "import type { DependencyList } from \"react\"\nimport type { LoadingOptions } from \"../../components/loading\"\nimport type { LoadingMethod } from \"../../components/loading/loading\"\nimport { useCallback, useMemo } from \"react\"\nimport { useLoading } from \"../../components/loading\"\nimport { useProcessing } from \"../../hooks/use-processing\"\n\ntype Callback = (...args: any[]) => any\n\nexport interface UseAsyncCallbackOptions {\n  /**\n   * The method to use for loading.\n   * If `false`, the loading will not be shown.\n   */\n  loading?: false | LoadingMethod\n  /**\n   * The options to pass to the loading component.\n   */\n  loadingOptions?: LoadingOptions\n  /**\n   * If `false`, the processing will not change.\n   *\n   * @default true\n   */\n  processing?: boolean\n}\n\n/**\n * `useAsyncCallback` is a custom hook used to manage async callbacks.\n *\n * @see https://yamada-ui.com/hooks/use-async-callback\n */\nexport const useAsyncCallback = <Y extends Callback>(\n  callback: Y,\n  deps: DependencyList,\n  {\n    loading: method = false,\n    loadingOptions,\n    processing: shouldProcessing = true,\n  }: UseAsyncCallbackOptions = {},\n): UseAsyncCallbackReturn<Y> => {\n  const context = useLoading()\n  const { finish, loading, start } = useProcessing()\n  const shouldLoading = !!method\n\n  const asyncCallback = useCallback(\n    async (...args: Parameters<Y>) => {\n      try {\n        if (shouldProcessing) start()\n        if (shouldLoading) context[method].start(loadingOptions)\n\n        return await callback(...args)\n      } finally {\n        if (shouldProcessing) finish()\n        if (shouldLoading) context[method].finish()\n      }\n    },\n    [\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      ...deps,\n      shouldProcessing,\n      shouldLoading,\n      context,\n      method,\n      loadingOptions,\n      callback,\n      start,\n      finish,\n    ],\n  )\n\n  const control = useMemo(() => ({ finish, start }), [finish, start])\n\n  return [loading, asyncCallback, control]\n}\n\nexport type UseAsyncCallbackReturn<Y extends Callback> = [\n  loading: boolean,\n  callback: (...args: Parameters<Y>) => Promise<Awaited<ReturnType<Y>>>,\n  control: { finish: () => void; start: () => void },\n]\n"
    }
  ]
}
