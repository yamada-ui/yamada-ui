{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "h-stack.style.ts",
      "content": "import { defineComponentStyle } from \"@yamada-ui/react\"\n\nexport const hStackStyle = defineComponentStyle({\n  base: {\n    alignItems: \"center\",\n    gap: \"md\",\n  },\n})\n\nexport type HStackStyle = typeof hStackStyle\n"
    },
    {
      "name": "h-stack.tsx",
      "content": "\"use client\"\n\nimport type { ThemeProps, WithoutThemeProps } from \"@yamada-ui/react\"\nimport type { HStackStyle } from \"./h-stack.style\"\nimport type { StackProps } from \"./stack\"\nimport { createComponent } from \"@yamada-ui/react\"\nimport { hStackStyle } from \"./h-stack.style\"\nimport { Stack } from \"./stack\"\n\nexport interface HStackProps\n  extends WithoutThemeProps<StackProps, HStackStyle>,\n    ThemeProps<HStackStyle> {}\n\nconst {\n  PropsContext: HStackPropsContext,\n  usePropsContext: useHStackPropsContext,\n  withContext,\n} = createComponent<HStackProps, HStackStyle>(\"stack--horizontal\", hStackStyle)\n\nexport { HStackPropsContext, useHStackPropsContext }\n\n/**\n * `HStack` is a component that groups elements and provides space between child elements.\n *\n * @see https://yamada-ui.com/components/stack\n */\nexport const HStack = withContext<\"div\", HStackProps>(Stack)(undefined, {\n  direction: \"row\",\n})\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./h-stack.style\"\nexport * from \"./stack.style\"\nexport * from \"./v-stack.style\"\nexport * from \"./z-stack.style\"\nexport { HStack, HStackPropsContext, useHStackPropsContext } from \"./h-stack\"\nexport type { HStackProps } from \"./h-stack\"\nexport { Stack, StackPropsContext, useStackPropsContext } from \"./stack\"\nexport type { StackProps } from \"./stack\"\nexport { useVStackPropsContext, VStack, VStackPropsContext } from \"./v-stack\"\nexport type { VStackProps } from \"./v-stack\"\nexport { useZStackPropsContext, ZStack, ZStackPropsContext } from \"./z-stack\"\nexport type { ZStackProps } from \"./z-stack\"\n"
    },
    {
      "name": "stack.style.ts",
      "content": "import { defineComponentStyle } from \"@yamada-ui/react\"\n\nexport const stackStyle = defineComponentStyle({\n  base: {\n    display: \"flex\",\n    gap: \"lg\",\n  },\n})\n\nexport type StackStyle = typeof stackStyle\n"
    },
    {
      "name": "stack.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement } from \"react\"\nimport type { CSSProps, HTMLStyledProps } from \"@yamada-ui/react\"\nimport type { StackStyle } from \"./stack.style\"\nimport { cloneElement, Fragment, useMemo } from \"react\"\nimport {\n  createComponent,\n  styled,\n  replaceObject,\n  useValidChildren,\n} from \"@yamada-ui/react\"\nimport { stackStyle } from \"./stack.style\"\n\nexport interface StackProps extends Omit<HTMLStyledProps, \"direction\"> {\n  /**\n   * The CSS `align-items` property.\n   */\n  align?: CSSProps[\"alignItems\"]\n  /**\n   * The CSS `flex-direction` property.\n   */\n  direction?: CSSProps[\"flexDirection\"]\n  /**\n   * The CSS `justify-content` property.\n   */\n  justify?: CSSProps[\"justifyContent\"]\n  /**\n   * If `true`, each stack item will show a separator.\n   */\n  separator?: ReactElement\n  /**\n   * The CSS `flex-wrap` property.\n   */\n  wrap?: CSSProps[\"flexWrap\"]\n}\n\nconst {\n  PropsContext: StackPropsContext,\n  usePropsContext: useStackPropsContext,\n  withContext,\n} = createComponent<StackProps, StackStyle>(\"stack\", stackStyle)\n\nexport { StackPropsContext, useStackPropsContext }\n\n/**\n * `Stack` is a component that groups elements and provides space between child elements.\n *\n * @see https://yamada-ui.com/components/stack\n */\nexport const Stack = withContext<\"div\", StackProps>(\n  ({\n    align: alignItems,\n    children,\n    direction: flexDirection = \"column\",\n    justify: justifyContent,\n    separator,\n    wrap: flexWrap,\n    ...rest\n  }) => {\n    const isColumn = (value: any) =>\n      value === \"column\" || value === \"column-reverse\"\n\n    const validChildren = useValidChildren(children)\n    const cloneChildren = useMemo(\n      () =>\n        separator\n          ? validChildren.map((child, index) => {\n              const key = typeof child.key !== \"undefined\" ? child.key : index\n\n              const cloneSeparator = cloneElement<any>(separator, {\n                borderWidth: replaceObject(flexDirection, (value) =>\n                  isColumn(value) ? \"0 0 1px 0\" : \"0 0 0 1px\",\n                ),\n                h: replaceObject(flexDirection, (value) =>\n                  isColumn(value) ? \"fit-content\" : \"100%\",\n                ),\n                w: replaceObject(flexDirection, (value) =>\n                  isColumn(value) ? \"100%\" : \"fit-content\",\n                ),\n              })\n\n              return (\n                <Fragment key={key}>\n                  {!!index ? cloneSeparator : null}\n                  {child}\n                </Fragment>\n              )\n            })\n          : validChildren,\n      [separator, flexDirection, validChildren],\n    )\n\n    return (\n      <styled.div\n        alignItems={alignItems}\n        flexDirection={flexDirection}\n        flexWrap={flexWrap}\n        justifyContent={justifyContent}\n        {...rest}\n      >\n        {cloneChildren}\n      </styled.div>\n    )\n  },\n)()\n"
    },
    {
      "name": "v-stack.style.ts",
      "content": "import { defineComponentStyle } from \"@yamada-ui/react\"\n\nexport const vStackStyle = defineComponentStyle({\n  base: {\n    alignItems: \"stretch\",\n    width: \"full\",\n  },\n})\n\nexport type VStackStyle = typeof vStackStyle\n"
    },
    {
      "name": "v-stack.tsx",
      "content": "\"use client\"\n\nimport type { ThemeProps, WithoutThemeProps } from \"@yamada-ui/react\"\nimport type { StackProps } from \"./stack\"\nimport type { VStackStyle } from \"./v-stack.style\"\nimport { createComponent } from \"@yamada-ui/react\"\nimport { Stack } from \"./stack\"\nimport { vStackStyle } from \"./v-stack.style\"\n\nexport interface VStackProps\n  extends WithoutThemeProps<StackProps, VStackStyle>,\n    ThemeProps<VStackStyle> {}\n\nconst {\n  PropsContext: VStackPropsContext,\n  usePropsContext: useVStackPropsContext,\n  withContext,\n} = createComponent<VStackProps, VStackStyle>(\"stack--vertical\", vStackStyle)\n\nexport { useVStackPropsContext, VStackPropsContext }\n\n/**\n * `VStack` is a component that groups elements and provides space between child elements.\n *\n * @see https://yamada-ui.com/components/stack\n */\nexport const VStack = withContext<\"div\", VStackProps>(Stack)(undefined, {\n  direction: \"column\",\n})\n"
    },
    {
      "name": "z-stack.style.ts",
      "content": "import { defineComponentStyle } from \"@yamada-ui/react\"\n\nexport const zStackStyle = defineComponentStyle({\n  base: {\n    gap: \"lg\",\n    overflow: \"hidden\",\n    position: \"relative\",\n  },\n})\n\nexport type ZStackStyle = typeof zStackStyle\n"
    },
    {
      "name": "z-stack.tsx",
      "content": "\"use client\"\n\nimport type { RefObject } from \"react\"\nimport type {\n  CSSObject,\n  Direction,\n  HTMLStyledProps,\n  ThemeProps,\n} from \"@yamada-ui/react\"\nimport type { ZStackStyle } from \"./z-stack.style\"\nimport {\n  cloneElement,\n  createRef,\n  Fragment,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport {\n  createComponent,\n  mergeCSS,\n  styled,\n  useInjectVarsIntoCss,\n  useInjectVarsIntoProps,\n  getValidChildren,\n  mergeRefs,\n} from \"@yamada-ui/react\"\nimport { zStackStyle } from \"./z-stack.style\"\n\nexport interface ZStackProps\n  extends Omit<HTMLStyledProps, \"direction\">,\n    ThemeProps<ZStackStyle> {\n  /**\n   * Stack in the specified direction.\n   *\n   * @default \"end\"\n   */\n  direction?: Direction\n  /**\n   * If `true`, calculate the `width` and `height` of the element and assign container.\n   *\n   * @default true\n   */\n  fit?: boolean\n  /**\n   * If `true`, reverse direction.\n   *\n   * @default false\n   */\n  reverse?: boolean\n  /**\n   * If set the stack will start from the given index.\n   *\n   * @default 0\n   */\n  startIndex?: number\n}\n\nconst {\n  PropsContext: ZStackPropsContext,\n  usePropsContext: useZStackPropsContext,\n  withContext,\n} = createComponent<ZStackProps, ZStackStyle>(\"stack--depth\", zStackStyle)\n\nexport { useZStackPropsContext, ZStackPropsContext }\n\n/**\n * `ZStack` is a component that groups elements and provides space between child elements.\n *\n * @see https://yamada-ui.com/components/stack\n */\nexport const ZStack = withContext<\"div\", ZStackProps>(\n  ({\n    css,\n    children,\n    direction = \"end\",\n    fit = true,\n    reverse = false,\n    startIndex = 0,\n    ...rest\n  }) => {\n    if (direction === \"start-center\") direction = \"start\"\n    if (direction === \"end-center\") direction = \"end\"\n\n    const refMap = useRef<Map<number, RefObject<HTMLDivElement | null>>>(\n      new Map(),\n    )\n    const [rect, setRect] = useState<{ height: number; width: number }>({\n      height: 0,\n      width: 0,\n    })\n\n    const vertical = useCallback(\n      (space: string) => {\n        if (direction.startsWith(\"start\")) {\n          return { [!reverse ? \"bottom\" : \"top\"]: space }\n        } else if (direction.startsWith(\"end\")) {\n          return { [!reverse ? \"top\" : \"bottom\"]: space }\n        } else {\n          return { [!reverse ? \"top\" : \"bottom\"]: 0 }\n        }\n      },\n      [direction, reverse],\n    )\n\n    const horizontal = useCallback(\n      (space: string) => {\n        if (direction.endsWith(\"-start\")) {\n          return { [!reverse ? \"right\" : \"left\"]: space }\n        } else if (direction.endsWith(\"-end\")) {\n          return { [!reverse ? \"left\" : \"right\"]: space }\n        } else {\n          return { [!reverse ? \"left\" : \"right\"]: 0 }\n        }\n      },\n      [direction, reverse],\n    )\n\n    const cloneChildren = useMemo(() => {\n      const validChildren = getValidChildren(children)\n\n      const clonedChildren = validChildren.map((child, index) => {\n        const ref = createRef<HTMLDivElement>()\n\n        refMap.current.set(index, ref)\n\n        const key = child.key ?? index\n\n        const zIndex = startIndex + index\n        const space = `calc({space} * ${index})`\n\n        const css: CSSObject = {\n          position: \"absolute\",\n          zIndex,\n          ...vertical(space),\n          ...horizontal(space),\n        }\n\n        const props = {\n          ...child.props,\n          ref: mergeRefs(child.props.ref, ref),\n          css: mergeCSS(child.props.css, css),\n        }\n\n        const clonedChild = cloneElement(child, props)\n\n        return <Fragment key={key}>{clonedChild}</Fragment>\n      })\n\n      return clonedChildren\n    }, [children, startIndex, vertical, horizontal])\n\n    useEffect(() => {\n      if (!fit) return\n\n      let negativeLeft = direction.endsWith(\"-start\")\n      let negativeTop = direction.startsWith(\"start\")\n      let width = 0\n      let height = 0\n\n      if (reverse) {\n        negativeLeft = !negativeLeft\n        negativeTop = !negativeTop\n      }\n\n      for (const ref of refMap.current.values()) {\n        if (!ref.current) continue\n\n        let { offsetHeight, offsetLeft, offsetParent, offsetTop, offsetWidth } =\n          ref.current\n\n        if (!offsetParent && process.env.NODE_ENV !== \"test\") continue\n\n        if (negativeLeft) {\n          const offsetParentWidth =\n            (offsetParent as HTMLDivElement | null)?.offsetWidth ?? 0\n\n          offsetLeft = offsetParentWidth - offsetLeft - offsetWidth\n        }\n\n        if (negativeTop) {\n          const offsetParentHeight =\n            (offsetParent as HTMLDivElement | null)?.offsetHeight ?? 0\n\n          offsetTop = offsetParentHeight - offsetTop - offsetHeight\n        }\n\n        offsetWidth += offsetLeft\n        offsetHeight += offsetTop\n\n        if (offsetWidth > width) width = offsetWidth\n        if (offsetHeight > height) height = offsetHeight\n      }\n\n      setRect({ height, width })\n    }, [cloneChildren, direction, reverse, fit])\n\n    return (\n      <styled.div\n        css={css}\n        minHeight={fit ? `${rect.height}px` : undefined}\n        minWidth={fit ? `${rect.width}px` : undefined}\n        {...rest}\n      >\n        {cloneChildren}\n      </styled.div>\n    )\n  },\n)(undefined, (props) => {\n  const css = useInjectVarsIntoCss(props.css, { gap: \"space\" })\n  const rest = useInjectVarsIntoProps(props, { gap: \"space\" })\n\n  return { ...rest, css }\n})\n"
    }
  ]
}
