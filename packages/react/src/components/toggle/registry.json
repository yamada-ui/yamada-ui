{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["group", "button", "input", "portal", "field"],
    "externals": [],
    "hooks": ["use-controllable-state"],
    "providers": ["i18n-provider"]
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./toggle.style\"\nexport * as ToggleGroup from \"./namespace\"\nexport { Toggle, TogglePropsContext, useTogglePropsContext } from \"./toggle\"\nexport type { ToggleProps } from \"./toggle\"\nexport { ToggleGroupRoot } from \"./toggle-group\"\nexport type { ToggleGroupRootProps } from \"./toggle-group\"\nexport * from \"./use-toggle\"\nexport * from \"./use-toggle-group\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  Toggle as Item,\n  TogglePropsContext as PropsContext,\n  useTogglePropsContext as usePropsContext,\n} from \"./toggle\"\nexport type { ToggleProps as ItemProps } from \"./toggle\"\nexport { ToggleGroupRoot as Root } from \"./toggle-group\"\nexport type { ToggleGroupRootProps as RootProps } from \"./toggle-group\"\n"
    },
    {
      "name": "toggle-group.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement } from \"react\"\nimport type {\n  GenericsComponent,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type { GroupProps } from \"../group\"\nimport type { ToggleProps } from \"./toggle\"\nimport type { ToggleStyle } from \"./toggle.style\"\nimport type { UseToggleGroupProps } from \"./use-toggle-group\"\nimport { useMemo } from \"react\"\nimport { Group } from \"../group\"\nimport { component, TogglePropsContext, useRootComponentProps } from \"./toggle\"\nimport { ToggleGroupContext, useToggleGroup } from \"./use-toggle-group\"\n\n/**\n * `ToggleGroup` is a set of two-state buttons that can be toggled on or off.\n *\n * @see https://yamada-ui.com/components/toggle\n */\nexport interface ToggleGroupRootProps<Y extends string | string[] = string>\n  extends Omit<\n      WithoutThemeProps<GroupProps, ToggleStyle>,\n      \"defaultValue\" | \"onChange\" | \"value\"\n    >,\n    UseToggleGroupProps<Y>,\n    ThemeProps<ToggleStyle> {}\n\nexport const ToggleGroupRoot = component<\"div\", ToggleGroupRootProps>(\n  (props: ToggleGroupRootProps) => {\n    const [, { colorScheme, size, variant, attached, ...rest }] =\n      useRootComponentProps(props, \"group\", {\n        transferProps: [\"size\", \"variant\", \"colorScheme\"],\n      })\n    const {\n      disabled,\n      readOnly,\n      value,\n      getGroupProps,\n      onChange,\n      onChangeMapRef,\n    } = useToggleGroup(rest)\n    const context = useMemo<ToggleProps>(\n      () => ({\n        colorScheme,\n        size,\n        variant,\n        focusVisibleRing: attached ? \"inside\" : undefined,\n      }),\n      [variant, size, colorScheme, attached],\n    )\n    const groupContext = useMemo(\n      () => ({\n        disabled,\n        readOnly,\n        value,\n        onChange,\n        onChangeMapRef,\n      }),\n      [value, disabled, readOnly, onChange, onChangeMapRef],\n    )\n\n    return (\n      <TogglePropsContext value={context}>\n        <ToggleGroupContext value={groupContext}>\n          <Group attached={attached} {...getGroupProps()} />\n        </ToggleGroupContext>\n      </TogglePropsContext>\n    )\n  },\n  \"group\",\n)() as GenericsComponent<{\n  <Y extends string | string[] = string>(\n    props: ToggleGroupRootProps<Y>,\n  ): ReactElement\n}>\n"
    },
    {
      "name": "toggle.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\nimport { iconButtonStyle } from \"../button\"\n\nexport const toggleStyle = defineComponentSlotStyle({\n  base: {\n    group: {},\n    root: {\n      \"--error-border-color\": \"colors.border.error\",\n      gap: \"2\",\n    },\n  },\n\n  props: {\n    /**\n     * If true, the toggle button is full rounded. Else, it'll be slightly round.\n     *\n     * @default false\n     */\n    fullRounded: {\n      true: {\n        root: {\n          rounded: \"full\",\n        },\n      },\n    },\n  },\n\n  variants: {\n    ghost: {\n      root: {\n        _checked: {\n          layerStyle: \"solid\",\n        },\n        _notChecked: {\n          layerStyle: \"ghost\",\n          _hover: {\n            layerStyle: \"ghost.hover\",\n          },\n        },\n        _invalid: {\n          borderColor: \"{error-border-color}\",\n          borderWidth: \"1px\",\n        },\n      },\n    },\n    outline: {\n      root: {\n        _checked: {\n          layerStyle: \"solid\",\n          borderColor: \"colorScheme.solid\",\n          borderWidth: \"1px\",\n          _invalid: {\n            borderColor: \"{error-border-color}\",\n          },\n        },\n        _notChecked: {\n          layerStyle: \"outline\",\n          _hover: {\n            layerStyle: \"outline.hover\",\n          },\n          _invalid: {\n            borderColor: \"{error-border-color}\",\n          },\n        },\n      },\n    },\n    solid: {\n      root: {\n        _checked: {\n          layerStyle: \"subtle\",\n        },\n        _notChecked: {\n          layerStyle: \"solid\",\n          _hover: {\n            layerStyle: \"solid.hover\",\n          },\n        },\n        _invalid: {\n          borderColor: \"{error-border-color}\",\n          borderWidth: \"1px\",\n        },\n      },\n    },\n    subtle: {\n      root: {\n        _checked: {\n          layerStyle: \"solid\",\n        },\n        _notChecked: {\n          layerStyle: \"subtle\",\n          _hover: {\n            layerStyle: \"subtle.hover\",\n          },\n        },\n        _invalid: {\n          borderColor: \"{error-border-color}\",\n          borderWidth: \"1px\",\n        },\n      },\n    },\n    surface: {\n      root: {\n        _checked: {\n          layerStyle: \"solid\",\n          _invalid: {\n            borderColor: \"{error-border-color}\",\n            borderWidth: \"1px\",\n          },\n        },\n        _notChecked: {\n          layerStyle: \"surface\",\n          _hover: {\n            layerStyle: \"surface.hover\",\n          },\n          _invalid: {\n            borderColor: \"{error-border-color}\",\n          },\n        },\n      },\n    },\n  },\n\n  sizes: {\n    xs: {\n      root: {\n        ...iconButtonStyle.sizes?.xs,\n        gap: \"1\",\n      },\n    },\n    sm: {\n      root: {\n        ...iconButtonStyle.sizes?.sm,\n        gap: \"2\",\n      },\n    },\n    md: {\n      root: {\n        ...iconButtonStyle.sizes?.md,\n        gap: \"2\",\n      },\n    },\n    lg: {\n      root: {\n        ...iconButtonStyle.sizes?.lg,\n        gap: \"2.5\",\n      },\n    },\n    xl: {\n      root: {\n        ...iconButtonStyle.sizes?.xl,\n        gap: \"3\",\n      },\n    },\n    \"2xl\": {\n      root: {\n        ...iconButtonStyle.sizes?.[\"2xl\"],\n        gap: \"3\",\n      },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"ghost\",\n  },\n})\n\nexport type ToggleStyle = typeof toggleStyle\n"
    },
    {
      "name": "toggle.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement } from \"react\"\nimport type {\n  GenericsComponent,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type { IconButtonProps } from \"../button\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { ToggleStyle } from \"./toggle.style\"\nimport type { UseToggleProps } from \"./use-toggle\"\nimport { createSlotComponent, styled } from \"@yamada-ui/react\"\nimport { IconButton } from \"../button\"\nimport { useInputBorder } from \"../input\"\nimport { Portal } from \"../portal\"\nimport { toggleStyle } from \"./toggle.style\"\nimport { useToggle } from \"./use-toggle\"\n\nexport interface ToggleProps<Y extends string = string>\n  extends Omit<\n      WithoutThemeProps<IconButtonProps, ToggleStyle>,\n      \"aria-label\" | \"onChange\" | \"ref\" | \"value\"\n    >,\n    UseToggleProps<Y>,\n    Pick<UseInputBorderProps, \"errorBorderColor\">,\n    ThemeProps<ToggleStyle> {}\n\nconst {\n  component,\n  PropsContext: TogglePropsContext,\n  usePropsContext: useTogglePropsContext,\n  withProvider,\n  useRootComponentProps,\n} = createSlotComponent<ToggleProps, ToggleStyle>(\"toggle\", toggleStyle)\n\nexport {\n  component,\n  TogglePropsContext,\n  useRootComponentProps,\n  useTogglePropsContext,\n}\n\n/**\n * `Toggle` is a two-state button that can be either on or off.\n *\n * @see https://yamada-ui.com/components/toggle\n */\nexport const Toggle = withProvider<\"button\", ToggleProps>(\n  ({ errorBorderColor, icon, ...rest }: ToggleProps) => {\n    const { getButtonProps, getInputProps } = useToggle(rest)\n    const varProps = useInputBorder({ errorBorderColor })\n\n    return (\n      <>\n        <Portal>\n          <styled.input {...getInputProps()} />\n        </Portal>\n\n        <IconButton icon={icon} {...varProps} {...getButtonProps()} />\n      </>\n    )\n  },\n  \"root\",\n)() as GenericsComponent<{\n  <Y extends string = string>(props: ToggleProps<Y>): ReactElement\n}>\n"
    },
    {
      "name": "use-toggle-group.ts",
      "content": "\"use client\"\n\nimport type { RefObject } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport { useCallback, useRef } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport {\n  createContext,\n  dataAttr,\n  isArray,\n  isUndefined,\n  toArray,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\n\ninterface ToggleGroupContext {\n  onChangeMapRef: RefObject<Map<string, (value: boolean) => void>>\n  disabled?: boolean\n  readOnly?: boolean\n  value?: string | string[]\n  onChange?: <Y extends string = string>(value: undefined | Y) => void\n}\n\nconst [ToggleGroupContext, useToggleGroupContext] =\n  createContext<ToggleGroupContext>({\n    name: \"ToggleGroupContext\",\n    strict: false,\n  })\n\nexport { ToggleGroupContext, useToggleGroupContext }\n\nexport interface UseToggleGroupProps<Y extends string | string[] = string>\n  extends Omit<HTMLProps, \"defaultValue\" | \"onChange\" | \"value\"> {\n  /**\n   * The initial value of the toggle button group.\n   */\n  defaultValue?: Y extends any[] ? Y : undefined | Y\n  /**\n   * If `true`, all wrapped toggle button will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * If `true`, all wrapped toggle button will be readonly.\n   *\n   * @default false\n   */\n  readOnly?: boolean\n  /**\n   * The value of the toggle button group.\n   */\n  value?: Y extends any[] ? Y : undefined | Y\n  /**\n   * The callback fired when any children toggle button is selected or unselected.\n   */\n  onChange?: (value: Y extends any[] ? Y : undefined | Y) => void\n}\n\nexport const useToggleGroup = <Y extends string | string[] = string>({\n  defaultValue,\n  disabled,\n  readOnly,\n  value: valueProp,\n  onChange: onChangeProp,\n  ...rest\n}: UseToggleGroupProps<Y>) => {\n  type Value = Y extends any[] ? Y : undefined | Y\n\n  const onChangeMapRef = useRef<Map<string, (value: boolean) => void>>(\n    new Map(),\n  )\n  const [value, setValue] = useControllableState<Value>({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n\n  const onReset = useCallback((targetValue?: string[]) => {\n    onChangeMapRef.current.forEach((onChange, value) => {\n      if (targetValue?.includes(value)) {\n        onChange(true)\n      } else {\n        onChange(false)\n      }\n    })\n  }, [])\n\n  const onChange = useCallback(\n    <M extends string = Y extends any[] ? Y[number] : Y>(\n      value: M | undefined,\n    ) => {\n      if (isUndefined(value)) return\n\n      setValue((prev) => {\n        if (isArray(prev)) {\n          const included = prev.includes(value)\n\n          if (included) {\n            const nextValue = prev.filter((prevValue) => prevValue !== value)\n\n            onReset(nextValue)\n\n            return nextValue as Value\n          } else {\n            const nextValue = [...prev, value]\n\n            onReset(nextValue)\n\n            return nextValue as Value\n          }\n        } else {\n          if (value === (prev as string | undefined)) {\n            onReset()\n\n            return undefined as Value\n          } else {\n            onReset([value])\n\n            return value as unknown as Value\n          }\n        }\n      })\n    },\n    [setValue, onReset],\n  )\n\n  useUpdateEffect(() => {\n    onReset(!isUndefined(valueProp) ? toArray(valueProp) : undefined)\n\n    setValue(valueProp as Value)\n  }, [valueProp])\n\n  const getGroupProps: PropGetter = useCallback(\n    (props) => ({\n      \"data-disabled\": dataAttr(disabled),\n      \"data-readonly\": dataAttr(readOnly),\n      role: \"group\",\n      ...rest,\n      ...props,\n    }),\n    [disabled, readOnly, rest],\n  )\n\n  return { disabled, readOnly, value, getGroupProps, onChange, onChangeMapRef }\n}\n\nexport type UseToggleGroupReturn = ReturnType<typeof useToggleGroup>\n"
    },
    {
      "name": "use-toggle.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent } from \"react\"\nimport type {\n  HTMLProps,\n  HTMLRefAttributes,\n  PropGetter,\n  Merge,\n} from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useMemo, useRef } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport {\n  ariaAttr,\n  dataAttr,\n  handlerAll,\n  isArray,\n  isUndefined,\n  mergeRefs,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\nimport { useToggleGroupContext } from \"./use-toggle-group\"\n\nexport interface UseToggleProps<Y extends string = string>\n  extends FieldProps,\n    HTMLRefAttributes<\"input\">,\n    Omit<HTMLProps<\"button\">, \"onChange\" | \"ref\" | \"value\"> {\n  /**\n   * If `true`, the toggle button is represented as active.\n   *\n   * @default false\n   */\n  active?: boolean\n  /**\n   * If `true`, the toggle button will be checked.\n   */\n  checked?: boolean\n  /**\n   * If `true`, the toggle button will be initially checked.\n   *\n   * @default false\n   */\n  defaultChecked?: boolean\n  /**\n   * The value of the toggle button.\n   */\n  value?: Y\n  /**\n   * The callback invoked when checked state changes.\n   */\n  onChange?: (checked: boolean) => void\n}\n\nexport const useToggle = <Y extends string = string>(\n  props: UseToggleProps<Y> = {},\n) => {\n  const { t } = useI18n(\"toggle\")\n  const {\n    disabled: groupDisabled,\n    readOnly: groupReadOnly,\n    value: groupValue,\n    onChange: onChangeGroup,\n    onChangeMapRef,\n  } = useToggleGroupContext() ?? {}\n  const {\n    props: {\n      id,\n      ref,\n      form,\n      name,\n      active,\n      checked: checkedProp,\n      defaultChecked = false,\n      disabled,\n      readOnly,\n      required,\n      value,\n      onChange: onChangeProp,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps<HTMLElement, UseToggleProps<Y>>({\n    disabled: groupDisabled,\n    readOnly: groupReadOnly,\n    ...props,\n  })\n  const inputRef = useRef<HTMLInputElement>(null)\n  const [checked, setChecked] = useControllableState({\n    defaultValue: defaultChecked,\n    value: checkedProp,\n    onChange: onChangeProp,\n  })\n  const interactive = !(readOnly || disabled)\n  const controlled = !isUndefined(groupValue)\n  const trulyChecked = useMemo(() => {\n    if (!controlled) {\n      return checked\n    } else {\n      return isArray(groupValue)\n        ? groupValue.includes(value ?? \"\")\n        : value === groupValue\n    }\n  }, [controlled, groupValue, checked, value])\n\n  if (controlled && isUndefined(value))\n    console.warn(`Toggle: value is required. Please set the value.`)\n\n  if (value) onChangeMapRef?.current.set(value, setChecked)\n\n  const onClick = useCallback(() => {\n    if (!interactive) return\n\n    setChecked((prev) => !prev)\n    onChangeGroup?.(value)\n  }, [onChangeGroup, setChecked, value, interactive])\n\n  const onChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      setChecked(ev.target.checked)\n      onChangeGroup?.(value)\n    },\n    [onChangeGroup, setChecked, value],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    (props = {}) => ({\n      ...visuallyHiddenAttributes,\n      ...ariaProps,\n      ...dataProps,\n      ...eventProps,\n      id,\n      form,\n      type: \"checkbox\",\n      name,\n      checked,\n      disabled,\n      readOnly,\n      required,\n      value,\n      ...props,\n      ref: mergeRefs(inputRef, ref, props.ref),\n      onChange: handlerAll(props.onChange, onChange),\n    }),\n    [\n      ariaProps,\n      checked,\n      dataProps,\n      disabled,\n      eventProps,\n      form,\n      id,\n      name,\n      onChange,\n      readOnly,\n      ref,\n      required,\n      value,\n    ],\n  )\n\n  const getButtonProps: PropGetter<\n    \"button\",\n    undefined,\n    Merge<HTMLProps<\"button\">, { \"aria-label\": string }>\n  > = useCallback(\n    (props = {}) => ({\n      ...dataProps,\n      type: \"button\",\n      \"aria-disabled\": ariaAttr(!interactive),\n      \"aria-label\": value?.toString() ?? t(\"Toggle button\"),\n      \"aria-pressed\": trulyChecked,\n      \"data-active\": dataAttr(active),\n      \"data-checked\": dataAttr(trulyChecked),\n      disabled,\n      tabIndex: interactive ? undefined : -1,\n      ...rest,\n      ...props,\n      onClick: handlerAll(rest.onClick, props.onClick, onClick),\n    }),\n    [\n      dataProps,\n      value,\n      trulyChecked,\n      active,\n      disabled,\n      rest,\n      onClick,\n      interactive,\n      t,\n    ],\n  )\n\n  return {\n    checked: trulyChecked,\n    setChecked,\n    getButtonProps,\n    getInputProps,\n  }\n}\n\nexport type UseToggleReturn = ReturnType<typeof useToggle>\n"
    }
  ]
}
