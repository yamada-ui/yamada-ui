{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["select", "field", "input", "group", "icon", "popover"],
    "externals": [],
    "hooks": ["use-combobox", "use-controllable-state"],
    "providers": ["i18n-provider"]
  },
  "section": "components",
  "sources": [
    {
      "name": "autocomplete.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\nimport { selectStyle } from \"../select\"\n\nexport const autocompleteStyle = defineComponentSlotStyle({\n  base: {\n    ...selectStyle.base,\n    empty: selectStyle.base?.option,\n  },\n\n  variants: {\n    filled: selectStyle.variants?.filled,\n    flushed: selectStyle.variants?.flushed,\n    outline: selectStyle.variants?.outline,\n    plain: selectStyle.variants?.plain,\n  },\n\n  sizes: {\n    xs: { ...selectStyle.sizes?.xs, empty: selectStyle.sizes?.xs.option },\n    sm: { ...selectStyle.sizes?.sm, empty: selectStyle.sizes?.sm.option },\n    md: { ...selectStyle.sizes?.md, empty: selectStyle.sizes?.md.option },\n    lg: { ...selectStyle.sizes?.lg, empty: selectStyle.sizes?.lg.option },\n    xl: { ...selectStyle.sizes?.xl, empty: selectStyle.sizes?.xl.option },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"outline\",\n  },\n})\n\nexport type AutocompleteStyle = typeof autocompleteStyle\n"
    },
    {
      "name": "autocomplete.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport type {\n  HTMLProps,\n  HTMLStyledProps,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type {\n  ComboboxItem,\n  UseComboboxGroupProps,\n} from \"../../hooks/use-combobox\"\nimport type { FieldProps } from \"../field\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { AutocompleteStyle } from \"./autocomplete.style\"\nimport type {\n  UseAutocompleteOptionProps,\n  UseAutocompleteProps,\n  UseAutocompleteReturn,\n} from \"./use-autocomplete\"\nimport { useMemo } from \"react\"\nimport { createSlotComponent, styled, cast } from \"@yamada-ui/react\"\nimport {\n  ComboboxContext,\n  ComboboxDescendantsContext,\n  ComboboxGroupContext,\n  createComboboxChildren,\n  createComboboxItem,\n  useComboboxGroup,\n  useComboboxGroupContext,\n} from \"../../hooks/use-combobox\"\nimport { useGroupItemProps } from \"../group\"\nimport { CheckIcon, ChevronDownIcon, MinusIcon, XIcon } from \"../icon\"\nimport { InputGroup, useInputBorder, useInputPropsContext } from \"../input\"\nimport { Popover, usePopoverProps } from \"../popover\"\nimport { autocompleteStyle } from \"./autocomplete.style\"\nimport {\n  AutocompleteContext,\n  useAutocomplete,\n  useAutocompleteOption,\n} from \"./use-autocomplete\"\n\ninterface ComponentContext\n  extends Pick<UseAutocompleteReturn, \"getSeparatorProps\">,\n    Pick<\n      AutocompleteRootProps,\n      \"emptyIcon\" | \"emptyProps\" | \"groupProps\" | \"optionProps\"\n    > {}\n\nexport interface AutocompleteRootProps\n  extends Omit<\n      HTMLStyledProps,\n      \"defaultValue\" | \"filter\" | \"offset\" | \"onChange\" | \"value\"\n    >,\n    UseAutocompleteProps,\n    Omit<\n      WithoutThemeProps<Popover.RootProps, AutocompleteStyle>,\n      | \"autoFocus\"\n      | \"children\"\n      | \"initialFocusRef\"\n      | \"modal\"\n      | \"transform\"\n      | \"updateRef\"\n      | \"withCloseButton\"\n    >,\n    ThemeProps<AutocompleteStyle>,\n    FieldProps,\n    UseInputBorderProps {\n  /**\n   * If `true`, display the clear icon.\n   *\n   * @default true\n   */\n  clearable?: boolean\n  /**\n   * The icon to be used in the clear button.\n   */\n  clearIcon?: ReactNode\n  /**\n   * The icon to be used in the empty element.\n   */\n  emptyIcon?: ReactNode\n  /**\n   * The icon to be used in the autocomplete.\n   */\n  icon?: ReactNode\n  /**\n   * Props for content element.\n   */\n  contentProps?: AutocompleteContentProps\n  /**\n   * The props for the end element.\n   */\n  elementProps?: InputGroup.ElementProps\n  /**\n   * Props for empty element.\n   */\n  emptyProps?: AutocompleteEmptyProps\n  /**\n   * Props for group element.\n   */\n  groupProps?: Omit<AutocompleteGroupProps, \"children\" | \"label\">\n  /**\n   * Props for icon element.\n   */\n  iconProps?: AutocompleteIconProps\n  /**\n   * Props for option element.\n   */\n  optionProps?: Omit<AutocompleteOptionProps, \"children\" | \"value\">\n  /**\n   * Props for root element.\n   */\n  rootProps?: InputGroup.RootProps\n}\n\nconst {\n  ComponentContext,\n  PropsContext: AutocompletePropsContext,\n  useComponentContext,\n  usePropsContext: useAutocompletePropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<\n  AutocompleteRootProps,\n  AutocompleteStyle,\n  ComponentContext\n>(\"autocomplete\", autocompleteStyle)\n\nexport { AutocompletePropsContext, useAutocompletePropsContext }\n\n/**\n * `Autocomplete` is a component used to display suggestions in response to user text input.\n *\n * @see https://yamada-ui.com/components/autocomplete\n */\nexport const AutocompleteRoot = withProvider<\"div\", AutocompleteRootProps>(\n  (props) => {\n    const [groupItemProps, mergedProps] = useGroupItemProps(props)\n    const [\n      popoverProps,\n      {\n        className,\n        css,\n        colorScheme,\n        children,\n        clearable = true,\n        clearIcon = <XIcon />,\n        emptyIcon,\n        errorBorderColor,\n        focusBorderColor,\n        icon,\n        items: itemsProp,\n        contentProps,\n        elementProps,\n        emptyProps,\n        groupProps,\n        iconProps,\n        optionProps,\n        rootProps,\n        ...rest\n      },\n    ] = usePopoverProps(mergedProps, [\n      \"disabled\",\n      \"open\",\n      \"defaultOpen\",\n      \"onOpen\",\n      \"onClose\",\n      \"openOnClick\",\n    ])\n    const items = useMemo<ComboboxItem[]>(() => {\n      if (itemsProp) return itemsProp\n\n      return createComboboxItem(children, {\n        Group: AutocompleteGroup,\n        Label: AutocompleteLabel,\n        Option: AutocompleteOption,\n      })\n    }, [itemsProp, children])\n    const {\n      descendants,\n      interactive,\n      items: computedItems,\n      open,\n      value,\n      getClearIconProps,\n      getContentProps,\n      getFieldProps,\n      getIconProps,\n      getRootProps,\n      getSeparatorProps,\n      onActiveDescendant,\n      onClose,\n      onOpen,\n      onSelect,\n    } = useAutocomplete({ items, ...rest })\n    const mergedPopoverProps = useMemo<Popover.RootProps>(\n      () => ({\n        animationScheme: \"block-start\",\n        autoFocus: false,\n        matchWidth: true,\n        openOnClick: false,\n        ...popoverProps,\n        disabled: !interactive,\n        open,\n        onClose,\n        onOpen,\n      }),\n      [interactive, onClose, onOpen, open, popoverProps],\n    )\n    const computedChildren = useMemo(\n      () =>\n        createComboboxChildren(computedItems, {\n          Empty: AutocompleteEmpty,\n          Group: AutocompleteGroup,\n          Option: AutocompleteOption,\n        }),\n      [computedItems],\n    )\n    const varProps = useInputBorder({ errorBorderColor, focusBorderColor })\n    const comboboxContext = useMemo(\n      () => ({ onActiveDescendant, onClose, onSelect }),\n      [onActiveDescendant, onClose, onSelect],\n    )\n    const autocompleteContext = useMemo(() => ({ value }), [value])\n    const componentContext = useMemo(\n      () => ({\n        emptyIcon,\n        emptyProps,\n        getSeparatorProps,\n        groupProps,\n        optionProps,\n      }),\n      [getSeparatorProps, groupProps, optionProps, emptyProps, emptyIcon],\n    )\n\n    return (\n      <ComboboxDescendantsContext value={descendants}>\n        <ComboboxContext value={comboboxContext}>\n          <AutocompleteContext value={autocompleteContext}>\n            <ComponentContext value={componentContext}>\n              <Popover.Root {...mergedPopoverProps}>\n                <InputGroup.Root\n                  className={className}\n                  css={css}\n                  colorScheme={colorScheme}\n                  {...getRootProps({ ...groupItemProps, ...rootProps })}\n                >\n                  <Popover.Trigger>\n                    <AutocompleteField {...getFieldProps(varProps)} />\n                  </Popover.Trigger>\n\n                  <InputGroup.Element\n                    {...{ clickable: clearable && !!value, ...elementProps }}\n                  >\n                    {clearable && !!value ? (\n                      <AutocompleteIcon\n                        icon={clearIcon}\n                        {...getClearIconProps(iconProps)}\n                      />\n                    ) : (\n                      <AutocompleteIcon\n                        icon={icon}\n                        {...getIconProps(iconProps)}\n                      />\n                    )}\n                  </InputGroup.Element>\n                </InputGroup.Root>\n\n                <AutocompleteContent\n                  {...cast<AutocompleteContentProps>(\n                    getContentProps(cast<HTMLProps>(contentProps)),\n                  )}\n                >\n                  {computedChildren}\n                </AutocompleteContent>\n              </Popover.Root>\n            </ComponentContext>\n          </AutocompleteContext>\n        </ComboboxContext>\n      </ComboboxDescendantsContext>\n    )\n  },\n  \"root\",\n)((props) => {\n  const context = useInputPropsContext()\n\n  return { ...context, ...props }\n})\n\ninterface AutocompleteFieldProps extends HTMLStyledProps<\"input\"> {}\n\nconst AutocompleteField = withContext<\"input\", AutocompleteFieldProps>(\n  \"input\",\n  \"field\",\n)({ \"data-group-propagate\": \"\" })\n\ninterface AutocompleteIconProps extends HTMLStyledProps {\n  icon?: ReactNode\n}\n\nconst AutocompleteIcon = withContext<\"div\", AutocompleteIconProps>(\n  \"div\",\n  \"icon\",\n)(undefined, ({ children, icon, ...rest }) => ({\n  children: icon || children || <ChevronDownIcon />,\n  ...rest,\n}))\n\ninterface AutocompleteContentProps extends Popover.ContentProps {}\n\nconst AutocompleteContent = withContext<\"div\", AutocompleteContentProps>(\n  Popover.Content,\n  \"content\",\n)()\n\nexport interface AutocompleteLabelProps extends HTMLStyledProps<\"span\"> {}\n\nexport const AutocompleteLabel = withContext<\"span\", AutocompleteLabelProps>(\n  \"span\",\n  \"label\",\n)(undefined, (props) => {\n  const { getLabelProps } = useComboboxGroupContext()\n\n  return getLabelProps(props)\n})\n\nexport interface AutocompleteGroupProps\n  extends UseComboboxGroupProps,\n    HTMLStyledProps {\n  /**\n   * The label of the group.\n   */\n  label?: ReactNode\n  /**\n   * Props for the label component.\n   */\n  labelProps?: AutocompleteLabelProps\n}\n\nexport const AutocompleteGroup = withContext<\"div\", AutocompleteGroupProps>(\n  ({ children, label, labelProps, ...rest }) => {\n    const { groupProps } = useComponentContext()\n    const { getGroupProps, getLabelProps } = useComboboxGroup({\n      ...groupProps,\n      ...rest,\n    })\n    const context = useMemo(() => ({ getLabelProps }), [getLabelProps])\n\n    return (\n      <ComboboxGroupContext value={context}>\n        <styled.div {...getGroupProps()}>\n          {label ? (\n            <AutocompleteLabel {...labelProps}>{label}</AutocompleteLabel>\n          ) : null}\n          {children}\n        </styled.div>\n      </ComboboxGroupContext>\n    )\n  },\n  \"group\",\n)()\n\nexport interface AutocompleteOptionProps\n  extends UseAutocompleteOptionProps,\n    HTMLStyledProps {\n  /**\n   * The icon to be used in the autocomplete option.\n   */\n  icon?: ReactNode\n}\n\nexport const AutocompleteOption = withContext<\"div\", AutocompleteOptionProps>(\n  ({ children, icon: iconProp, ...rest }) => {\n    const { optionProps: { icon, ...optionProps } = {} } = useComponentContext()\n    const { getIndicatorProps, getOptionProps } = useAutocompleteOption({\n      ...optionProps,\n      ...rest,\n    })\n\n    return (\n      <styled.div {...getOptionProps()}>\n        <AutocompleteIndicator {...getIndicatorProps()}>\n          {iconProp ?? icon ?? <CheckIcon />}\n        </AutocompleteIndicator>\n        {children}\n      </styled.div>\n    )\n  },\n  \"option\",\n)()\n\ninterface AutocompleteEmptyProps extends HTMLStyledProps {\n  /**\n   * The icon to be used in the autocomplete option.\n   */\n  icon?: ReactNode\n}\n\nconst AutocompleteEmpty = withContext<\"div\", AutocompleteEmptyProps>(\n  ({ children, icon, ...rest }) => {\n    const { emptyIcon, emptyProps } = useComponentContext()\n\n    return (\n      <styled.div {...emptyProps} {...rest}>\n        <AutocompleteIndicator>\n          {icon ?? emptyIcon ?? <MinusIcon />}\n        </AutocompleteIndicator>\n        {children}\n      </styled.div>\n    )\n  },\n  \"empty\",\n)()\n\ninterface AutocompleteIndicatorProps extends HTMLStyledProps {}\n\nconst AutocompleteIndicator = withContext<\"div\", AutocompleteIndicatorProps>(\n  \"div\",\n  \"indicator\",\n)()\n"
    },
    {
      "name": "index.ts",
      "content": "export {\n  AutocompleteGroup,\n  AutocompleteLabel,\n  AutocompleteOption,\n  AutocompletePropsContext,\n  AutocompleteRoot,\n  useAutocompletePropsContext,\n} from \"./autocomplete\"\nexport type {\n  AutocompleteGroupProps,\n  AutocompleteLabelProps,\n  AutocompleteOptionProps,\n  AutocompleteRootProps,\n} from \"./autocomplete\"\nexport * as Autocomplete from \"./namespace\"\nexport * from \"./use-autocomplete\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export type {\n  ComboboxItem as Item,\n  ComboboxItemWithItems as ItemWithItems,\n  ComboboxItemWithValue as ItemWithValue,\n} from \"../../hooks/use-combobox\"\nexport {\n  AutocompleteGroup as Group,\n  AutocompleteLabel as Label,\n  AutocompleteOption as Option,\n  AutocompletePropsContext as PropsContext,\n  AutocompleteRoot as Root,\n  useAutocompletePropsContext as usePropsContext,\n} from \"./autocomplete\"\nexport type {\n  AutocompleteGroupProps as GroupProps,\n  AutocompleteLabelProps as LabelProps,\n  AutocompleteOptionProps as OptionProps,\n  AutocompleteRootProps as RootProps,\n} from \"./autocomplete\"\n"
    },
    {
      "name": "use-autocomplete.tsx",
      "content": "\"use client\"\n\nimport type { ChangeEvent, KeyboardEvent, MouseEvent, ReactNode } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type {\n  ComboboxItem,\n  ComboboxItemWithValue,\n  UseComboboxItemProps,\n  UseComboboxProps,\n} from \"../../hooks/use-combobox\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useMemo, useRef } from \"react\"\nimport { useCombobox, useComboboxItem } from \"../../hooks/use-combobox\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport {\n  cast,\n  createContext,\n  handlerAll,\n  isArray,\n  isString,\n  isUndefined,\n  mergeRefs,\n  runIfFn,\n  runKeyAction,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\nconst getInputValue = (item?: ComboboxItemWithValue) =>\n  isString(item?.label) ? item.label : (item?.query ?? \"\")\n\nexport interface AutocompleteFilter {\n  (\n    inputValue: string,\n    items: ComboboxItem[],\n    matcher: AutocompleteMatcher,\n  ): ComboboxItem[]\n}\n\nconst defaultFilter: AutocompleteFilter = (inputValue, items, matcher) => {\n  if (!inputValue.length) return items\n\n  return items\n    .map((item) => {\n      if (\"items\" in item) {\n        const items = item.items.filter((item) => {\n          if (\"query\" in item) {\n            return matcher(inputValue, item.query)\n          } else if (isString(item.label)) {\n            return matcher(inputValue, item.label)\n          }\n        })\n\n        if (items.length) return { ...item, items }\n      } else if (\"query\" in item) {\n        if (matcher(inputValue, item.query)) return item\n      } else if (isString(item.label)) {\n        if (matcher(inputValue, item.label)) return item\n      }\n    })\n    .filter(Boolean) as ComboboxItem[]\n}\n\nexport interface AutocompleteMatcher {\n  (input: string, target?: string): boolean\n}\n\nconst defaultMatcher: AutocompleteMatcher = (input, target) =>\n  target?.toLowerCase().includes(input.toLowerCase()) ?? false\n\ninterface AutocompleteContext extends Pick<UseAutocompleteReturn, \"value\"> {}\n\nconst [AutocompleteContext, useAutocompleteContext] =\n  createContext<AutocompleteContext>({\n    name: \"AutocompleteContext\",\n  })\n\nexport { AutocompleteContext, useAutocompleteContext }\n\nexport interface UseAutocompleteProps\n  extends Omit<HTMLProps, \"defaultValue\" | \"onChange\" | \"value\">,\n    Omit<\n      UseComboboxProps,\n      \"defaultValue\" | \"initialFocusValue\" | \"onChange\" | \"value\"\n    >,\n    FieldProps {\n  /**\n   * If `true`, the autocomplete will allow custom value.\n   *\n   * @default false\n   */\n  allowCustomValue?: boolean\n  /**\n   * If `true`, the autocomplete will be closed when the input value changes.\n   *\n   * @default false\n   */\n  closeOnChange?: ((ev: ChangeEvent<HTMLInputElement>) => boolean) | boolean\n  /**\n   * The initial value of the input.\n   */\n  defaultInputValue?: string\n  /**\n   * The initial value of the autocomplete.\n   */\n  defaultValue?: string\n  /**\n   * The message displayed when the search yields no hits.\n   *\n   * @default 'No results found'\n   */\n  emptyMessage?: ReactNode\n  /**\n   * The function to filter the items.\n   */\n  filter?: AutocompleteFilter\n  /**\n   * If `true`, the input will be focused when the clear icon is clicked.\n   *\n   * @default true\n   */\n  focusOnClear?: boolean\n  /**\n   * The value of the input.\n   */\n  inputValue?: string\n  /**\n   * If provided, generate options based on items.\n   *\n   * @default '[]'\n   */\n  items?: ComboboxItem[]\n  /**\n   * The function to match the items.\n   */\n  matcher?: AutocompleteMatcher\n  /**\n   * If `true`, the autocomplete will be opened when the input value changes.\n   *\n   * @default true\n   */\n  openOnChange?: ((ev: ChangeEvent<HTMLInputElement>) => boolean) | boolean\n  /**\n   * If `true`, the autocomplete will be opened when the input is focused.\n   *\n   * @default false\n   */\n  openOnFocus?: boolean\n  /**\n   * The placeholder for autocomplete.\n   */\n  placeholder?: string\n  /**\n   * The value of the autocomplete.\n   */\n  value?: string\n  /**\n   * The callback invoked when value state changes.\n   */\n  onChange?: (value: string) => void\n  /**\n   * The callback invoked when input value state changes.\n   */\n  onInputChange?: (value: string) => void\n}\n\nexport const useAutocomplete = (props: UseAutocompleteProps = {}) => {\n  const { t } = useI18n(\"autocomplete\")\n  const {\n    props: {\n      allowCustomValue = false,\n      closeOnChange = false,\n      closeOnSelect = true,\n      defaultInputValue,\n      defaultValue,\n      disabled,\n      emptyMessage = t(\"No results found\"),\n      filter = defaultFilter,\n      focusOnClear = true,\n      inputValue: inputValueProp,\n      items = [],\n      matcher = defaultMatcher,\n      openOnChange = true,\n      openOnFocus = false,\n      placeholder,\n      readOnly,\n      value: valueProp,\n      onChange: onChangeProp,\n      onInputChange: onInputChangeProp,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const inputRef = useRef<HTMLInputElement>(null)\n  const valueMap = useMemo<{ [key: string]: ComboboxItemWithValue }>(() => {\n    const valueMap: { [key: string]: ComboboxItemWithValue } = {}\n\n    items.forEach((item) => {\n      if (\"items\" in item) {\n        item.items.forEach((item) => {\n          item.value ??= isString(item.label) ? item.label : undefined\n\n          if (!isUndefined(item.value)) valueMap[item.value] = item\n        })\n      } else {\n        item.value ??= isString(item.label) ? item.label : undefined\n\n        if (!isUndefined(item.value)) valueMap[item.value] = item\n      }\n    })\n\n    return valueMap\n  }, [items])\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const [inputValue, setInputValue] = useControllableState({\n    defaultValue: defaultInputValue ?? getInputValue(valueMap[value]),\n    value: inputValueProp,\n    onChange: onInputChangeProp,\n  })\n  const onChange = useCallback(\n    (value: string) => {\n      setValue(value)\n\n      const item = valueMap[value]\n\n      setInputValue(getInputValue(item))\n    },\n    [setInputValue, setValue, valueMap],\n  )\n  const {\n    activeDescendant,\n    descendants,\n    interactive,\n    open,\n    getContentProps: getComboboxContentProps,\n    getSeparatorProps,\n    getTriggerProps,\n    onActiveDescendant,\n    onClose,\n    onOpen,\n    onSelect,\n  } = useCombobox({\n    closeOnSelect,\n    disabled,\n    initialFocusValue: isArray(value) ? value[0] : value,\n    readOnly,\n    onChange,\n    ...ariaProps,\n    ...dataProps,\n    ...eventProps,\n    ...rest,\n  })\n  const filteredItems = useMemo<ComboboxItem[]>(() => {\n    if (!items.length) return []\n\n    const filteredItems = filter(inputValue, items, matcher)\n\n    return filteredItems.length\n      ? filteredItems\n      : [{ \"data-empty\": \"\", label: emptyMessage }]\n  }, [emptyMessage, filter, inputValue, items, matcher])\n  const empty = useMemo(\n    () => !filteredItems.filter(({ hidden }) => !hidden).length,\n    [filteredItems],\n  )\n\n  const onInputChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      if (runIfFn(closeOnChange, ev)) {\n        onClose()\n      } else if (runIfFn(openOnChange, ev)) {\n        onOpen()\n      }\n\n      activeDescendant.current = null\n\n      const value = ev.target.value\n\n      setInputValue(value)\n\n      if (!value.length) setValue(\"\")\n    },\n    [\n      activeDescendant,\n      closeOnChange,\n      onClose,\n      onOpen,\n      openOnChange,\n      setInputValue,\n      setValue,\n    ],\n  )\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLInputElement>) => {\n      if (!open || disabled || ev.nativeEvent.isComposing) return\n\n      if (!inputValue.length) return\n      if (activeDescendant.current) return\n\n      const item = filteredItems[0]\n\n      if (!item) return\n\n      runKeyAction(ev, {\n        Enter: () => {\n          if (\"items\" in item) {\n            onSelect(item.items[0]?.value)\n          } else {\n            onSelect(item.value)\n          }\n        },\n      })\n    },\n    [activeDescendant, disabled, filteredItems, inputValue, onSelect, open],\n  )\n\n  const onClick = useCallback(() => {\n    if (openOnFocus) inputRef.current?.focus()\n  }, [openOnFocus])\n\n  const onMouseDown = useCallback(\n    (ev: MouseEvent<HTMLInputElement>) => {\n      if (!openOnFocus) return\n\n      ev.preventDefault()\n      ev.stopPropagation()\n    },\n    [openOnFocus],\n  )\n\n  const onFocus = useCallback(() => {\n    if (openOnFocus) onOpen()\n  }, [openOnFocus, onOpen])\n\n  const onBlur = useCallback(() => {\n    if (allowCustomValue) {\n      if (inputValue) setValue(inputValue)\n    } else {\n      const item = valueMap[value]\n\n      setInputValue(getInputValue(item))\n    }\n  }, [allowCustomValue, inputValue, setInputValue, setValue, value, valueMap])\n\n  const onClear = useCallback(() => {\n    setValue(\"\")\n    setInputValue(\"\")\n\n    if (focusOnClear) inputRef.current?.focus()\n  }, [focusOnClear, setInputValue, setValue])\n\n  const getRootProps: PropGetter = useCallback(\n    (props) => ({ ...dataProps, ...props }),\n    [dataProps],\n  )\n\n  const getFieldProps: PropGetter<\"input\"> = useCallback(\n    ({ ref, ...props } = {}) =>\n      cast<HTMLProps<\"input\">>(\n        getTriggerProps({\n          ref: mergeRefs(ref, inputRef),\n          autoCapitalize: \"off\",\n          autoComplete: \"off\",\n          autoCorrect: \"off\",\n          placeholder,\n          spellCheck: false,\n          value: inputValue,\n          ...props,\n          onBlur: handlerAll(props.onBlur, onBlur),\n          onChange: handlerAll(props.onChange, onInputChange),\n          onClick: handlerAll(props.onClick, onClick),\n          onFocus: handlerAll(props.onFocus, onFocus),\n          onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n          onMouseDown: handlerAll(props.onMouseDown, onMouseDown),\n        }),\n      ),\n    [\n      getTriggerProps,\n      inputValue,\n      onBlur,\n      onClick,\n      onFocus,\n      onInputChange,\n      onKeyDown,\n      onMouseDown,\n      placeholder,\n    ],\n  )\n\n  const getContentProps: PropGetter = useCallback(\n    (props) => getComboboxContentProps({ hidden: empty, ...props }),\n    [empty, getComboboxContentProps],\n  )\n\n  const getIconProps: PropGetter = useCallback(\n    (props) => ({ ...dataProps, ...props }),\n    [dataProps],\n  )\n\n  const getClearIconProps: PropGetter = useCallback(\n    (props = {}) =>\n      getIconProps({\n        \"aria-label\": t(\"Clear value\"),\n        role: \"button\",\n        tabIndex: 0,\n        ...props,\n        onClick: handlerAll(props.onClick, onClear),\n        onKeyDown: handlerAll(props.onKeyDown, (ev) =>\n          runKeyAction(ev, {\n            Enter: onClear,\n            Space: onClear,\n          }),\n        ),\n      }),\n    [getIconProps, onClear, t],\n  )\n\n  useUpdateEffect(() => {\n    const item = valueMap[value]\n\n    setInputValue(getInputValue(item))\n  }, [valueProp])\n\n  return {\n    descendants,\n    inputValue,\n    interactive,\n    items: filteredItems,\n    open,\n    setInputValue,\n    setValue,\n    value,\n    valueMap,\n    getClearIconProps,\n    getContentProps,\n    getFieldProps,\n    getIconProps,\n    getRootProps,\n    getSeparatorProps,\n    onActiveDescendant,\n    onChange,\n    onClose,\n    onInputChange,\n    onOpen,\n    onSelect,\n  }\n}\n\nexport type UseAutocompleteReturn = ReturnType<typeof useAutocomplete>\n\nexport interface UseAutocompleteOptionProps extends UseComboboxItemProps {}\n\nexport const useAutocompleteOption = ({\n  children,\n  closeOnSelect,\n  disabled,\n  hidden,\n  value,\n  ...rest\n}: UseAutocompleteOptionProps = {}) => {\n  const { value: selectedValue } = useAutocompleteContext()\n\n  value ??= isString(children) ? children : undefined\n\n  const selected = selectedValue === value\n  const { getIndicatorProps, getItemProps } = useComboboxItem({\n    children,\n    closeOnSelect,\n    disabled: disabled || hidden,\n    hidden,\n    selected,\n    value,\n    ...rest,\n  })\n\n  const getOptionProps: PropGetter = useCallback(\n    (props = {}) => getItemProps(props),\n    [getItemProps],\n  )\n\n  return { getIndicatorProps, getOptionProps }\n}\n\nexport type UseAutocompleteOptionReturn = ReturnType<\n  typeof useAutocompleteOption\n>\n"
    }
  ]
}
