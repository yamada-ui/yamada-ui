{
  "dependencies": {
    "components": ["field"],
    "externals": [],
    "hooks": ["use-value", "use-controllable-state", "use-pan-event"],
    "providers": ["i18n-provider"]
  },
  "dependents": { "components": ["hue-slider"], "hooks": [], "providers": [] },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./slider.style\"\nexport * as Slider from \"./namespace\"\nexport {\n  SliderMark,\n  SliderMarks,\n  SliderPropsContext,\n  SliderRange,\n  SliderRoot,\n  SliderThumb,\n  SliderThumbs,\n  SliderTrack,\n  useSliderPropsContext,\n} from \"./slider\"\nexport type {\n  SliderMarkProps,\n  SliderMarksProps,\n  SliderRangeProps,\n  SliderRootProps,\n  SliderThumbProps,\n  SliderThumbsProps,\n  SliderTrackProps,\n} from \"./slider\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  SliderMark as Mark,\n  SliderMarks as Marks,\n  SliderPropsContext as PropsContext,\n  SliderRange as Range,\n  SliderRoot as Root,\n  SliderThumb as Thumb,\n  SliderThumbs as Thumbs,\n  SliderTrack as Track,\n  useSliderPropsContext as usePropsContext,\n} from \"./slider\"\nexport type {\n  SliderMarkProps as MarkProps,\n  SliderMarksProps as MarksProps,\n  SliderRangeProps as RangeProps,\n  SliderRootProps as RootProps,\n  SliderThumbProps as ThumbProps,\n  SliderThumbsProps as ThumbsProps,\n  SliderTrackProps as TrackProps,\n} from \"./slider\"\n"
    },
    {
      "name": "slider.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const sliderStyle = defineComponentSlotStyle({\n  base: {\n    mark: {\n      \"&[data-indicator]\": {\n        _before: {\n          bg: \"{indicator-fill}\",\n          boxSize: \"{track-size}\",\n          position: \"absolute\",\n          rounded: \"{indicator-rounded}\",\n        },\n        _between: {\n          \"--indicator-fill\": \"colorScheme.contrast\",\n        },\n      },\n      color: \"fg.muted\",\n      fontSize: \"xs\",\n      pointerEvents: \"none\",\n      position: \"absolute\",\n      textAlign: \"center\",\n      whiteSpace: \"nowrap\",\n      zIndex: 1,\n    },\n    range: {\n      bg: \"{range-fill}\",\n      position: \"absolute\",\n      rounded: \"{track-rounded}\",\n    },\n    root: {\n      \"--indicator-rounded\": \"radii.full\",\n      \"--track-rounded\": \"radii.full\",\n      alignItems: \"center\",\n      display: \"inline-flex\",\n      isolation: \"isolate\",\n      position: \"relative\",\n      touchAction: \"none\",\n      _readOnly: { layerStyle: \"readOnly\" },\n      _disabled: { layerStyle: \"disabled\" },\n    },\n    thumb: {\n      alignItems: \"center\",\n      bg: \"{thumb-fill}\",\n      borderColor: \"{thumb-stroke}\",\n      borderWidth: \"2px\",\n      boxSize: \"{thumb-size}\",\n      color: \"{thumb-stroke}\",\n      display: \"flex\",\n      justifyContent: \"center\",\n      position: \"absolute\",\n      rounded: \"{thumb-rounded}\",\n      zIndex: 2,\n    },\n    track: {\n      bg: \"{track-fill}\",\n      cursor: {\n        base: \"pointer\",\n        _readOnly: \"default\",\n        _disabled: \"not-allowed\",\n      },\n      flex: \"1\",\n      position: \"relative\",\n      rounded: \"{track-rounded}\",\n    },\n  },\n\n  props: {\n    /**\n     * The orientation of the slider.\n     *\n     * @default 'horizontal'\n     */\n    orientation: {\n      horizontal: {\n        mark: {\n          left: \"{mark-position}\",\n          pt: \"calc({track-size} + {spaces.2})\",\n          top: \"0\",\n          translate: \"-50% 0\",\n          _before: {\n            left: \"50%\",\n            top: \"0\",\n            translate: \"-50% 0\",\n          },\n        },\n        range: {\n          h: \"full\",\n          left: \"{range-start}\",\n          top: \"50%\",\n          translate: \"0 -50%\",\n          w: \"calc({range-end} - {range-start} + ({track-size} / 2))\",\n          _range: {\n            left: \"calc({range-start} - ({track-size} / 2))\",\n            w: \"calc({range-end} - {range-start} + {track-size})\",\n          },\n        },\n        root: {\n          flexDirection: \"row\",\n          minW: \"{thumb-size}\",\n          w: \"full\",\n        },\n        thumb: {\n          top: \"50%\",\n          translate: \"-50% -50%\",\n          _end: { left: \"{range-end}\" },\n          _start: { left: \"{range-start}\" },\n        },\n        track: {\n          h: \"{track-size}\",\n        },\n      },\n      vertical: {\n        mark: {\n          bottom: \"{mark-position}\",\n          left: \"0\",\n          lineHeight: \"2\",\n          ps: \"calc({track-size} + {spaces.3})\",\n          translate: \"0 50%\",\n          _before: {\n            left: \"0\",\n            top: \"50%\",\n            translate: \"0 -50%\",\n          },\n        },\n        range: {\n          bottom: \"{range-start}\",\n          h: \"calc({range-end} - {range-start} + ({track-size} / 2))\",\n          left: \"50%\",\n          translate: \"-50% 0\",\n          w: \"full\",\n          _range: {\n            bottom: \"calc({range-start} - ({track-size} / 2))\",\n            h: \"calc({range-end} - {range-start} + {track-size})\",\n          },\n        },\n        root: {\n          flexDirection: \"column\",\n          h: \"full\",\n          minH: \"{thumb-size}\",\n        },\n        thumb: {\n          left: \"50%\",\n          translate: \"-50% 50%\",\n          _end: { bottom: \"{range-end}\" },\n          _start: { bottom: \"{range-start}\" },\n        },\n        track: {\n          w: \"{track-size}\",\n        },\n      },\n    },\n    /**\n     * The shape of the thumb.\n     *\n     * @default 'circle'\n     */\n    shape: {\n      circle: {\n        root: { \"--thumb-rounded\": \"radii.full\" },\n      },\n      rounded: {\n        root: { \"--thumb-rounded\": \"radii.l2\" },\n      },\n      square: {\n        root: { \"--thumb-rounded\": \"0\" },\n      },\n    },\n  },\n\n  variants: {\n    outline: {\n      root: {\n        \"--indicator-fill\": \"colorScheme.solid\",\n        \"--range-fill\": \"colorScheme.solid\",\n        \"--thumb-fill\": \"colors.bg\",\n        \"--thumb-stroke\": \"colorScheme.solid\",\n        \"--track-fill\": \"colors.bg.muted\",\n      },\n    },\n    solid: {\n      root: {\n        \"--indicator-fill\": \"colorScheme.solid\",\n        \"--range-fill\": \"colorScheme.solid\",\n        \"--thumb-fill\": \"colorScheme.solid\",\n        \"--thumb-stroke\": \"colorScheme.solid\",\n        \"--track-fill\": \"colors.bg.muted\",\n      },\n    },\n  },\n\n  sizes: {\n    sm: {\n      root: {\n        \"--thumb-size\": \"sizes.4\",\n        \"--track-size\": \"sizes.1.5\",\n      },\n    },\n    md: {\n      root: {\n        \"--thumb-size\": \"sizes.5\",\n        \"--track-size\": \"sizes.2\",\n      },\n    },\n    lg: {\n      root: {\n        \"--thumb-size\": \"sizes.6\",\n        \"--track-size\": \"sizes.2.5\",\n      },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"outline\",\n    orientation: \"horizontal\",\n    shape: \"circle\",\n  },\n})\n\nexport type SliderStyle = typeof sliderStyle\n"
    },
    {
      "name": "slider.tsx",
      "content": "\"use client\"\n\nimport type { FC, ReactElement, ReactNode } from \"react\"\nimport type {\n  CSSProps,\n  GenericsComponent,\n  HTMLStyledProps,\n  ThemeProps,\n} from \"@yamada-ui/react\"\nimport type { SliderStyle } from \"./slider.style\"\nimport type { UseSliderProps, UseSliderReturn } from \"./use-slider\"\nimport { useMemo } from \"react\"\nimport {\n  createSlotComponent,\n  styled,\n  varAttr,\n  dataAttr,\n  isNumber,\n} from \"@yamada-ui/react\"\nimport { useValue } from \"../../hooks/use-value\"\nimport { sliderStyle } from \"./slider.style\"\nimport { useSlider } from \"./use-slider\"\n\ninterface ComponentContext\n  extends Pick<\n    UseSliderReturn,\n    | \"getInputProps\"\n    | \"getMarkProps\"\n    | \"getRangeProps\"\n    | \"getThumbProps\"\n    | \"getTrackProps\"\n    | \"range\"\n  > {}\n\nexport interface SliderRootProps<Y extends [number, number] | number = number>\n  extends Omit<HTMLStyledProps, \"defaultValue\" | \"onChange\" | \"ref\">,\n    Omit<UseSliderProps<Y>, \"orientation\">,\n    ThemeProps<SliderStyle> {\n  /**\n   * The fill color of the indicator.\n   */\n  indicatorFill?: CSSProps[\"color\"]\n  /**\n   * The rounded of the indicator.\n   */\n  indicatorRounded?: CSSProps[\"rounded\"]\n  /**\n   * The marks to display on the slider.\n   */\n  marks?: SliderMarksProps[\"marks\"]\n  /**\n   * The fill color of the range.\n   */\n  rangeFill?: CSSProps[\"color\"]\n  /**\n   * The fill color of the thumb.\n   */\n  thumbFill?: CSSProps[\"color\"]\n  /**\n   * The rounded of the thumb.\n   */\n  thumbRounded?: CSSProps[\"rounded\"]\n  /**\n   * The size of the thumb.\n   */\n  thumbSize?: CSSProps[\"boxSize\"]\n  /**\n   * The stroke color of the thumb.\n   */\n  thumbStroke?: CSSProps[\"color\"]\n  /**\n   * The fill color of the track.\n   */\n  trackFill?: CSSProps[\"color\"]\n  /**\n   * The rounded of the track.\n   */\n  trackRounded?: CSSProps[\"rounded\"]\n  /**\n   * The size of the track.\n   */\n  trackSize?: CSSProps[\"boxSize\"]\n  /**\n   * Props for the input element.\n   */\n  inputProps?: SliderInputProps\n  /**\n   * Props for the marks element.\n   */\n  marksProps?: Partial<SliderMarksProps>\n  /**\n   * Props for the range element.\n   */\n  rangeProps?: SliderRangeProps\n  /**\n   * Props for the thumb element.\n   */\n  thumbProps?: SliderThumbProps\n  /**\n   * Props for the track element.\n   */\n  trackProps?: SliderTrackProps\n}\n\nconst {\n  ComponentContext,\n  PropsContext: SliderPropsContext,\n  useComponentContext,\n  usePropsContext: useSliderPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<SliderRootProps, SliderStyle, ComponentContext>(\n  \"slider\",\n  sliderStyle,\n)\n\nexport { SliderPropsContext, useSliderPropsContext }\n\n/**\n * `Slider` is a component used for allowing users to select a value from a range.\n *\n * @see https://yamada-ui.com/components/slider\n */\nexport const SliderRoot = withProvider<\"div\", SliderRootProps, \"orientation\">(\n  <Y extends [number, number] | number = number>({\n    children,\n    marks,\n    orientation: orientationProp,\n    inputProps,\n    marksProps,\n    rangeProps,\n    thumbProps,\n    trackProps,\n    ...rest\n  }: SliderRootProps<Y>) => {\n    const orientation = useValue(orientationProp)\n    const {\n      range,\n      getInputProps,\n      getMarkProps,\n      getRangeProps,\n      getRootProps,\n      getThumbProps,\n      getTrackProps,\n    } = useSlider<Y>({ orientation, ...rest })\n    const computedChildren = useMemo(() => {\n      if (children) return children\n\n      return (\n        <>\n          <SliderTrack {...trackProps}>\n            <SliderRange {...rangeProps} />\n\n            {range ? (\n              <SliderThumbs {...thumbProps} />\n            ) : (\n              <SliderThumb {...thumbProps} />\n            )}\n          </SliderTrack>\n\n          {marks ? <SliderMarks marks={marks} {...marksProps} /> : null}\n        </>\n      )\n    }, [children, marks, marksProps, range, rangeProps, thumbProps, trackProps])\n    const context = useMemo(\n      () => ({\n        range,\n        getInputProps,\n        getMarkProps,\n        getRangeProps,\n        getThumbProps,\n        getTrackProps,\n      }),\n      [\n        range,\n        getInputProps,\n        getMarkProps,\n        getRangeProps,\n        getThumbProps,\n        getTrackProps,\n      ],\n    )\n\n    return (\n      <ComponentContext value={context}>\n        <styled.div {...getRootProps()}>\n          <SliderInput {...inputProps} />\n\n          {computedChildren}\n        </styled.div>\n      </ComponentContext>\n    )\n  },\n  \"root\",\n  { transferProps: [\"orientation\"] },\n)(\n  undefined,\n  ({\n    indicatorFill,\n    indicatorRounded,\n    rangeFill,\n    thumbFill,\n    thumbRounded,\n    thumbSize,\n    thumbStroke,\n    trackFill,\n    trackRounded,\n    trackSize,\n    ...rest\n  }) => ({\n    \"--indicator-fill\": varAttr(indicatorFill, \"colors\"),\n    \"--indicator-rounded\": varAttr(indicatorRounded, \"radii\"),\n    \"--range-fill\": varAttr(rangeFill, \"colors\"),\n    \"--thumb-fill\": varAttr(thumbFill, \"colors\"),\n    \"--thumb-rounded\": varAttr(thumbRounded, \"radii\"),\n    \"--thumb-size\": varAttr(thumbSize, \"sizes\"),\n    \"--thumb-stroke\": varAttr(thumbStroke, \"colors\"),\n    \"--track-fill\": varAttr(trackFill, \"colors\"),\n    \"--track-rounded\": varAttr(trackRounded, \"radii\"),\n    \"--track-size\": varAttr(trackSize, \"sizes\"),\n    ...rest,\n  }),\n) as GenericsComponent<{\n  <Y extends [number, number] | number = number>(\n    props: SliderRootProps<Y>,\n  ): ReactElement\n}>\n\ninterface SliderInputProps extends HTMLStyledProps<\"input\"> {}\n\nconst SliderInput: FC<SliderInputProps> = () => {\n  const { range, getInputProps } = useComponentContext()\n\n  return range ? (\n    Array.from({ length: 2 }).map((_, index) => (\n      <styled.input key={index} {...getInputProps({ index })} />\n    ))\n  ) : (\n    <styled.input {...getInputProps()} />\n  )\n}\n\nexport interface SliderTrackProps extends HTMLStyledProps {}\n\nexport const SliderTrack = withContext<\"div\", SliderTrackProps>(\"div\", \"track\")(\n  undefined,\n  (props) => {\n    const { getTrackProps } = useComponentContext()\n\n    return getTrackProps(props)\n  },\n)\n\nexport interface SliderRangeProps extends HTMLStyledProps {}\n\nexport const SliderRange = withContext<\"div\", SliderRangeProps>(\"div\", \"range\")(\n  undefined,\n  (props) => {\n    const { getRangeProps } = useComponentContext()\n\n    return getRangeProps(props)\n  },\n)\n\nexport interface SliderMarkProps extends HTMLStyledProps {\n  /**\n   * The value of the mark.\n   */\n  value: number\n  /**\n   * Whether the mark is an indicator.\n   *\n   * @default true\n   */\n  indicator?: boolean\n}\n\nexport const SliderMark = withContext<\"div\", SliderMarkProps>(\"div\", \"mark\")(\n  undefined,\n  ({ indicator = true, ...props }) => {\n    const { getMarkProps } = useComponentContext()\n\n    return getMarkProps({ \"data-indicator\": dataAttr(indicator), ...props })\n  },\n)\n\nexport interface SliderMarksProps extends Omit<SliderMarkProps, \"value\"> {\n  /**\n   * The marks to display on the slider.\n   */\n  marks: (number | { label: ReactNode; value: number; indicator?: boolean })[]\n}\n\nexport const SliderMarks: FC<SliderMarksProps> = ({ marks, ...props }) => {\n  return (\n    <>\n      {marks.map((mark, index) => {\n        if (isNumber(mark)) {\n          return <SliderMark key={index} value={mark} {...props} />\n        } else {\n          const { indicator, label, value } = mark\n\n          return (\n            <SliderMark key={index} indicator={indicator} value={value}>\n              {label}\n            </SliderMark>\n          )\n        }\n      })}\n    </>\n  )\n}\n\nexport interface SliderThumbProps extends HTMLStyledProps {\n  /**\n   * The index of the thumb.\n   */\n  index?: number\n}\n\nexport const SliderThumb = withContext<\"div\", SliderThumbProps>(\"div\", \"thumb\")(\n  undefined,\n  (props) => {\n    const { getThumbProps } = useComponentContext()\n\n    return getThumbProps(props)\n  },\n)\n\nexport interface SliderThumbsProps extends SliderThumbProps {}\n\nexport const SliderThumbs: FC<SliderThumbsProps> = (props) => {\n  return (\n    <>\n      {Array.from({ length: 2 }).map((_, index) => (\n        <SliderThumb key={index} index={index} {...props} />\n      ))}\n    </>\n  )\n}\n"
    },
    {
      "name": "use-slider.ts",
      "content": "\"use client\"\n\nimport type { KeyboardEvent } from \"react\"\nimport type {\n  HTMLProps,\n  HTMLRefAttributes,\n  Orientation,\n  PropGetter,\n  RequiredPropGetter,\n  Point,\n} from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useRef } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { usePanEvent } from \"../../hooks/use-pan-event\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport {\n  clampNumber,\n  cx,\n  dataAttr,\n  handlerAll,\n  isArray,\n  isNumber,\n  mergeRefs,\n  percentToValue,\n  roundNumberToStep,\n  runKeyAction,\n  valueToPercent,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\nexport interface UseSliderProps<Y extends [number, number] | number = number>\n  extends Omit<HTMLProps, \"defaultValue\" | \"onChange\" | \"ref\">,\n    HTMLRefAttributes<\"input\">,\n    FieldProps {\n  /**\n   * The base `id` to use for the slider.\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms.\n   */\n  name?: string\n  /**\n   * The minimum distance between slider thumbs.\n   * Useful for preventing the thumbs from being too close together.\n   *\n   * @default 0\n   */\n  betweenThumbs?: number\n  /**\n   * The initial value of the slider.\n   */\n  defaultValue?: Y\n  /**\n   * This is used to format the value so that screen readers\n   * can speak out a more human-friendly value.\n   *\n   * It is used to set the `aria-valuetext` property of the input.\n   */\n  getAriaValueText?: (value: number, index: number) => string | undefined\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   *\n   * @default 100\n   */\n  max?: number\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   *\n   * @default 0\n   */\n  min?: number\n  /**\n   * The orientation of the slider.\n   *\n   * @default 'horizontal'\n   */\n  orientation?: Orientation\n  /**\n   * The step in which increments or decrements have to be made.\n   *\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider.\n   */\n  value?: Y\n  /**\n   * Function called whenever the slider value changes.\n   */\n  onChange?: (value: Y) => void\n  /**\n   * Function called when the user is done selecting a new value.\n   */\n  onChangeEnd?: (value: Y) => void\n  /**\n   * Function called when the user starts selecting a new value.\n   */\n  onChangeStart?: (value: Y) => void\n}\n\nexport const useSlider = <Y extends [number, number] | number = number>(\n  props: UseSliderProps<Y> = {},\n) => {\n  const {\n    props: {\n      id,\n      ref,\n      name,\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-valuetext\": ariaValueText,\n      betweenThumbs = 0,\n      defaultValue = 0 as Y,\n      disabled,\n      getAriaValueText,\n      max = 100,\n      min = 0,\n      orientation = \"horizontal\",\n      readOnly,\n      required,\n      step = 1,\n      value: valueProp,\n      onChange: onChangeProp,\n      onChangeEnd,\n      onChangeStart,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const { t } = useI18n(\"slider\")\n  const currentIndex = useRef(0)\n  const interactive = !(disabled || readOnly)\n  const [_, getPanEventProps] = usePanEvent<HTMLDivElement>({\n    onEnd: (_, point, rect) => {\n      if (!interactive) return\n\n      const panValue = getPanValue(point, rect)\n\n      if (range) {\n        const start = currentIndex.current === 0\n        const oppositeIndex = currentIndex.current === 0 ? 1 : 0\n        const oppositeValue = value[oppositeIndex]!\n\n        onChangeEnd?.(\n          (start ? [panValue, oppositeValue] : [oppositeValue, panValue]) as Y,\n        )\n      } else {\n        onChangeEnd?.(panValue as Y)\n      }\n    },\n    onMove: (_, point, rect) => {\n      if (!interactive) return\n\n      const panValue = getPanValue(point, rect)\n\n      onChange(currentIndex.current, panValue)\n    },\n    onStart: (_, point, rect) => {\n      if (!interactive) return\n\n      const panValue = getPanValue(point, rect)\n\n      if (range) {\n        const distances = value.map((value) => Math.abs(value - panValue))\n        const closest = Math.min(...distances)\n        const index = distances.indexOf(closest)\n\n        currentIndex.current = index\n\n        const start = index === 0\n        const oppositeIndex = index === 0 ? 1 : 0\n        const oppositeValue = value[oppositeIndex]!\n\n        onChangeStart?.(\n          (start ? [panValue, oppositeValue] : [oppositeValue, panValue]) as Y,\n        )\n      } else {\n        currentIndex.current = 0\n\n        onChangeStart?.(value as Y)\n      }\n\n      onChange(currentIndex.current, panValue)\n    },\n  })\n  const range = !isNumber(value)\n  const percent = (\n    range\n      ? value.map((value) => valueToPercent(value, min, max))\n      : valueToPercent(value, min, max)\n  ) as Y extends number ? number : number[]\n  const tenStep = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  if (max < min) console.warn(\"Do not assign a number less than 'min' to 'max'\")\n\n  const getMinMax = useCallback(\n    (index: number) => {\n      const start = index === 0\n      const oppositeIndex = index === 0 ? 1 : 0\n      const oppositeValue = range ? value[oppositeIndex]! : value\n\n      return {\n        max: range ? (start ? oppositeValue - betweenThumbs : max) : max,\n        min: range ? (start ? min : oppositeValue + betweenThumbs) : min,\n      }\n    },\n    [betweenThumbs, max, min, range, value],\n  )\n\n  const getPanValue = useCallback(\n    ({ x, y }: Point, { bottom, height, left, width }: DOMRect) => {\n      const diff = orientation === \"horizontal\" ? x - left : bottom - y\n      const length = orientation === \"horizontal\" ? width : height\n      const percent = diff / length\n\n      let nextValue = percentToValue(percent, min, max)\n\n      nextValue = parseFloat(roundNumberToStep(nextValue, min, step))\n      nextValue = clampNumber(nextValue, min, max)\n\n      return nextValue\n    },\n    [orientation, min, max, step],\n  )\n\n  const onChange = useCallback(\n    (index: number, value: number) => {\n      if (!interactive) return\n\n      const { max, min } = getMinMax(index)\n\n      value = parseFloat(roundNumberToStep(value, min, oneStep))\n      value = clampNumber(value, min, max)\n\n      setValue((prev) => {\n        if (isArray(prev)) {\n          const next = [...prev]\n\n          next[index] = value\n\n          return next as Y\n        } else {\n          return value as Y\n        }\n      })\n    },\n    [getMinMax, interactive, oneStep, setValue],\n  )\n\n  const stepUp = useCallback(\n    (index: number, step = oneStep) =>\n      range\n        ? onChange(index, value[index]! + step)\n        : onChange(index, value + step),\n    [oneStep, range, onChange, value],\n  )\n\n  const stepDown = useCallback(\n    (index: number, step = oneStep) =>\n      range\n        ? onChange(index, value[index]! - step)\n        : onChange(index, value - step),\n    [oneStep, range, onChange, value],\n  )\n\n  const onKeyDown = useCallback(\n    (index: number) => (ev: KeyboardEvent<HTMLDivElement>) => {\n      const { max, min } = getMinMax(index)\n\n      runKeyAction(ev, {\n        ArrowDown: () => stepDown(index),\n        ArrowLeft: () => stepDown(index),\n        ArrowRight: () => stepUp(index),\n        ArrowUp: () => stepUp(index),\n        End: () => onChange(index, max),\n        Home: () => onChange(index, min),\n        PageDown: () => stepDown(index, tenStep),\n        PageUp: () => stepUp(index, tenStep),\n      })\n    },\n    [getMinMax, onChange, stepDown, stepUp, tenStep],\n  )\n\n  const getRootProps: PropGetter = useCallback(\n    (props) => {\n      const computedProps: HTMLProps = {\n        ...dataProps,\n        \"data-orientation\": orientation,\n        ...eventProps,\n        ...rest,\n        ...props,\n      }\n\n      computedProps.style ??= {}\n\n      if (isArray(percent)) {\n        computedProps.style[\"--range-start\"] = `${Math.abs(percent[0]!)}%`\n        computedProps.style[\"--range-end\"] = `${Math.abs(percent[1]!)}%`\n      } else {\n        computedProps.style[\"--range-start\"] = \"0%\"\n        computedProps.style[\"--range-end\"] = `${Math.abs(percent)}%`\n      }\n\n      return computedProps\n    },\n    [dataProps, eventProps, orientation, percent, rest],\n  )\n\n  const getInputProps: PropGetter<\"input\", { index?: number }> = useCallback(\n    ({ index = 0, ...props } = {}) => ({\n      ...visuallyHiddenAttributes,\n      ...dataProps,\n      ...ariaProps,\n      id,\n      type: \"hidden\",\n      name,\n      disabled,\n      readOnly,\n      required,\n      value: range ? value[index]! : value,\n      ...props,\n      ref: index === 0 ? mergeRefs(props.ref, ref) : props.ref,\n    }),\n    [\n      dataProps,\n      ariaProps,\n      id,\n      name,\n      disabled,\n      readOnly,\n      required,\n      range,\n      value,\n      ref,\n    ],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props) =>\n      getPanEventProps({\n        ...dataProps,\n        \"data-orientation\": orientation,\n        ...props,\n      }),\n    [dataProps, getPanEventProps, orientation],\n  )\n\n  const getRangeProps: PropGetter = useCallback(\n    (props) => ({\n      ...dataProps,\n      \"data-orientation\": orientation,\n      \"data-range\": dataAttr(range),\n      ...props,\n    }),\n    [dataProps, orientation, range],\n  )\n\n  const getMarkProps: RequiredPropGetter<\"div\", { value: number }> =\n    useCallback(\n      ({ style, value: valueProp, ...props }) => {\n        const between = range\n          ? value[0]! < valueProp && valueProp < value[1]!\n          : valueProp < value\n        const percent = valueToPercent(valueProp, min, max)\n\n        return {\n          ...dataProps,\n          \"aria-hidden\": true,\n          \"data-between\": dataAttr(between),\n          \"data-orientation\": orientation,\n          role: \"presentation\",\n          ...props,\n          style: { ...style, \"--mark-position\": `${percent}%` },\n        }\n      },\n      [dataProps, max, min, orientation, range, value],\n    )\n\n  const getThumbProps: PropGetter<\"div\", { index?: number }> = useCallback(\n    ({ index = 0, ...rest } = {}) => {\n      const { max, min } = getMinMax(index)\n\n      const props: HTMLProps = {\n        ...dataProps,\n        ...ariaProps,\n        \"aria-label\": t(\"Slider thumb\"),\n        \"aria-orientation\": orientation,\n        \"aria-valuemax\": max,\n        \"aria-valuemin\": min,\n        role: \"slider\",\n        tabIndex: interactive ? 0 : -1,\n        ...rest,\n        \"aria-labelledby\": cx(rest[\"aria-labelledby\"], ariaLabelledBy),\n        onKeyDown: handlerAll(rest.onKeyDown, onKeyDown(index)),\n      }\n\n      if (range) {\n        const currentValue = value[index]!\n\n        props[\"data-start\"] = dataAttr(index === 0)\n        props[\"data-end\"] = dataAttr(index === 1)\n        props[\"aria-valuenow\"] = currentValue\n        props[\"aria-valuetext\"] =\n          ariaValueText ??\n          getAriaValueText?.(currentValue, index) ??\n          currentValue.toString()\n      } else {\n        props[\"data-end\"] = dataAttr(index === 0)\n        props[\"aria-valuenow\"] = value\n        props[\"aria-valuetext\"] =\n          ariaValueText ?? getAriaValueText?.(value, index) ?? value.toString()\n      }\n\n      return props\n    },\n    [\n      t,\n      ariaLabelledBy,\n      ariaProps,\n      ariaValueText,\n      dataProps,\n      getAriaValueText,\n      getMinMax,\n      interactive,\n      onKeyDown,\n      orientation,\n      range,\n      value,\n    ],\n  )\n\n  return {\n    percent,\n    range,\n    setValue,\n    stepDown,\n    stepUp,\n    value,\n    getInputProps,\n    getMarkProps,\n    getRangeProps,\n    getRootProps,\n    getThumbProps,\n    getTrackProps,\n    onChange,\n  }\n}\n\nexport type UseSliderReturn = ReturnType<typeof useSlider>\n"
    }
  ]
}
