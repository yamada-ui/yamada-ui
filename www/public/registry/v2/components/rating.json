{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["icon", "field"],
    "externals": [],
    "hooks": ["use-controllable-state"],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./rating.style\"\nexport { Rating } from \"./rating\"\nexport type { RatingProps } from \"./rating\"\nexport * from \"./use-rating\"\n"
    },
    {
      "name": "rating.style.ts",
      "content": "import { defineComponentSlotStyle, focusRingStyle } from \"@yamada-ui/react\"\n\nexport const ratingStyle = defineComponentSlotStyle({\n  base: {\n    group: { position: \"relative\" },\n    icon: {\n      alignItems: \"center\",\n      clipPath: \"{clip-path}\",\n      display: \"inline-flex\",\n      fill: \"currentColor\",\n      justifyContent: \"center\",\n    },\n    item: {\n      \"&:has(input:focus-visible)\": { ...focusRingStyle.outside },\n      color: { base: \"{empty-color}\", _filled: \"{filled-color}\" },\n      cursor: \"pointer\",\n      display: \"block\",\n      lineHeight: \"0\",\n      rounded: \"l1\",\n      _notLast: { inset: 0, position: \"absolute\" },\n      _readOnly: { layerStyle: \"readOnly\" },\n      _disabled: { layerStyle: \"disabled\" },\n    },\n    root: {\n      \"--empty-color\": \"colors.bg.muted\",\n      \"--filled-color\": \"colorScheme.solid\",\n      display: \"flex\",\n      w: \"max-content\",\n    },\n  },\n\n  sizes: {\n    xs: { icon: { fontSize: \"md\" } },\n    sm: { icon: { fontSize: \"lg\" } },\n    md: { icon: { fontSize: \"xl\" } },\n    lg: { icon: { fontSize: \"2xl\" } },\n    xl: { icon: { fontSize: \"3xl\" } },\n  },\n\n  defaultProps: {\n    size: \"md\",\n  },\n})\n\nexport type RatingStyle = typeof ratingStyle\n"
    },
    {
      "name": "rating.tsx",
      "content": "\"use client\"\n\nimport type {\n  CSSProps,\n  HTMLStyledProps,\n  ThemeProps,\n  FunctionOrValue,\n  Merge,\n  ReactNodeOrFunction,\n} from \"@yamada-ui/react\"\nimport type { RatingStyle } from \"./rating.style\"\nimport type { UseRatingItemProps, UseRatingProps } from \"./use-rating\"\nimport { useMemo } from \"react\"\nimport { createSlotComponent, styled, varAttr, runIfFn } from \"@yamada-ui/react\"\nimport { StarIcon } from \"../icon\"\nimport { ratingStyle } from \"./rating.style\"\nimport {\n  RatingContext,\n  useRating,\n  useRatingContext,\n  useRatingItem,\n} from \"./use-rating\"\n\ninterface ComponentContext\n  extends Pick<\n    RatingProps,\n    | \"color\"\n    | \"emptyIcon\"\n    | \"filledIcon\"\n    | \"groupProps\"\n    | \"iconProps\"\n    | \"inputProps\"\n    | \"itemProps\"\n  > {}\n\nexport interface RatingProps\n  extends Merge<Omit<HTMLStyledProps, \"children\" | \"color\">, UseRatingProps>,\n    ThemeProps<RatingStyle> {\n  /**\n   * The color of the filled icons.\n   */\n  color?: FunctionOrValue<number, CSSProps[\"color\"]>\n  /**\n   * The empty icon for the rating.\n   */\n  emptyIcon?: ReactNodeOrFunction<number>\n  /**\n   * The filled icon for the rating.\n   */\n  filledIcon?: ReactNodeOrFunction<number>\n  /**\n   * Props for the rating group.\n   */\n  groupProps?: FunctionOrValue<number, RatingGroupProps>\n  /**\n   * Props for the rating item.\n   */\n  iconProps?: FunctionOrValue<number, RatingIconProps>\n  /**\n   * Props for the input element.\n   */\n  inputProps?: FunctionOrValue<number, HTMLStyledProps<\"input\">>\n  /**\n   * Props for the rating item.\n   */\n  itemProps?: FunctionOrValue<number, RatingItemProps>\n}\n\nconst {\n  ComponentContext,\n  PropsContext: RatingPropsContext,\n  useComponentContext,\n  usePropsContext: useRatingPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<RatingProps, RatingStyle, ComponentContext>(\n  \"rating\",\n  ratingStyle,\n)\n\nexport { RatingPropsContext, useRatingPropsContext }\n\n/**\n * `Rating` is a component used to allow users to provide ratings.\n *\n * @see https://yamada-ui.com/components/rating\n */\nexport const Rating = withProvider<\"div\", RatingProps>(\n  ({\n    color,\n    emptyIcon,\n    filledIcon,\n    groupProps,\n    iconProps,\n    inputProps,\n    itemProps,\n    ...rest\n  }) => {\n    const {\n      id,\n      name,\n      count,\n      decimal,\n      disabled,\n      displayValue,\n      fractions,\n      highlightSelectedOnly,\n      hoveredValue,\n      interactive,\n      outsideRef,\n      readOnly,\n      required,\n      roundedValue,\n      setHoveredValue,\n      setValue,\n      value,\n      ariaProps,\n      dataProps,\n      eventProps,\n      getRootProps,\n    } = useRating(rest)\n    const ratingContext = useMemo(\n      () => ({\n        id,\n        name,\n        count,\n        decimal,\n        disabled,\n        displayValue,\n        fractions,\n        highlightSelectedOnly,\n        hoveredValue,\n        interactive,\n        outsideRef,\n        readOnly,\n        required,\n        roundedValue,\n        setHoveredValue,\n        setValue,\n        value,\n        ariaProps,\n        dataProps,\n        eventProps,\n      }),\n      [\n        id,\n        name,\n        count,\n        decimal,\n        disabled,\n        fractions,\n        highlightSelectedOnly,\n        hoveredValue,\n        interactive,\n        displayValue,\n        outsideRef,\n        readOnly,\n        required,\n        roundedValue,\n        setHoveredValue,\n        setValue,\n        value,\n        ariaProps,\n        dataProps,\n        eventProps,\n      ],\n    )\n    const componentContext = useMemo(\n      () => ({\n        color,\n        emptyIcon,\n        filledIcon,\n        groupProps,\n        iconProps,\n        inputProps,\n        itemProps,\n      }),\n      [\n        color,\n        emptyIcon,\n        filledIcon,\n        groupProps,\n        iconProps,\n        inputProps,\n        itemProps,\n      ],\n    )\n\n    return (\n      <RatingContext value={ratingContext}>\n        <ComponentContext value={componentContext}>\n          <styled.div {...getRootProps()}>\n            {Array.from({ length: count }).map((_, index) => (\n              <RatingGroup key={index} value={index + 1} />\n            ))}\n          </styled.div>\n        </ComponentContext>\n      </RatingContext>\n    )\n  },\n  \"root\",\n)()\n\ninterface RatingGroupProps extends HTMLStyledProps {\n  value: number\n}\n\nconst RatingGroup = withContext<\"div\", RatingGroupProps>(\n  ({ value, ...rest }) => {\n    const { fractions } = useRatingContext()\n    const { groupProps } = useComponentContext()\n    const count = useMemo(\n      () => (value === 1 ? fractions + 1 : fractions),\n      [value, fractions],\n    )\n\n    return (\n      <styled.div {...runIfFn(groupProps, value)} {...rest}>\n        {Array.from({ length: count }).map((_, index) => (\n          <RatingItem key={index} groupValue={value} index={index} />\n        ))}\n      </styled.div>\n    )\n  },\n  \"group\",\n)()\n\ninterface RatingItemProps\n  extends HTMLStyledProps<\"label\">,\n    UseRatingItemProps {}\n\nconst RatingItem = withContext<\"label\", RatingItemProps>((props) => {\n  const {\n    active,\n    filled,\n    fractionValue,\n    groupValue,\n    getInputProps,\n    getLabelProps,\n  } = useRatingItem(props)\n  const {\n    emptyIcon = <StarIcon fill=\"currentColor\" strokeColor=\"currentColor\" />,\n    filledIcon = <StarIcon fill=\"currentColor\" strokeColor=\"currentColor\" />,\n    iconProps,\n    inputProps,\n    itemProps,\n  } = useComponentContext()\n  const clipPath =\n    fractionValue !== 1\n      ? `inset(0 ${active ? 100 - fractionValue * 100 : 100}% 0 0)`\n      : undefined\n\n  return (\n    <styled.label {...getLabelProps(runIfFn(itemProps, groupValue))}>\n      <styled.input {...getInputProps(runIfFn(inputProps, groupValue))} />\n\n      <RatingIcon\n        {...{ \"--clip-path\": clipPath }}\n        {...runIfFn(iconProps, groupValue)}\n      >\n        {filled\n          ? runIfFn(filledIcon, groupValue)\n          : runIfFn(emptyIcon, groupValue)}\n      </RatingIcon>\n    </styled.label>\n  )\n}, \"item\")(undefined, ({ groupValue, ...rest }) => {\n  const { color } = useComponentContext()\n\n  return {\n    \"--filled-color\": varAttr(runIfFn(color, groupValue), \"colors\"),\n    groupValue,\n    ...rest,\n  }\n})\n\ninterface RatingIconProps extends HTMLStyledProps {}\n\nconst RatingIcon = withContext<\"div\", RatingIconProps>(\"div\", \"icon\")()\n"
    },
    {
      "name": "use-rating.tsx",
      "content": "\"use client\"\n\nimport type { ChangeEvent, KeyboardEvent, MouseEvent, TouchEvent } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useId, useMemo, useRef, useState } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport {\n  ariaAttr,\n  clampNumber,\n  createContext,\n  dataAttr,\n  handlerAll,\n  mergeRefs,\n  runKeyAction,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\nconst getRoundedValue = (value: number, to: number) => {\n  const rounded = Math.round(value / to) * to\n  const precision = `${to}`.split(\".\")[1]?.length || 0\n\n  return Number(rounded.toFixed(precision))\n}\n\nexport interface RatingContext extends Omit<UseRatingReturn, \"getRootProps\"> {}\n\nconst [RatingContext, useRatingContext] = createContext<RatingContext>({\n  name: \"RatingContext\",\n})\n\nexport { RatingContext, useRatingContext }\n\nexport interface UseRatingProps\n  extends FieldProps,\n    Omit<HTMLProps, \"color\" | \"defaultValue\" | \"onChange\"> {\n  /**\n   * The top-level id string that will be applied to the rating.\n   * The index of the rating item will be appended to this top-level id.\n   */\n  id?: string\n  /**\n   * The name of the input element.\n   */\n  name?: string\n  /**\n   * Number of controls that should be rendered.\n   *\n   * @default 5\n   */\n  count?: number\n  /**\n   * The initial value of the rating.\n   *\n   * @default 0\n   */\n  defaultValue?: number\n  /**\n   * Number of fractions each item can be divided into,\n   *\n   * @default 1\n   */\n  fractions?: number\n  /**\n   * If `true`, only the selected icons will be filled.\n   *\n   * @default false\n   */\n  highlightSelectedOnly?: boolean\n  /**\n   * The value of the rating.\n   */\n  value?: number\n  /**\n   * The callback invoked when value state changes.\n   */\n  onChange?: (value: number) => void\n  /**\n   * The callback invoked when hovering over the rating.\n   */\n  onHover?: (value: number) => void\n}\n\nexport const useRating = (props: UseRatingProps = {}) => {\n  const uuid = useId()\n  const {\n    props: {\n      id = uuid,\n      name = uuid,\n      count: countProp = 5,\n      defaultValue = 0,\n      disabled,\n      fractions: fractionsProp = 1,\n      highlightSelectedOnly = false,\n      readOnly,\n      required,\n      value: valueProp,\n      onChange: onChangeProp,\n      onHover,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps({ ...props, notSupportReadOnly: true })\n  const rootRef = useRef<HTMLDivElement>(null)\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const [hoveredValue, setHoveredValue] = useState(-1)\n  const outsideRef = useRef(true)\n  const fractions = Math.floor(fractionsProp)\n  const count = Math.floor(countProp)\n  const decimal = 1 / fractions\n  const roundedValue = useMemo(\n    () => getRoundedValue(value, decimal),\n    [decimal, value],\n  )\n  const interactive = !(readOnly || disabled)\n  const displayValue = hoveredValue !== -1 ? hoveredValue : roundedValue\n\n  const getHoveredValue = useCallback(\n    (x: number) => {\n      if (!rootRef.current) return -1\n\n      const { left, width } = rootRef.current.getBoundingClientRect()\n      const itemWidth = width / count\n\n      const hoveredValue = (x - left) / itemWidth\n\n      const value = clampNumber(\n        getRoundedValue(hoveredValue + decimal / 2, decimal),\n        decimal,\n        count,\n      )\n\n      return value\n    },\n    [count, decimal],\n  )\n\n  const onMouseEnter = useCallback(() => {\n    if (interactive) outsideRef.current = false\n  }, [interactive])\n\n  const onMouseLeave = useCallback(() => {\n    if (!interactive) return\n\n    setHoveredValue(-1)\n    outsideRef.current = true\n\n    if (hoveredValue !== -1) onHover?.(-1)\n  }, [hoveredValue, onHover, interactive, setHoveredValue])\n\n  const onMouseMove = useCallback(\n    (ev: MouseEvent<HTMLDivElement>) => {\n      if (disabled || readOnly) return\n\n      const roundedValue = getHoveredValue(ev.clientX)\n\n      setHoveredValue(roundedValue)\n\n      if (roundedValue !== hoveredValue) onHover?.(roundedValue)\n    },\n    [disabled, getHoveredValue, hoveredValue, readOnly, onHover],\n  )\n\n  const onTouchStart = useCallback(\n    (ev: TouchEvent<HTMLDivElement>) => {\n      ev.preventDefault()\n\n      const el = ev.touches[0]\n\n      if (!el) return\n\n      const value = getHoveredValue(el.clientX)\n\n      setValue(value)\n    },\n    [getHoveredValue, setValue],\n  )\n\n  const onTouchEnd = useCallback((ev: TouchEvent<HTMLDivElement>) => {\n    ev.preventDefault()\n  }, [])\n\n  const getRootProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...dataProps,\n      ...eventProps,\n      ...ariaProps,\n      id,\n      \"aria-label\": `${value} Stars`,\n      \"aria-readonly\": ariaAttr(readOnly),\n      role: \"radiogroup\",\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref, rootRef),\n      onMouseEnter: handlerAll(\n        props.onMouseEnter,\n        rest.onMouseEnter,\n        onMouseEnter,\n      ),\n      onMouseLeave: handlerAll(\n        props.onMouseLeave,\n        rest.onMouseLeave,\n        onMouseLeave,\n      ),\n      onMouseMove: handlerAll(props.onMouseMove, rest.onMouseMove, onMouseMove),\n      onTouchEnd: handlerAll(props.onTouchEnd, rest.onTouchEnd, onTouchEnd),\n      onTouchStart: handlerAll(\n        props.onTouchStart,\n        rest.onTouchStart,\n        onTouchStart,\n      ),\n    }),\n    [\n      ariaProps,\n      dataProps,\n      eventProps,\n      id,\n      onMouseEnter,\n      onMouseLeave,\n      onMouseMove,\n      onTouchEnd,\n      onTouchStart,\n      readOnly,\n      rest,\n      value,\n    ],\n  )\n\n  return {\n    id,\n    name,\n    count,\n    decimal,\n    disabled,\n    displayValue,\n    fractions,\n    highlightSelectedOnly,\n    hoveredValue,\n    interactive,\n    outsideRef,\n    readOnly,\n    required,\n    roundedValue,\n    setHoveredValue,\n    setValue,\n    value,\n    ariaProps,\n    dataProps,\n    eventProps,\n    getRootProps,\n  }\n}\n\nexport type UseRatingReturn = ReturnType<typeof useRating>\n\nexport interface UseRatingItemProps extends HTMLProps<\"label\"> {\n  groupValue: number\n  index: number\n}\n\nexport const useRatingItem = ({\n  groupValue,\n  index,\n  ...rest\n}: UseRatingItemProps) => {\n  const {\n    id: rootId,\n    name,\n    decimal,\n    disabled,\n    displayValue,\n    highlightSelectedOnly,\n    interactive,\n    outsideRef,\n    readOnly,\n    required,\n    roundedValue,\n    setHoveredValue,\n    setValue,\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useRatingContext()\n  const fractionValue = decimal * (groupValue === 1 ? index : index + 1)\n  const value = useMemo(\n    () => getRoundedValue(groupValue - 1 + fractionValue, decimal),\n    [decimal, fractionValue, groupValue],\n  )\n  const active = value === displayValue\n  const checked = value === roundedValue\n  const filled = highlightSelectedOnly\n    ? value === displayValue\n    : value <= displayValue\n  const id = `${rootId}-${groupValue}-${value}`\n\n  const onBlur = useCallback(() => {\n    if (outsideRef.current) setHoveredValue(-1)\n  }, [outsideRef, setHoveredValue])\n\n  const onInputChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      if (!interactive) return\n\n      const value = parseFloat(ev.target.value)\n\n      setHoveredValue(value)\n    },\n    [interactive, setHoveredValue],\n  )\n\n  const onChange = useCallback(\n    (value: number) => {\n      if (!interactive) return\n\n      setValue(value)\n    },\n    [interactive, setValue],\n  )\n\n  const onMouseDown = useCallback(() => {\n    onChange(value)\n  }, [onChange, value])\n\n  const onTouchStart = useCallback(() => {\n    onChange(value)\n  }, [onChange, value])\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLInputElement>) => {\n      runKeyAction(ev, {\n        Space: () => onChange(value),\n      })\n    },\n    [onChange, value],\n  )\n\n  const getLabelProps: PropGetter<\"label\"> = useCallback(\n    ({ style, ...props } = {}) => ({\n      ...dataProps,\n      ...ariaProps,\n      htmlFor: id,\n      \"data-active\": dataAttr(active),\n      \"data-filled\": dataAttr(filled),\n      ...rest,\n      ...props,\n      style: {\n        ...style,\n        zIndex: fractionValue !== 1 ? (active ? 1 : -1) : undefined,\n      },\n      onMouseDown: handlerAll(props.onMouseDown, onMouseDown),\n      onTouchStart: handlerAll(props.onTouchStart, onTouchStart),\n    }),\n    [\n      active,\n      ariaProps,\n      dataProps,\n      filled,\n      fractionValue,\n      id,\n      onMouseDown,\n      onTouchStart,\n      rest,\n    ],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    (props = {}) => ({\n      ...dataProps,\n      ...eventProps,\n      ...ariaProps,\n      id,\n      type: \"radio\",\n      name,\n      style: visuallyHiddenAttributes.style,\n      \"aria-label\": value.toString(),\n      \"data-active\": dataAttr(active),\n      \"data-checked\": dataAttr(checked),\n      checked,\n      disabled,\n      readOnly,\n      required,\n      value,\n      ...props,\n      onBlur: handlerAll(onBlur, props.onBlur),\n      onChange: handlerAll(props.onChange, onInputChange),\n      onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n    }),\n    [\n      id,\n      name,\n      value,\n      active,\n      checked,\n      dataProps,\n      eventProps,\n      ariaProps,\n      disabled,\n      readOnly,\n      required,\n      onBlur,\n      onInputChange,\n      onKeyDown,\n    ],\n  )\n\n  return {\n    active,\n    checked,\n    filled,\n    fractionValue,\n    groupValue,\n    value,\n    getInputProps,\n    getLabelProps,\n  }\n}\n\nexport type UseRatingItemReturn = ReturnType<typeof useRatingItem>\n"
    }
  ]
}
