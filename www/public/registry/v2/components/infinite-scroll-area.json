{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": ["use-value"],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./infinite-scroll-area.style\"\nexport {\n  InfiniteScrollArea,\n  InfiniteScrollAreaPropsContext,\n  useInfiniteScrollAreaPropsContext,\n} from \"./infinite-scroll-area\"\nexport type { InfiniteScrollAreaProps } from \"./infinite-scroll-area\"\nexport * from \"./use-infinite-scroll\"\n"
    },
    {
      "name": "infinite-scroll-area.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const infiniteScrollAreaStyle = defineComponentSlotStyle({\n  base: {\n    root: {\n      display: \"flex\",\n      flexDirection: \"row\",\n      w: \"full\",\n    },\n    trigger: {\n      alignItems: \"center\",\n      display: \"flex\",\n      flex: 1,\n      justifyContent: \"center\",\n      w: \"full\",\n    },\n  },\n\n  props: {\n    /**\n     * If `true`, the button is full rounded. Else, it'll be slightly round.\n     *\n     * @default 'vertical'\n     */\n    orientation: {\n      horizontal: {\n        root: { flexDirection: \"row\", gap: \"md\" },\n      },\n      vertical: {\n        root: { flexDirection: \"column\", gap: \"lg\" },\n      },\n    },\n  },\n\n  defaultProps: {\n    orientation: \"vertical\",\n  },\n})\n\nexport type InfiniteScrollAreaStyle = typeof infiniteScrollAreaStyle\n"
    },
    {
      "name": "infinite-scroll-area.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport type {\n  HTMLStyledProps,\n  Orientation,\n  StyleValue,\n  ThemeProps,\n} from \"@yamada-ui/react\"\nimport type { InfiniteScrollAreaStyle } from \"./infinite-scroll-area.style\"\nimport type { UseInfiniteScrollProps } from \"./use-infinite-scroll\"\nimport { useRef } from \"react\"\nimport { createSlotComponent, styled, mergeRefs } from \"@yamada-ui/react\"\nimport { useValue } from \"../../hooks/use-value\"\nimport { infiniteScrollAreaStyle } from \"./infinite-scroll-area.style\"\nimport { useInfiniteScroll } from \"./use-infinite-scroll\"\n\nexport interface InfiniteScrollAreaProps\n  extends Omit<HTMLStyledProps, keyof UseInfiniteScrollProps>,\n    Omit<UseInfiniteScrollProps, \"orientation\">,\n    ThemeProps<InfiniteScrollAreaStyle> {\n  /**\n   * The infinite scroll area finish to use.\n   */\n  finish?: ReactNode\n  /**\n   * The infinite scroll area loading to use.\n   */\n  loading?: ReactNode\n  /**\n   * The orientation of the infinite scroll.\n   *\n   * @default 'vertical'\n   */\n  orientation?: StyleValue<Orientation>\n  /**\n   * Props for infinite scroll area trigger component.\n   */\n  triggerProps?: HTMLStyledProps\n}\n\nconst {\n  PropsContext: InfiniteScrollAreaPropsContext,\n  usePropsContext: useInfiniteScrollAreaPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<InfiniteScrollAreaProps, InfiniteScrollAreaStyle>(\n  \"infinite-scroll-area\",\n  infiniteScrollAreaStyle,\n)\n\nexport { InfiniteScrollAreaPropsContext, useInfiniteScrollAreaPropsContext }\n\n/**\n * `InfiniteScrollArea` is for providing infinite scroll functionality.\n * This feature provides a smooth scrolling experience by automatically loading and displaying the next dataset when the user reaches the end of the page.\n *\n * @see https://yamada-ui.com/components/infinite-scroll-area\n */\nexport const InfiniteScrollArea = withProvider<\n  \"div\",\n  InfiniteScrollAreaProps,\n  \"orientation\"\n>(\n  ({\n    ref,\n    children,\n    disabled,\n    finish: finishProp,\n    indexRef,\n    initialLoad,\n    loading,\n    orientation: orientationProp,\n    resetRef,\n    reverse,\n    rootMargin,\n    rootRef: rootRefProp,\n    startIndex,\n    threshold,\n    triggerProps,\n    onLoad,\n    ...rest\n  }) => {\n    const rootRef = useRef<HTMLDivElement>(null)\n    const orientation = useValue(orientationProp)\n    const { ref: triggerRef, finish } = useInfiniteScroll({\n      disabled,\n      indexRef,\n      initialLoad,\n      orientation,\n      resetRef,\n      reverse,\n      rootMargin,\n      rootRef: rootRefProp ?? rootRef,\n      startIndex,\n      threshold,\n      onLoad,\n    })\n    const hasFinish = !!finishProp\n    const showTrigger = !disabled && (hasFinish || !finish)\n\n    return (\n      <styled.div\n        ref={mergeRefs(rootRef, ref)}\n        aria-busy=\"false\"\n        role=\"feed\"\n        {...rest}\n      >\n        {reverse && showTrigger ? (\n          <InfiniteScrollTrigger ref={triggerRef} {...triggerProps}>\n            {finish ? finishProp : loading}\n          </InfiniteScrollTrigger>\n        ) : null}\n\n        {children}\n\n        {!reverse && showTrigger ? (\n          <InfiniteScrollTrigger ref={triggerRef} {...triggerProps}>\n            {finish ? finishProp : loading}\n          </InfiniteScrollTrigger>\n        ) : null}\n      </styled.div>\n    )\n  },\n  \"root\",\n  { transferProps: [\"orientation\"] },\n)()\n\ninterface InfiniteScrollTriggerProps extends HTMLStyledProps {}\n\nconst InfiniteScrollTrigger = withContext<\"div\", InfiniteScrollTriggerProps>(\n  \"div\",\n  \"trigger\",\n)()\n"
    },
    {
      "name": "use-infinite-scroll.ts",
      "content": "\"use client\"\n\nimport type { RefObject } from \"react\"\nimport type { Orientation } from \"@yamada-ui/react\"\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\nimport {\n  assignRef,\n  isHTMLElement,\n  useCallbackRef,\n  useUnmountEffect,\n} from \"@yamada-ui/react\"\n\nconst isScrollable = (el: HTMLElement, vertical: boolean) => {\n  const style = getComputedStyle(el)\n\n  if ([\"auto\", \"overlay\", \"scroll\"].includes(style.overflow)) return true\n\n  if (vertical) {\n    return [\"auto\", \"overlay\", \"scroll\"].includes(style.overflowY)\n  } else {\n    return [\"auto\", \"overlay\", \"scroll\"].includes(style.overflowX)\n  }\n}\n\nconst onScroll = ({\n  behavior,\n  position,\n  reverse,\n  root,\n  vertical,\n}: {\n  root: HTMLElement | null | undefined\n  vertical: boolean\n  behavior?: ScrollBehavior\n  position?: number\n  reverse?: boolean\n}) => {\n  let options: ScrollToOptions\n  const el =\n    isHTMLElement(root) && isScrollable(root, vertical) ? root : document.body\n\n  if (vertical) {\n    options = { behavior, top: position ?? (reverse ? el.scrollHeight : 0) }\n  } else {\n    options = { behavior, left: position ?? (reverse ? el.scrollWidth : 0) }\n  }\n\n  if (el === document.body) {\n    window.scrollTo(options)\n  } else {\n    el.scrollTo(options)\n  }\n}\n\nconst getScrollPosition = (\n  root: HTMLElement | null | undefined,\n  vertical: boolean,\n) => {\n  const el =\n    isHTMLElement(root) && isScrollable(root, vertical) ? root : document.body\n\n  if (vertical) {\n    return el.scrollHeight - el.scrollTop\n  } else {\n    return el.scrollWidth - el.scrollLeft\n  }\n}\n\nexport interface UseInfiniteScrollProps\n  extends Omit<IntersectionObserverInit, \"root\"> {\n  /**\n   * Determines whether scrolling is instant or animates smoothly.\n   */\n  behavior?: ScrollBehavior\n  /**\n   * If `true`, the infinite scroll is disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * Ref to a reset index function.\n   */\n  indexRef?: RefObject<(index: number) => void>\n  /**\n   * If `true`, invoke `onLoad` function for the first time.\n   *\n   * @default false\n   */\n  initialLoad?: boolean\n  /**\n   * The orientation of the infinite scroll.\n   *\n   * @default 'vertical'\n   */\n  orientation?: Orientation\n  /**\n   * Ref to a reset function.\n   */\n  resetRef?: RefObject<(index?: number, runScroll?: boolean) => void>\n  /**\n   *  If `true`, reverse direction.\n   *\n   * @default false\n   */\n  reverse?: boolean\n  /**\n   * Margin around the root. Can have values similar to the CSS margin property,\n   * e.g. \"10px 20px 30px 40px\" (top, right, bottom, left).\n   */\n  rootMargin?: string\n  /**\n   * The element that is used as the viewport for checking visibility of the target.\n   * Defaults to the browser viewport if not specified or if `null`.\n   */\n  rootRef?: RefObject<HTMLElement | null>\n  /**\n   * If set the `onLoad` function will start from the given index.\n   * If `initialLoad` is `true`, index starts from `0`.\n   *\n   * @default 1\n   */\n  startIndex?: number\n  /**\n   * Either a single number or an array of numbers which indicate at what percentage of the target's visibility the observer's callback should be executed.\n   */\n  threshold?: number | number[]\n  /**\n   * The callback invoked when trigger is intersect.\n   */\n  onLoad?: ({\n    entry,\n    finish,\n    index,\n  }: {\n    finish: () => void\n    index: number\n    entry?: IntersectionObserverEntry\n  }) => Promise<void> | void\n}\n\n/**\n * `useInfiniteScroll` is a custom hook for providing infinite scroll functionality.\n *\n * @see https://yamada-ui.com/hooks/use-infinite-scroll\n */\nexport const useInfiniteScroll = <Y extends HTMLElement = HTMLDivElement>({\n  behavior,\n  disabled = false,\n  indexRef: indexRefProp,\n  initialLoad = false,\n  orientation = \"vertical\",\n  resetRef,\n  reverse = false,\n  rootMargin,\n  rootRef,\n  startIndex = initialLoad ? 0 : 1,\n  threshold,\n  onLoad: onLoadProp,\n}: UseInfiniteScrollProps = {}) => {\n  const ref = useRef<Y>(null)\n  const indexRef = useRef<number>(startIndex)\n  const processingRef = useRef<boolean>(false)\n  const observerRef = useRef<IntersectionObserver | undefined>(undefined)\n  const mountedRef = useRef<boolean>(false)\n  const prevScrollPosition = useRef<number>(0)\n  const [finish, setFinish] = useState<boolean>(false)\n  const onLoad = useCallbackRef(onLoadProp)\n  const vertical = orientation === \"vertical\"\n  const options: IntersectionObserverInit = useMemo(() => {\n    const root = rootRef?.current\n\n    return { root, rootMargin, threshold }\n  }, [rootMargin, rootRef, threshold])\n\n  const onReset = useCallback(\n    (index = 1, runScroll = true) => {\n      indexRef.current = index\n\n      setFinish(false)\n\n      if (runScroll) {\n        const root = rootRef?.current\n\n        onScroll({ behavior, reverse, root, vertical })\n      }\n\n      if (disabled) return\n\n      setTimeout(() => {\n        const observer = observerRef.current\n        const el = ref.current\n\n        if (el) observer?.observe(el)\n      })\n    },\n    [disabled, reverse, rootRef, vertical, behavior],\n  )\n\n  const onFinish = useCallback(() => {\n    const observer = observerRef.current\n    const el = ref.current\n\n    if (el) observer?.unobserve(el)\n\n    setFinish(true)\n  }, [])\n\n  const createObserver = useCallback(() => {\n    const observer = new IntersectionObserver(async ([entry]) => {\n      if (!entry?.isIntersecting || processingRef.current) return\n\n      const props = { entry, finish: onFinish, index: indexRef.current }\n\n      processingRef.current = true\n\n      const root = rootRef?.current\n\n      if (root) root.ariaBusy = \"true\"\n\n      if (reverse) {\n        prevScrollPosition.current = getScrollPosition(root, vertical)\n      }\n\n      await onLoad(props)\n\n      if (reverse) {\n        const position = prevScrollPosition.current\n\n        onScroll({ position, root, vertical })\n      }\n\n      indexRef.current += 1\n      processingRef.current = false\n      if (root) root.ariaBusy = \"false\"\n    }, options)\n\n    return observer\n  }, [onFinish, onLoad, options, rootRef, reverse, vertical])\n\n  useEffect(() => {\n    const setupObserver = async () => {\n      const el = ref.current\n      const mounted = mountedRef.current\n      const index = indexRef.current\n      const root = rootRef?.current\n\n      if (initialLoad && !mounted) {\n        processingRef.current = true\n        if (root) root.ariaBusy = \"true\"\n\n        await onLoad({ finish: onFinish, index })\n\n        indexRef.current += 1\n        processingRef.current = false\n        if (root) root.ariaBusy = \"false\"\n      }\n\n      if (disabled) return\n\n      observerRef.current = createObserver()\n\n      const observer = observerRef.current\n\n      if (reverse && !mounted) {\n        const root = rootRef?.current\n\n        onScroll({ reverse, root, vertical })\n\n        mountedRef.current = true\n      }\n\n      setTimeout(() => {\n        if (el) observer.observe(el)\n      })\n\n      return () => {\n        if (el) observer.unobserve(el)\n      }\n    }\n\n    setupObserver()\n  }, [\n    createObserver,\n    initialLoad,\n    disabled,\n    reverse,\n    vertical,\n    onFinish,\n    onLoad,\n    rootRef,\n  ])\n\n  useUnmountEffect(() => (mountedRef.current = false))\n\n  assignRef(resetRef, onReset)\n  assignRef(indexRefProp, (index) => (indexRef.current = index))\n\n  return { ref, finish }\n}\n"
    }
  ]
}
