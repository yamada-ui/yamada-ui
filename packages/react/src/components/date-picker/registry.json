{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [
      "autocomplete",
      "native-select",
      "input",
      "calendar",
      "group",
      "icon",
      "popover",
      "field",
      "format"
    ],
    "externals": ["dayjs@^1.11.18"],
    "hooks": ["use-field-sizing", "use-combobox", "use-controllable-state"],
    "providers": ["i18n-provider"]
  },
  "section": "components",
  "sources": [
    {
      "name": "date-picker.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\nimport { autocompleteStyle } from \"../autocomplete\"\nimport { nativeSelectStyle } from \"../native-select\"\n\nexport const datePickerStyle = defineComponentSlotStyle({\n  base: {\n    ...nativeSelectStyle.base,\n    adjust: { fieldSizing: \"content\", flex: \"inherit\", w: \"fit-content\" },\n    content: { p: \"1\" },\n    field: autocompleteStyle.base?.field,\n    input: {\n      ...autocompleteStyle.base?.input,\n      '&[tabindex=\"-1\"]': { caret: \"transparent\" },\n    },\n    separator: { color: \"fg.subtle\", mx: \"{gap}\" },\n  },\n\n  variants: {\n    filled: autocompleteStyle.variants?.filled,\n    flushed: autocompleteStyle.variants?.flushed,\n    outline: autocompleteStyle.variants?.outline,\n    plain: autocompleteStyle.variants?.plain,\n  },\n\n  sizes: {\n    xs: nativeSelectStyle.sizes?.xs,\n    sm: nativeSelectStyle.sizes?.sm,\n    md: nativeSelectStyle.sizes?.md,\n    lg: nativeSelectStyle.sizes?.lg,\n    xl: nativeSelectStyle.sizes?.xl,\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"outline\",\n  },\n})\n\nexport type DatePickerStyle = typeof datePickerStyle\n"
    },
    {
      "name": "date-picker.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement, ReactNode } from \"react\"\nimport type {\n  Direction,\n  GenericsComponent,\n  HTMLProps,\n  HTMLStyledProps,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { DatePickerStyle } from \"./date-picker.style\"\nimport type { UseDatePickerProps, UseDatePickerReturn } from \"./use-date-picker\"\nimport { useMemo } from \"react\"\nimport {\n  createSlotComponent,\n  styled,\n  cast,\n  isArray,\n  isDate,\n  isObject,\n  mergeRefs,\n} from \"@yamada-ui/react\"\nimport { useFieldSizing } from \"../../hooks/use-field-sizing\"\nimport { Calendar } from \"../calendar\"\nimport { useGroupItemProps } from \"../group\"\nimport { CalendarIcon, XIcon } from \"../icon\"\nimport { InputGroup, useInputBorder, useInputPropsContext } from \"../input\"\nimport { Popover, usePopoverProps } from \"../popover\"\nimport { datePickerStyle } from \"./date-picker.style\"\nimport { useDatePicker } from \"./use-date-picker\"\n\ninterface ComponentContext\n  extends Pick<UseDatePickerReturn, \"getInputProps\" | \"range\" | \"separator\">,\n    Pick<DatePickerProps, \"inputProps\"> {}\n\nexport interface DatePickerProps<\n  Multiple extends boolean = false,\n  Range extends boolean = false,\n> extends Omit<\n      HTMLStyledProps,\n      \"defaultValue\" | \"filter\" | \"offset\" | \"onChange\" | \"ref\" | \"value\"\n    >,\n    UseDatePickerProps<Multiple, Range>,\n    Omit<\n      WithoutThemeProps<Popover.RootProps, DatePickerStyle>,\n      | \"autoFocus\"\n      | \"children\"\n      | \"initialFocusRef\"\n      | \"modal\"\n      | \"transform\"\n      | \"updateRef\"\n      | \"withCloseButton\"\n    >,\n    ThemeProps<DatePickerStyle>,\n    UseInputBorderProps {\n  /**\n   * If `true`, display the clear icon.\n   *\n   * @default true\n   */\n  clearable?: boolean\n  /**\n   * The icon to be used in the clear button.\n   */\n  clearIcon?: ReactNode\n  /**\n   * The icon to be used in the date picker.\n   */\n  icon?: ReactNode\n  /**\n   * The placement of the popper relative to its reference.\n   *\n   * @default 'end-start'\n   */\n  placement?: Direction\n  /**\n   * The size of the calendar component.\n   */\n  calendarProps?: Calendar.RootProps<Multiple, Range>\n  /**\n   * Props for content element.\n   */\n  contentProps?: DatePickerContentProps\n  /**\n   * The props for the end element.\n   */\n  elementProps?: InputGroup.ElementProps\n  /**\n   * Props for icon element.\n   */\n  iconProps?: DatePickerIconProps\n  /**\n   * The props for the input element.\n   */\n  inputProps?: HTMLStyledProps<\"input\">\n  /**\n   * Props for root element.\n   */\n  rootProps?: InputGroup.RootProps\n}\n\nconst {\n  ComponentContext,\n  PropsContext: DatePickerPropsContext,\n  useComponentContext,\n  usePropsContext: useDatePickerPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<DatePickerProps, DatePickerStyle, ComponentContext>(\n  \"date-picker\",\n  datePickerStyle,\n)\n\nexport { DatePickerPropsContext, useDatePickerPropsContext }\n\n/**\n * `DatePicker` is a component used for users to select a date.\n *\n * @see https://yamada-ui.com/docs/components/date-picker\n */\nexport const DatePicker = withProvider(\n  <Multiple extends boolean = false, Range extends boolean = false>(\n    props: DatePickerProps<Multiple, Range>,\n  ) => {\n    const [groupItemProps, mergedProps] = useGroupItemProps(props)\n    const [\n      popoverProps,\n      {\n        className,\n        css,\n        colorScheme,\n        size,\n        children,\n        clearable = true,\n        clearIcon = <XIcon />,\n        errorBorderColor,\n        focusBorderColor,\n        icon,\n        calendarProps,\n        contentProps,\n        elementProps,\n        iconProps,\n        inputProps,\n        rootProps,\n        ...rest\n      },\n    ] = usePopoverProps(mergedProps, [\n      \"disabled\",\n      \"open\",\n      \"defaultOpen\",\n      \"onOpen\",\n      \"onClose\",\n      \"openOnClick\",\n    ])\n    const {\n      children: fieldChildren,\n      interactive,\n      open,\n      range,\n      separator,\n      value,\n      getCalendarProps,\n      getClearIconProps,\n      getContentProps,\n      getFieldProps,\n      getIconProps,\n      getInputProps,\n      getRootProps,\n      onClose,\n      onOpen,\n    } = useDatePicker(rest)\n    const mergedPopoverProps = useMemo<Popover.RootProps>(\n      () => ({\n        animationScheme: \"block-start\",\n        autoFocus: false,\n        placement: \"end-start\",\n        ...popoverProps,\n        disabled: !interactive,\n        open,\n        onClose,\n        onOpen,\n      }),\n      [interactive, onClose, onOpen, open, popoverProps],\n    )\n    const varProps = useInputBorder({ errorBorderColor, focusBorderColor })\n    const selectProps = useMemo<Calendar.RootProps[\"selectProps\"]>(\n      () => ({ contentProps: { portalProps: { disabled: true } } }),\n      [],\n    )\n    const componentContext = useMemo(\n      () => ({ range, separator, getInputProps, inputProps }),\n      [getInputProps, inputProps, range, separator],\n    )\n    const hasValue = isArray(value)\n      ? !!value.length\n      : isObject(value) && !isDate(value)\n        ? !!value.end || !!value.start\n        : !!value\n\n    return (\n      <ComponentContext value={componentContext}>\n        <Popover.Root {...mergedPopoverProps}>\n          <InputGroup.Root\n            className={className}\n            css={css}\n            colorScheme={colorScheme}\n            {...getRootProps({ ...groupItemProps, ...rootProps })}\n          >\n            <Popover.Trigger>\n              <DatePickerField {...getFieldProps(varProps)}>\n                {fieldChildren}\n              </DatePickerField>\n            </Popover.Trigger>\n\n            <InputGroup.Element\n              {...{ clickable: clearable && hasValue, ...elementProps }}\n            >\n              {clearable && hasValue ? (\n                <DatePickerIcon\n                  icon={clearIcon}\n                  {...getClearIconProps(iconProps)}\n                />\n              ) : (\n                <DatePickerIcon icon={icon} {...getIconProps(iconProps)} />\n              )}\n            </InputGroup.Element>\n          </InputGroup.Root>\n\n          <DatePickerContent\n            {...cast<DatePickerContentProps>(\n              getContentProps(cast<HTMLProps>(contentProps)),\n            )}\n          >\n            <Calendar.Root\n              colorScheme={colorScheme}\n              size={size}\n              fixed={false}\n              selectProps={selectProps}\n              {...getCalendarProps(calendarProps)}\n            >\n              {children}\n            </Calendar.Root>\n          </DatePickerContent>\n        </Popover.Root>\n      </ComponentContext>\n    )\n  },\n  \"root\",\n  { transferProps: [\"size\"] },\n)((props) => {\n  const context = useInputPropsContext()\n\n  return { ...context, ...props }\n}) as GenericsComponent<{\n  <Multiple extends boolean = false, Range extends boolean = false>(\n    props: DatePickerProps<Multiple, Range>,\n  ): ReactElement\n}>\n\ninterface DatePickerFieldProps extends HTMLStyledProps {}\n\nconst DatePickerField = withContext<\"div\", DatePickerFieldProps>(\n  \"div\",\n  \"field\",\n)({ \"data-group-propagate\": \"\" }, ({ children, ...rest }) => {\n  const { range, separator, getInputProps, inputProps } = useComponentContext()\n  const computedChildren = useMemo(() => {\n    if (range) {\n      return (\n        <>\n          <DatePickerAdjustInput\n            {...getInputProps({ align: \"start\", ...inputProps })}\n          />\n          <DatePickerSeparator>{separator}</DatePickerSeparator>\n          <DatePickerAdjustInput\n            {...getInputProps({ align: \"end\", ...inputProps })}\n          />\n        </>\n      )\n    } else {\n      return (\n        <>\n          {children}\n          <DatePickerInput {...getInputProps(inputProps)} />\n        </>\n      )\n    }\n  }, [children, getInputProps, inputProps, range, separator])\n\n  return {\n    ...rest,\n    children: computedChildren,\n  }\n})\n\ninterface DatePickerInputProps extends HTMLStyledProps<\"input\"> {}\n\nconst DatePickerInput = withContext<\"input\", DatePickerInputProps>(\n  \"input\",\n  \"input\",\n)()\n\ninterface DatePickerAdjustInputProps extends HTMLStyledProps<\"input\"> {}\n\nconst DatePickerAdjustInput = withContext<\"input\", DatePickerAdjustInputProps>(\n  ({ ref, placeholder, value, ...rest }) => {\n    const { ref: inputRef, text } = useFieldSizing({\n      value: value?.toString() || placeholder,\n    })\n\n    return (\n      <>\n        {text}\n\n        <styled.input\n          ref={mergeRefs(ref, inputRef)}\n          placeholder={placeholder}\n          value={value}\n          {...rest}\n        />\n      </>\n    )\n  },\n  [\"input\", \"adjust\"],\n)()\n\ninterface DatePickerSeparatorProps extends HTMLStyledProps<\"span\"> {}\n\nconst DatePickerSeparator = withContext<\"span\", DatePickerSeparatorProps>(\n  \"span\",\n  \"separator\",\n)()\n\ninterface DatePickerIconProps extends HTMLStyledProps {\n  icon?: ReactNode\n}\n\nconst DatePickerIcon = withContext<\"div\", DatePickerIconProps>(\"div\", \"icon\")(\n  undefined,\n  ({ children, icon, ...rest }) => ({\n    children: icon || children || <CalendarIcon />,\n    ...rest,\n  }),\n)\n\ninterface DatePickerContentProps extends Popover.ContentProps {}\n\nconst DatePickerContent = withContext<\"div\", DatePickerContentProps>(\n  Popover.Content,\n  \"content\",\n)()\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./date-picker.style\"\nexport {\n  DatePicker,\n  DatePickerPropsContext,\n  useDatePickerPropsContext,\n} from \"./date-picker\"\nexport type { DatePickerProps } from \"./date-picker\"\nexport * from \"./use-date-picker\"\n"
    },
    {
      "name": "use-date-picker.tsx",
      "content": "\"use client\"\n\nimport type {\n  ChangeEvent,\n  FocusEvent,\n  KeyboardEvent,\n  MouseEvent,\n  ReactNode,\n} from \"react\"\nimport type {\n  HTMLProps,\n  HTMLRefAttributes,\n  PropGetter,\n  Dict,\n} from \"@yamada-ui/react\"\nimport type { UseComboboxProps } from \"../../hooks/use-combobox\"\nimport type {\n  Calendar,\n  CalendarFormat,\n  MaybeDateValue,\n  UseCalendarProps,\n} from \"../calendar\"\nimport type { FieldProps } from \"../field\"\nimport dayjs from \"dayjs\"\nimport {\n  cloneElement,\n  isValidElement,\n  useCallback,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport { useCombobox } from \"../../hooks/use-combobox\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport {\n  ariaAttr,\n  cast,\n  contains,\n  dataAttr,\n  handlerAll,\n  isArray,\n  isComposing,\n  isDate,\n  isNumber,\n  isObject,\n  mergeRefs,\n  runIfFn,\n  runKeyAction,\n  useUpdateEffect,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\nimport {\n  DEFAULT_MAX_DATE,\n  DEFAULT_MIN_DATE,\n  getAdjustedMonth,\n  isAfterDate,\n  isBeforeDate,\n  updateMaybeDateValue,\n  useCalendarProps,\n} from \"../calendar\"\nimport { useFieldProps } from \"../field\"\nimport { useDateTimeFormat } from \"../format\"\n\nexport interface DatePickerFormat extends CalendarFormat {\n  input?: Intl.DateTimeFormatOptions | null\n}\n\ntype InputAlign = \"end\" | \"start\"\ntype MaybeInputValue<Range extends boolean = false> = Range extends true\n  ? { end?: string; start?: string }\n  : string | undefined\n\ninterface DatePickerRenderProps {\n  count: number\n  date: Date\n  focused: boolean\n  index: number\n  separator: string\n  value: string\n  onClear: () => void\n  max?: number\n}\n\nexport interface DatePickerRender {\n  (props: DatePickerRenderProps): ReactNode\n}\n\nconst defaultRender: DatePickerRender = ({\n  count,\n  focused,\n  index,\n  max,\n  separator,\n  value,\n}) => {\n  const last = count - 1 === index\n\n  return (\n    <span style={{ marginInlineEnd: \"var(--gap)\" }}>\n      {value}\n      {((!isNumber(max) || count < max) && focused) || !last ? separator : null}\n    </span>\n  )\n}\n\nexport interface UseDatePickerProps<\n  Multiple extends boolean = false,\n  Range extends boolean = false,\n> extends Omit<UseCalendarProps<Multiple, Range>, \"format\" | \"ref\">,\n    Omit<\n      UseComboboxProps,\n      \"defaultValue\" | \"initialFocusValue\" | \"onChange\" | \"ref\" | \"value\"\n    >,\n    HTMLRefAttributes<\"input\">,\n    FieldProps {\n  /**\n   * The `id` attribute of the input element.\n   */\n  id?: string\n  /**\n   * The `name` attribute of the input element.\n   */\n  name?: string\n  /**\n   * If `true`, allows input.\n   *\n   * @default true\n   */\n  allowInput?: boolean\n  /**\n   * If `true`, allows input of dates beyond the `minDate` and `maxDate` restrictions.\n   *\n   * @default true\n   */\n  allowInputBeyond?: boolean\n  /**\n   * If `true`, the date picker will be closed when the input value changes.\n   *\n   * @default false\n   */\n  closeOnChange?: ((ev: ChangeEvent<HTMLInputElement>) => boolean) | boolean\n  /**\n   * The initial value of the input.\n   */\n  defaultInputValue?: MaybeInputValue<Range>\n  /**\n   * If `true`, the input will be focused when the clear icon is clicked.\n   *\n   * @default true\n   */\n  focusOnClear?: boolean\n  /**\n   * The format used for conversion.\n   * Check the docs to see the format of possible modifiers you can pass.\n   *\n   * @see https://day.js.org/docs/en/display/format#list-of-localized-formats\n   */\n  format?: DatePickerFormat\n  /**\n   * The value of the input.\n   */\n  inputValue?: MaybeInputValue<Range>\n  /**\n   * If `true`, the date picker will be opened when the input value changes.\n   *\n   * @default true\n   */\n  openOnChange?: ((ev: ChangeEvent<HTMLInputElement>) => boolean) | boolean\n  /**\n   * If `true`, the date picker will be opened when the input is focused.\n   *\n   * @default true\n   */\n  openOnFocus?: boolean\n  /**\n   * Function that converts the input value to Date type.\n   */\n  parseDate?: (value: string) => Date | undefined\n  /**\n   * The pattern used to check the input element.\n   */\n  pattern?: RegExp\n  /**\n   * The placeholder for date picker.\n   */\n  placeholder?: string\n  /**\n   * The function to render the selected date.\n   */\n  render?: (props: DatePickerRenderProps) => ReactNode\n  /**\n   * The visual separator between each value.\n   *\n   * @default ','\n   */\n  separator?: string\n  /**\n   * The callback invoked when input value state changes.\n   */\n  onInputChange?: (value: MaybeInputValue<Range>) => void\n}\n\nexport const useDatePicker = <\n  Multiple extends boolean = false,\n  Range extends boolean = false,\n>({\n  maxDate = DEFAULT_MAX_DATE,\n  minDate = DEFAULT_MIN_DATE,\n  ...props\n}: UseDatePickerProps<Multiple, Range> = {}) => {\n  if (dayjs(minDate).isAfter(dayjs(maxDate))) maxDate = minDate\n\n  const { locale: defaultLocale, t } = useI18n(\"datePicker\")\n  const {\n    props: {\n      id,\n      ref,\n      name,\n      allowInput = true,\n      allowInputBeyond = false,\n      closeOnChange = false,\n      multiple = false,\n      closeOnSelect = !multiple,\n      defaultInputValue,\n      defaultMonth = new Date(),\n      range = false,\n      defaultValue = (range\n        ? { end: undefined, start: undefined }\n        : multiple\n          ? []\n          : undefined) as MaybeDateValue<Multiple, Range>,\n      disabled,\n      focusOnClear = true,\n      format,\n      inputValue: inputValueProp,\n      locale = defaultLocale,\n      max,\n      month: monthProp,\n      openOnChange = true,\n      openOnFocus = true,\n      parseDate,\n      pattern,\n      placeholder: placeholderProp,\n      readOnly,\n      render = defaultRender,\n      required,\n      separator = range ? \"-\" : \",\",\n      value: valueProp,\n      onChange: onChangeProp,\n      onChangeMonth: onChangeMonthProp,\n      onInputChange: onInputChangeProp,\n      ...computedProps\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const dateTimeFormat = useDateTimeFormat({ locale })\n  const { calendarFormat, inputFormat } = useMemo(() => {\n    const { input: inputFormat, ...calendarFormat } = format ?? {}\n    const defaultInputFormat: Intl.DateTimeFormatOptions = {\n      day: \"numeric\",\n      month: \"long\",\n      year: \"numeric\",\n    }\n\n    return {\n      calendarFormat,\n      inputFormat:\n        inputFormat !== null ? (inputFormat ?? defaultInputFormat) : undefined,\n    }\n  }, [format])\n  const [calendarProps, rest] = useCalendarProps<Multiple, Range>(computedProps)\n  const { excludeDate } = calendarProps\n  const rootRef = useRef<HTMLDivElement>(null)\n  const fieldRef = useRef<HTMLDivElement>(null)\n  const contentRef = useRef<HTMLDivElement>(null)\n  const startInputRef = useRef<HTMLInputElement>(null)\n  const endInputRef = useRef<HTMLInputElement>(null)\n  const [focused, setFocused] = useState(false)\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue as MaybeDateValue<Multiple, Range>,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const [month, setMonth] = useControllableState({\n    defaultValue: () => {\n      let value = defaultMonth\n\n      if (dayjs(minDate).isAfter(dayjs(defaultMonth)))\n        value = dayjs(minDate).set(\"date\", 1).toDate()\n\n      if (valueProp) {\n        value = getAdjustedMonth(valueProp, value)\n      } else if (defaultValue) {\n        value = getAdjustedMonth(defaultValue, value)\n      }\n\n      return value\n    },\n    value: monthProp,\n    onChange: onChangeMonthProp,\n  })\n  const stringToDate = useCallback(\n    (value: string, start: Date = minDate, end: Date = maxDate) => {\n      let date = parseDate?.(value)\n\n      if (!date && dayjs(value).isValid()) date = dayjs(value, locale).toDate()\n\n      if (date == null) return undefined\n      if (excludeDate?.(date)) return undefined\n\n      if (!allowInputBeyond) {\n        if (isBeforeDate(date, start)) date = start\n        if (isAfterDate(date, end)) date = end\n      }\n\n      return date\n    },\n    [allowInputBeyond, excludeDate, locale, maxDate, minDate, parseDate],\n  )\n  const dateToString = useCallback(\n    (date?: Date) => {\n      if (date == null) return \"\"\n\n      return dateTimeFormat(date, inputFormat)\n    },\n    [dateTimeFormat, inputFormat],\n  )\n  const [inputValue, setInputValue] = useControllableState({\n    defaultValue: () => {\n      if (defaultInputValue) {\n        if (isObject(defaultInputValue)) {\n          if (dayjs(defaultInputValue.start).isValid())\n            defaultInputValue.start = dateTimeFormat(\n              dayjs(defaultInputValue.start).toDate(),\n              inputFormat,\n            )\n\n          if (dayjs(defaultInputValue.end).isValid())\n            defaultInputValue.end = dateTimeFormat(\n              dayjs(defaultInputValue.end).toDate(),\n              inputFormat,\n            )\n\n          return defaultInputValue\n        } else {\n          if (dayjs(defaultInputValue).isValid()) {\n            return dateTimeFormat(\n              dayjs(defaultInputValue).toDate(),\n              inputFormat,\n            ) as MaybeInputValue<Range>\n          } else {\n            return defaultInputValue as MaybeInputValue<Range>\n          }\n        }\n      } else if (isDate(value)) {\n        return dateToString(value) as MaybeInputValue<Range>\n      } else if (isObject(value) && !isArray(value)) {\n        return {\n          end: dateToString(value.end),\n          start: dateToString(value.start),\n        } as MaybeInputValue<Range>\n      } else {\n        return \"\" as MaybeInputValue<Range>\n      }\n    },\n    value: inputValueProp,\n    onChange: onInputChangeProp,\n  })\n  const {\n    interactive,\n    open,\n    getContentProps: getComboboxContentProps,\n    getTriggerProps,\n    onClose,\n    onOpen,\n  } = useCombobox({\n    disabled,\n    openOnEnter: !allowInput,\n    openOnSpace: !allowInput,\n    readOnly,\n    ...ariaProps,\n    ...dataProps,\n    ...eventProps,\n    ...rest,\n  })\n  const children = useMemo<ReactNode>(() => {\n    if (!isArray(value)) return null\n\n    const count = value.length\n\n    return value.map((date, index) => {\n      const value = dateToString(date)\n\n      const onClear = (ev?: MouseEvent<HTMLElement>) => {\n        ev?.preventDefault()\n        ev?.stopPropagation()\n\n        setValue(\n          (prev) =>\n            updateMaybeDateValue(date, max)(prev) as MaybeDateValue<\n              Multiple,\n              Range\n            >,\n        )\n      }\n\n      const component = render({\n        count,\n        date,\n        focused,\n        index,\n        max,\n        separator,\n        value,\n        onClear,\n      })\n\n      if (isValidElement<Dict>(component)) {\n        return cloneElement(component, { ...component.props, key: index })\n      } else {\n        return component\n      }\n    })\n  }, [dateToString, focused, max, render, separator, setValue, value])\n  const { endPlaceholder, startPlaceholder } = useMemo(() => {\n    if (range) {\n      const startPlaceholder =\n        placeholderProp ?? dateTimeFormat(new Date(), inputFormat)\n      const endPlaceholder =\n        placeholderProp ??\n        dateTimeFormat(dayjs().add(1, \"day\").toDate(), inputFormat)\n\n      return { endPlaceholder, startPlaceholder }\n    } else {\n      const placeholder =\n        placeholderProp ?? dateTimeFormat(new Date(), inputFormat)\n\n      return { endPlaceholder: placeholder, startPlaceholder: placeholder }\n    }\n  }, [dateTimeFormat, inputFormat, placeholderProp, range])\n\n  const onChange = useCallback(\n    (value: MaybeDateValue<Multiple, Range>) => {\n      setValue(value)\n\n      if (isArray(value)) {\n        setInputValue(\"\" as MaybeInputValue<Range>)\n      } else if (isObject(value) && !isDate(value)) {\n        setInputValue({\n          end: dateToString(value.end),\n          start: dateToString(value.start),\n        } as MaybeInputValue<Range>)\n      } else {\n        setInputValue(dateToString(value) as MaybeInputValue<Range>)\n      }\n\n      if (!closeOnSelect) return\n\n      if (isObject(value) && !isArray(value) && !isDate(value)) {\n        if (value.end && value.start) onClose()\n      } else {\n        onClose()\n      }\n    },\n    [setValue, closeOnSelect, setInputValue, dateToString, onClose],\n  )\n\n  const onInputChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      if (!allowInput) return\n      if (isArray(value) && value.length === max) return\n\n      if (runIfFn(closeOnChange, ev)) {\n        onClose()\n      } else if (runIfFn(openOnChange, ev)) {\n        onOpen()\n      }\n\n      let inputValue = ev.target.value\n\n      if (pattern) inputValue = inputValue.replace(pattern, \"\")\n\n      if (isArray(value)) {\n        const date = stringToDate(inputValue)\n\n        setInputValue(inputValue as MaybeInputValue<Range>)\n\n        if (date) setMonth(dayjs(date).set(\"date\", 1).toDate())\n      } else if (isObject(value) && !isDate(value)) {\n        const align = contains(endInputRef.current, ev.target) ? \"end\" : \"start\"\n        const minDate =\n          value.start && align === \"end\"\n            ? dayjs(value.start).add(1, \"day\").toDate()\n            : undefined\n        const maxDate =\n          value.end && align === \"start\"\n            ? dayjs(value.end).subtract(1, \"day\").toDate()\n            : undefined\n        const date = stringToDate(inputValue, minDate, maxDate)\n\n        setInputValue((prev) =>\n          isObject(prev)\n            ? ({\n                ...(prev as MaybeInputValue<true>),\n                [align]: inputValue,\n              } as MaybeInputValue<Range>)\n            : prev,\n        )\n        setValue((prev) =>\n          isObject(prev) && !isDate(prev)\n            ? ({ ...prev, [align]: date } as MaybeDateValue<Multiple, Range>)\n            : prev,\n        )\n      } else {\n        const date = stringToDate(inputValue)\n\n        setInputValue(inputValue as MaybeInputValue<Range>)\n        setValue(date as MaybeDateValue<Multiple, Range>)\n      }\n    },\n    [\n      allowInput,\n      closeOnChange,\n      max,\n      onClose,\n      onOpen,\n      openOnChange,\n      pattern,\n      setInputValue,\n      setMonth,\n      setValue,\n      stringToDate,\n      value,\n    ],\n  )\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLInputElement>) => {\n      if (disabled || isComposing(ev)) return\n\n      const inputValue = cast<HTMLInputElement>(ev.target).value\n\n      runKeyAction(\n        ev,\n        {\n          Backspace: (ev) => {\n            if (!value || isDate(value)) return\n            if (!!inputValue.length) return\n\n            if (isArray(value)) {\n              ev.preventDefault()\n\n              setValue((prev) =>\n                isArray(prev)\n                  ? (prev.slice(0, -1) as MaybeDateValue<Multiple, Range>)\n                  : prev,\n              )\n            } else if (contains(endInputRef.current, ev.target)) {\n              ev.preventDefault()\n\n              setInputValue({ end: \"\", start: \"\" } as MaybeInputValue<Range>)\n              setValue({ end: undefined, start: undefined } as MaybeDateValue<\n                Multiple,\n                Range\n              >)\n\n              startInputRef.current?.focus()\n            }\n          },\n          Enter: (ev) => {\n            if (!open || !inputValue.length) return\n\n            if (isDate(value) || isArray(value)) {\n              const date = stringToDate(inputValue)\n\n              if (!date) return\n\n              ev.preventDefault()\n\n              if (isArray(value)) {\n                setInputValue(\"\" as MaybeInputValue<Range>)\n              } else {\n                setInputValue(dateToString(date) as MaybeInputValue<Range>)\n              }\n\n              setValue(\n                (prev) =>\n                  updateMaybeDateValue(date, max)(prev) as MaybeDateValue<\n                    Multiple,\n                    Range\n                  >,\n              )\n            } else if (isObject(value)) {\n              const align = contains(endInputRef.current, ev.target)\n                ? \"end\"\n                : \"start\"\n              const minDate =\n                value.start && align === \"end\"\n                  ? dayjs(value.start).add(1, \"day\").toDate()\n                  : undefined\n              const maxDate =\n                value.end && align === \"start\"\n                  ? dayjs(value.end).subtract(1, \"day\").toDate()\n                  : undefined\n              const date = stringToDate(inputValue, minDate, maxDate)\n\n              if (!date) return\n\n              ev.preventDefault()\n\n              setInputValue((prev) =>\n                isObject(prev)\n                  ? ({\n                      ...(prev as MaybeInputValue<true>),\n                      [align]: dateToString(date),\n                    } as MaybeInputValue<Range>)\n                  : prev,\n              )\n              setValue((prev) =>\n                isObject(prev) && !isDate(prev)\n                  ? ({ ...prev, [align]: date } as MaybeDateValue<\n                      Multiple,\n                      Range\n                    >)\n                  : prev,\n              )\n\n              if (align === \"start\") endInputRef.current?.focus()\n            }\n          },\n        },\n        { preventDefault: false },\n      )\n    },\n    [\n      dateToString,\n      disabled,\n      max,\n      open,\n      setInputValue,\n      setValue,\n      stringToDate,\n      value,\n    ],\n  )\n\n  const onClick = useCallback(\n    (ev: MouseEvent<HTMLDivElement>) => {\n      if (!interactive || !allowInput) return\n\n      if (isObject(value) && !isArray(value) && !isDate(value)) {\n        if (contains(startInputRef.current, ev.target)) return\n        if (contains(endInputRef.current, ev.target)) return\n\n        const { end, start } = value\n\n        if ((!start && !end) || !!end) {\n          startInputRef.current?.focus()\n        } else {\n          endInputRef.current?.focus()\n        }\n      } else {\n        startInputRef.current?.focus()\n      }\n    },\n    [allowInput, interactive, value],\n  )\n\n  const onMouseDown = useCallback(\n    (ev: MouseEvent<HTMLInputElement>) => {\n      if (!openOnFocus) return\n\n      ev.preventDefault()\n      ev.stopPropagation()\n    },\n    [openOnFocus],\n  )\n\n  const onFocus = useCallback(\n    (ev: FocusEvent<HTMLInputElement>) => {\n      ev.preventDefault()\n      ev.stopPropagation()\n\n      setFocused(true)\n\n      if (openOnFocus) onOpen()\n    },\n    [onOpen, openOnFocus],\n  )\n\n  const onBlur = useCallback(\n    (ev: FocusEvent<HTMLInputElement>) => {\n      setFocused(false)\n\n      if (\n        contains(rootRef.current, ev.relatedTarget) ||\n        contains(contentRef.current, ev.relatedTarget)\n      ) {\n        ev.preventDefault()\n      } else {\n        if (isArray(value)) {\n          setInputValue(\"\" as MaybeInputValue<Range>)\n        } else if (isObject(value) && !isDate(value)) {\n          setInputValue((prev) =>\n            isObject(prev)\n              ? ({\n                  end: dateToString(value.end),\n                  start: dateToString(value.start),\n                } as MaybeInputValue<Range>)\n              : prev,\n          )\n        } else {\n          setInputValue(dateToString(value) as MaybeInputValue<Range>)\n        }\n      }\n    },\n    [dateToString, setInputValue, value],\n  )\n\n  const onClear = useCallback(() => {\n    if (!interactive) return\n\n    setValue((prev) => {\n      if (isDate(prev)) {\n        return undefined as MaybeDateValue<Multiple, Range>\n      } else if (isArray(prev)) {\n        return [] as unknown as MaybeDateValue<Multiple, Range>\n      } else if (isObject(prev)) {\n        return { end: undefined, start: undefined } as MaybeDateValue<\n          Multiple,\n          Range\n        >\n      } else {\n        return prev\n      }\n    })\n\n    setInputValue(\n      (range ? { end: \"\", start: \"\" } : \"\") as MaybeInputValue<Range>,\n    )\n\n    if (focusOnClear) {\n      if (allowInput) {\n        startInputRef.current?.focus()\n      } else {\n        fieldRef.current?.focus()\n      }\n    }\n  }, [allowInput, focusOnClear, interactive, range, setInputValue, setValue])\n\n  useUpdateEffect(() => {\n    setMonth((prev) => getAdjustedMonth(value, prev))\n  }, [value, range])\n\n  useUpdateEffect(() => {\n    if (isArray(valueProp)) return\n\n    if (isObject(valueProp) && !isDate(valueProp)) {\n      setInputValue({\n        end: dateToString(valueProp.end),\n        start: dateToString(valueProp.start),\n      } as MaybeInputValue<Range>)\n    } else {\n      setInputValue(dateToString(valueProp) as MaybeInputValue<Range>)\n    }\n  }, [valueProp])\n\n  const getRootProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ref: mergeRefs(ref, rootRef),\n      \"data-range\": dataAttr(range),\n      ...dataProps,\n      ...props,\n    }),\n    [dataProps, range],\n  )\n\n  const getFieldProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) =>\n      getTriggerProps({\n        ref: mergeRefs(ref, fieldRef),\n        \"aria-haspopup\": \"dialog\",\n        tabIndex: !allowInput ? 0 : -1,\n        ...props,\n        onClick: handlerAll(props.onClick, onClick),\n      }),\n\n    [allowInput, getTriggerProps, onClick],\n  )\n\n  const getInputProps: PropGetter<\"input\", { align?: InputAlign }> =\n    useCallback(\n      ({ align = \"start\", ...props } = {}) => {\n        const inputProps: HTMLProps<\"input\"> = {\n          style: {\n            ...(!allowInput ? { pointerEvents: \"none\" } : {}),\n            ...props.style,\n          },\n          autoComplete: \"off\",\n          disabled,\n          readOnly,\n          required,\n          tabIndex: allowInput ? 0 : -1,\n          ...dataProps,\n          ...props,\n          onBlur: handlerAll(props.onBlur, onBlur),\n          onChange: handlerAll(props.onChange, onInputChange),\n          onFocus: handlerAll(props.onFocus, onFocus),\n          onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n          onMouseDown: handlerAll(props.onMouseDown, onMouseDown),\n        }\n\n        if (isObject(inputValue)) {\n          if (align === \"start\") {\n            inputProps.ref = mergeRefs(props.ref, ref, startInputRef)\n            inputProps.value = inputValue.start\n            inputProps.placeholder = startPlaceholder\n          } else {\n            inputProps.ref = mergeRefs(props.ref, ref, endInputRef)\n            inputProps.value = inputValue.end\n            inputProps.placeholder = endPlaceholder\n          }\n\n          if (!inputValue.start && align === \"start\") {\n            inputProps.id = id\n            inputProps.name = name\n          }\n\n          if (!!inputValue.start && align === \"end\") {\n            inputProps.id = id\n            inputProps.name = name\n          }\n        } else {\n          inputProps.ref = mergeRefs(props.ref, ref, startInputRef)\n          inputProps.value = inputValue\n          inputProps.id = id\n          inputProps.name = name\n\n          if (isArray(value)) {\n            inputProps.style = {\n              ...(!focused && !!value.length\n                ? visuallyHiddenAttributes.style\n                : {}),\n              ...inputProps.style,\n            }\n            inputProps.placeholder = !value.length\n              ? startPlaceholder\n              : undefined\n            inputProps[\"data-max\"] = dataAttr(\n              isNumber(max) && value.length >= max,\n            )\n          } else {\n            inputProps.placeholder = startPlaceholder\n          }\n        }\n\n        return inputProps\n      },\n      [\n        allowInput,\n        dataProps,\n        disabled,\n        endPlaceholder,\n        focused,\n        id,\n        inputValue,\n        max,\n        name,\n        onBlur,\n        onFocus,\n        onInputChange,\n        onKeyDown,\n        onMouseDown,\n        readOnly,\n        ref,\n        required,\n        startPlaceholder,\n        value,\n      ],\n    )\n\n  const getContentProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) =>\n      getComboboxContentProps({\n        ref: mergeRefs(ref, contentRef),\n        role: \"dialog\",\n        ...props,\n      }),\n    [getComboboxContentProps],\n  )\n\n  const getCalendarProps: PropGetter<\n    \"div\",\n    Calendar.RootProps<Multiple, Range>,\n    Calendar.RootProps<Multiple, Range>\n  > = useCallback(\n    (props) =>\n      ({\n        disabled: !interactive,\n        format: calendarFormat,\n        locale,\n        max,\n        maxDate,\n        minDate,\n        month,\n        multiple,\n        range,\n        value,\n        onChange,\n        onChangeMonth: setMonth,\n        ...calendarProps,\n        ...props,\n      }) as Calendar.RootProps<Multiple, Range>,\n    [\n      interactive,\n      calendarFormat,\n      locale,\n      max,\n      maxDate,\n      minDate,\n      month,\n      multiple,\n      range,\n      value,\n      onChange,\n      setMonth,\n      calendarProps,\n    ],\n  )\n\n  const getIconProps: PropGetter = useCallback(\n    (props) => ({ ...dataProps, ...props }),\n    [dataProps],\n  )\n\n  const getClearIconProps: PropGetter = useCallback(\n    (props = {}) =>\n      getIconProps({\n        \"aria-disabled\": ariaAttr(!interactive),\n        \"aria-label\": t(\"Clear value\"),\n        role: \"button\",\n        tabIndex: interactive ? 0 : -1,\n        ...props,\n        onClick: handlerAll(props.onClick, onClear),\n        onKeyDown: handlerAll(props.onKeyDown, (ev) =>\n          runKeyAction(ev, { Enter: onClear, Space: onClear }),\n        ),\n      }),\n    [getIconProps, interactive, onClear, t],\n  )\n\n  return {\n    children,\n    dateToString,\n    inputValue,\n    interactive,\n    month,\n    open,\n    range,\n    separator,\n    setInputValue,\n    setMonth,\n    setValue,\n    stringToDate,\n    value,\n    getCalendarProps,\n    getClearIconProps,\n    getContentProps,\n    getFieldProps,\n    getIconProps,\n    getInputProps,\n    getRootProps,\n    onChange,\n    onClose,\n    onInputChange,\n    onOpen,\n  }\n}\n\nexport type UseDatePickerReturn = ReturnType<typeof useDatePicker>\n"
    }
  ]
}
