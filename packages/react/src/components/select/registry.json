{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [
      "menu",
      "native-select",
      "input",
      "group",
      "icon",
      "popover",
      "field"
    ],
    "externals": [],
    "hooks": ["use-combobox", "use-controllable-state"],
    "providers": ["i18n-provider"]
  },
  "dependents": {
    "components": ["autocomplete", "calendar"],
    "hooks": [],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./select.style\"\nexport * as Select from \"./namespace\"\nexport {\n  SelectGroup,\n  SelectLabel,\n  SelectOption,\n  SelectPropsContext,\n  SelectRoot,\n  SelectSeparator,\n  useSelectPropsContext,\n} from \"./select\"\nexport type {\n  SelectGroupProps,\n  SelectLabelProps,\n  SelectOptionProps,\n  SelectRootProps,\n  SelectSeparatorProps,\n} from \"./select\"\nexport * from \"./use-select\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export type {\n  ComboboxItem as Item,\n  ComboboxItemWithItems as ItemWithItems,\n  ComboboxItemWithValue as ItemWithValue,\n} from \"../../hooks/use-combobox\"\nexport {\n  SelectGroup as Group,\n  SelectLabel as Label,\n  SelectOption as Option,\n  SelectPropsContext as PropsContext,\n  SelectRoot as Root,\n  SelectSeparator as Separator,\n  useSelectPropsContext as usePropsContext,\n} from \"./select\"\nexport type {\n  SelectGroupProps as GroupProps,\n  SelectLabelProps as LabelProps,\n  SelectOptionProps as OptionProps,\n  SelectRootProps as RootProps,\n  SelectSeparatorProps as SeparatorProps,\n} from \"./select\"\nexport type { SelectItemRender as Render } from \"./use-select\"\n"
    },
    {
      "name": "select.style.ts",
      "content": "import { defineComponentSlotStyle, focusRingStyle } from \"@yamada-ui/react\"\nimport { menuStyle } from \"../menu\"\nimport { nativeSelectStyle } from \"../native-select\"\n\nexport const selectStyle = defineComponentSlotStyle({\n  base: {\n    ...nativeSelectStyle.base,\n    content: { ...menuStyle.base?.content, maxH: \"xs\" },\n    field: {\n      ...nativeSelectStyle.base?.field,\n      \"--gap\": \"spaces.1\",\n      alignItems: \"center\",\n      display: \"flex\",\n    },\n    group: menuStyle.base?.group,\n    indicator: menuStyle.base?.indicator,\n    label: menuStyle.base?.label,\n    option: menuStyle.base?.item,\n    separator: menuStyle.base?.separator,\n    valueText: { userSelect: \"none\" },\n  },\n\n  props: {\n    /**\n     * If `true`, wrap the value text.\n     *\n     * @default false\n     */\n    wrap: {\n      false: {\n        valueText: { truncated: true },\n      },\n      true: {\n        field: { py: \"{gap}\" },\n        valueText: {\n          display: \"inline-flex\",\n          flexWrap: \"wrap\",\n          gapY: \"{gap}\",\n        },\n      },\n    },\n  },\n\n  variants: {\n    filled: {\n      ...nativeSelectStyle.variants?.filled,\n      field: {\n        ...nativeSelectStyle.variants?.filled.field,\n        _expanded: focusRingStyle.inside,\n      },\n    },\n    flushed: {\n      ...nativeSelectStyle.variants?.flushed,\n      field: {\n        ...nativeSelectStyle.variants?.flushed.field,\n        _expanded: nativeSelectStyle.variants?.flushed.field?._focusVisible,\n      },\n    },\n    outline: {\n      ...nativeSelectStyle.variants?.outline,\n      field: {\n        ...nativeSelectStyle.variants?.outline.field,\n        _expanded: focusRingStyle.inside,\n      },\n    },\n    plain: {\n      ...nativeSelectStyle.variants?.plain,\n      field: {\n        ...nativeSelectStyle.variants?.plain.field,\n        _expanded: focusRingStyle.inside,\n      },\n    },\n  },\n\n  sizes: {\n    xs: {\n      ...nativeSelectStyle.sizes?.xs,\n      content: menuStyle.sizes?.sm.content,\n      indicator: menuStyle.sizes?.sm.indicator,\n      label: menuStyle.sizes?.sm.label,\n      option: menuStyle.sizes?.sm.item,\n    },\n    sm: {\n      ...nativeSelectStyle.sizes?.sm,\n      content: menuStyle.sizes?.md.content,\n      indicator: menuStyle.sizes?.md.indicator,\n      label: menuStyle.sizes?.md.label,\n      option: menuStyle.sizes?.md.item,\n    },\n    md: {\n      ...nativeSelectStyle.sizes?.md,\n      content: menuStyle.sizes?.md.content,\n      indicator: menuStyle.sizes?.md.indicator,\n      label: menuStyle.sizes?.md.label,\n      option: menuStyle.sizes?.md.item,\n    },\n    lg: {\n      ...nativeSelectStyle.sizes?.lg,\n      content: menuStyle.sizes?.lg.content,\n      indicator: menuStyle.sizes?.lg.indicator,\n      label: menuStyle.sizes?.lg.label,\n      option: menuStyle.sizes?.lg.item,\n    },\n    xl: {\n      ...nativeSelectStyle.sizes?.xl,\n      content: menuStyle.sizes?.lg.content,\n      indicator: menuStyle.sizes?.lg.indicator,\n      label: menuStyle.sizes?.lg.label,\n      option: menuStyle.sizes?.lg.item,\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"outline\",\n    wrap: false,\n  },\n})\n\nexport type SelectStyle = typeof selectStyle\n"
    },
    {
      "name": "select.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement, ReactNode } from \"react\"\nimport type {\n  GenericsComponent,\n  HTMLProps,\n  HTMLStyledProps,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type {\n  ComboboxItem,\n  UseComboboxGroupProps,\n} from \"../../hooks/use-combobox\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { SelectStyle } from \"./select.style\"\nimport type {\n  UseSelectOptionProps,\n  UseSelectProps,\n  UseSelectReturn,\n} from \"./use-select\"\nimport { useMemo } from \"react\"\nimport { createSlotComponent, styled, cast, isArray } from \"@yamada-ui/react\"\nimport {\n  ComboboxContext,\n  ComboboxDescendantsContext,\n  ComboboxGroupContext,\n  createComboboxChildren,\n  createComboboxItem,\n  useComboboxGroup,\n  useComboboxGroupContext,\n} from \"../../hooks/use-combobox\"\nimport { useGroupItemProps } from \"../group\"\nimport { CheckIcon, ChevronDownIcon, XIcon } from \"../icon\"\nimport { InputGroup, useInputBorder, useInputPropsContext } from \"../input\"\nimport { Popover, usePopoverProps } from \"../popover\"\nimport { selectStyle } from \"./select.style\"\nimport { SelectContext, useSelect, useSelectOption } from \"./use-select\"\n\ninterface ComponentContext\n  extends Pick<UseSelectReturn, \"getSeparatorProps\">,\n    Pick<SelectRootProps, \"groupProps\" | \"optionProps\"> {}\n\nexport interface SelectRootProps<Multiple extends boolean = false>\n  extends Omit<\n      HTMLStyledProps,\n      \"defaultValue\" | \"offset\" | \"onChange\" | \"value\"\n    >,\n    UseSelectProps<Multiple>,\n    Omit<\n      WithoutThemeProps<Popover.RootProps, SelectStyle>,\n      | \"autoFocus\"\n      | \"children\"\n      | \"initialFocusRef\"\n      | \"modal\"\n      | \"transform\"\n      | \"updateRef\"\n      | \"withCloseButton\"\n    >,\n    ThemeProps<SelectStyle>,\n    UseInputBorderProps {\n  /**\n   * If `true`, display the clear icon.\n   *\n   * @default false\n   */\n  clearable?: boolean\n  /**\n   * The icon to be used in the clear button.\n   */\n  clearIcon?: ReactNode\n  /**\n   * The icon to be used in the select.\n   */\n  icon?: ReactNode\n  /**\n   * Props for content element.\n   */\n  contentProps?: SelectContentProps\n  /**\n   * The props for the end element.\n   */\n  elementProps?: InputGroup.ElementProps\n  /**\n   * Props for group element.\n   */\n  groupProps?: Omit<SelectGroupProps, \"children\" | \"label\">\n  /**\n   * Props for icon element.\n   */\n  iconProps?: SelectIconProps\n  /**\n   * Props for option element.\n   */\n  optionProps?: Omit<SelectOptionProps, \"children\" | \"value\">\n  /**\n   * Props for placeholder element.\n   */\n  placeholderProps?: Omit<SelectOptionProps, \"children\" | \"value\">\n  /**\n   * Props for root element.\n   */\n  rootProps?: InputGroup.RootProps\n}\n\nconst {\n  ComponentContext,\n  PropsContext: SelectPropsContext,\n  useComponentContext,\n  usePropsContext: useSelectPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<SelectRootProps, SelectStyle, ComponentContext>(\n  \"select\",\n  selectStyle,\n)\n\nexport { SelectPropsContext, useSelectPropsContext }\n\n/**\n * `Select` is a component used for allowing a user to choose one option from a list.\n *\n * @see https://yamada-ui.com/docs/components/select\n */\nexport const SelectRoot = withProvider<\"div\", SelectRootProps>(\n  <Multiple extends boolean = false>(props: SelectRootProps<Multiple>) => {\n    const [groupItemProps, mergedProps] = useGroupItemProps(props)\n    const [\n      popoverProps,\n      {\n        className,\n        css,\n        colorScheme,\n        children,\n        clearable,\n        clearIcon = <XIcon />,\n        errorBorderColor,\n        focusBorderColor,\n        icon,\n        items: itemsProp,\n        contentProps,\n        elementProps,\n        groupProps,\n        iconProps,\n        optionProps,\n        placeholderProps,\n        rootProps,\n        ...rest\n      },\n    ] = usePopoverProps(mergedProps, [\n      \"disabled\",\n      \"open\",\n      \"defaultOpen\",\n      \"onOpen\",\n      \"onClose\",\n      \"openOnClick\",\n    ])\n    const items = useMemo<ComboboxItem[]>(() => {\n      if (itemsProp) return itemsProp\n\n      return createComboboxItem(children, {\n        Group: SelectGroup,\n        Label: SelectLabel,\n        Option: SelectOption,\n      })\n    }, [itemsProp, children])\n    const {\n      descendants,\n      includePlaceholder,\n      interactive,\n      items: computedItems,\n      max,\n      open,\n      placeholder,\n      value,\n      getClearIconProps,\n      getContentProps,\n      getFieldProps,\n      getIconProps,\n      getRootProps,\n      getSeparatorProps,\n      onActiveDescendant,\n      onChange,\n      onClose,\n      onOpen,\n      onSelect,\n    } = useSelect({ items, ...rest })\n    const mergedPopoverProps = useMemo<Popover.RootProps>(\n      () => ({\n        animationScheme: \"block-start\",\n        autoFocus: false,\n        matchWidth: true,\n        ...popoverProps,\n        disabled: !interactive,\n        open,\n        onClose,\n        onOpen,\n      }),\n      [interactive, onClose, onOpen, open, popoverProps],\n    )\n    const computedChildren = useMemo(() => {\n      if (children)\n        return (\n          <>\n            {placeholder ? (\n              <SelectOption\n                {...placeholderProps}\n                hidden={!includePlaceholder}\n                value=\"\"\n              >\n                {placeholder}\n              </SelectOption>\n            ) : null}\n\n            {children}\n          </>\n        )\n\n      return createComboboxChildren(computedItems, {\n        Group: SelectGroup,\n        Option: SelectOption,\n      })\n    }, [\n      children,\n      computedItems,\n      placeholder,\n      includePlaceholder,\n      placeholderProps,\n    ])\n    const varProps = useInputBorder({ errorBorderColor, focusBorderColor })\n    const comboboxContext = useMemo(\n      () => ({ max, value, onActiveDescendant, onChange, onClose, onSelect }),\n      [max, onActiveDescendant, onChange, onClose, onSelect, value],\n    )\n    const selectContext = useMemo(() => ({ max, value }), [max, value])\n    const componentContext = useMemo(\n      () => ({ getSeparatorProps, groupProps, optionProps }),\n      [getSeparatorProps, groupProps, optionProps],\n    )\n    const hasValue = isArray(value) ? !!value.length : !!value\n\n    return (\n      <ComboboxDescendantsContext value={descendants}>\n        <ComboboxContext value={comboboxContext}>\n          <SelectContext value={selectContext}>\n            <ComponentContext value={componentContext}>\n              <Popover.Root {...mergedPopoverProps}>\n                <InputGroup.Root\n                  className={className}\n                  css={css}\n                  colorScheme={colorScheme}\n                  {...getRootProps({ ...groupItemProps, ...rootProps })}\n                >\n                  <Popover.Trigger>\n                    <SelectField {...getFieldProps(varProps)} />\n                  </Popover.Trigger>\n\n                  <InputGroup.Element\n                    {...{ clickable: clearable && hasValue, ...elementProps }}\n                  >\n                    {clearable && hasValue ? (\n                      <SelectIcon\n                        icon={clearIcon}\n                        {...getClearIconProps(iconProps)}\n                      />\n                    ) : (\n                      <SelectIcon icon={icon} {...getIconProps(iconProps)} />\n                    )}\n                  </InputGroup.Element>\n                </InputGroup.Root>\n\n                <SelectContent\n                  {...cast<SelectContentProps>(\n                    getContentProps(cast<HTMLProps>(contentProps)),\n                  )}\n                >\n                  {computedChildren}\n                </SelectContent>\n              </Popover.Root>\n            </ComponentContext>\n          </SelectContext>\n        </ComboboxContext>\n      </ComboboxDescendantsContext>\n    )\n  },\n  \"root\",\n)((props) => {\n  const context = useInputPropsContext()\n\n  return { ...context, ...props }\n}) as GenericsComponent<{\n  <Multiple extends boolean = false>(\n    props: SelectRootProps<Multiple>,\n  ): ReactElement\n}>\n\ninterface SelectFieldProps extends HTMLStyledProps {}\n\nconst SelectField = withContext<\"div\", SelectFieldProps>(\"div\", \"field\")(\n  { \"data-group-propagate\": \"\" },\n  ({ children, ...rest }) => ({\n    ...rest,\n    children: <SelectValueText>{children}</SelectValueText>,\n  }),\n)\n\ninterface SelectIconProps extends HTMLStyledProps {\n  icon?: ReactNode\n}\n\nconst SelectIcon = withContext<\"div\", SelectIconProps>(\"div\", \"icon\")(\n  undefined,\n  ({ children, icon, ...rest }) => ({\n    children: icon || children || <ChevronDownIcon />,\n    ...rest,\n  }),\n)\n\ninterface SelectValueTextProps extends HTMLProps<\"span\"> {}\n\nconst SelectValueText = withContext<\"span\", SelectValueTextProps>(\n  \"span\",\n  \"valueText\",\n)()\n\ninterface SelectContentProps extends Popover.ContentProps {}\n\nconst SelectContent = withContext<\"div\", SelectContentProps>(\n  Popover.Content,\n  \"content\",\n)()\n\nexport interface SelectLabelProps extends HTMLStyledProps<\"span\"> {}\n\nexport const SelectLabel = withContext<\"span\", SelectLabelProps>(\n  \"span\",\n  \"label\",\n)(undefined, (props) => {\n  const { getLabelProps } = useComboboxGroupContext()\n\n  return getLabelProps(props)\n})\n\nexport interface SelectGroupProps\n  extends UseComboboxGroupProps,\n    HTMLStyledProps {\n  /**\n   * The label of the group.\n   */\n  label?: ReactNode\n  /**\n   * Props for the label component.\n   */\n  labelProps?: SelectLabelProps\n}\n\nexport const SelectGroup = withContext<\"div\", SelectGroupProps>(\n  ({ children, label, labelProps, ...rest }) => {\n    const { groupProps } = useComponentContext()\n    const { getGroupProps, getLabelProps } = useComboboxGroup({\n      ...groupProps,\n      ...rest,\n    })\n    const context = useMemo(() => ({ getLabelProps }), [getLabelProps])\n\n    return (\n      <ComboboxGroupContext value={context}>\n        <styled.div {...getGroupProps()}>\n          {label ? <SelectLabel {...labelProps}>{label}</SelectLabel> : null}\n          {children}\n        </styled.div>\n      </ComboboxGroupContext>\n    )\n  },\n  \"group\",\n)()\n\nexport interface SelectOptionProps\n  extends UseSelectOptionProps,\n    HTMLStyledProps {\n  /**\n   * The icon to be used in the select option.\n   */\n  icon?: ReactNode\n}\n\nexport const SelectOption = withContext<\"div\", SelectOptionProps>(\n  ({ children, icon: iconProp, ...rest }) => {\n    const { optionProps: { icon, ...optionProps } = {} } = useComponentContext()\n    const { getIndicatorProps, getOptionProps } = useSelectOption({\n      ...optionProps,\n      ...rest,\n    })\n\n    return (\n      <styled.div {...getOptionProps()}>\n        <SelectIndicator {...getIndicatorProps()}>\n          {iconProp ?? icon ?? <CheckIcon />}\n        </SelectIndicator>\n        {children}\n      </styled.div>\n    )\n  },\n  \"option\",\n)()\n\ninterface SelectIndicatorProps extends HTMLStyledProps {}\n\nconst SelectIndicator = withContext<\"div\", SelectIndicatorProps>(\n  \"div\",\n  \"indicator\",\n)()\n\nexport interface SelectSeparatorProps extends HTMLStyledProps<\"hr\"> {}\n\nexport const SelectSeparator = withContext<\"hr\", SelectSeparatorProps>(\n  \"hr\",\n  \"separator\",\n)(undefined, (props) => {\n  const { getSeparatorProps } = useComponentContext()\n\n  return getSeparatorProps(props)\n})\n"
    },
    {
      "name": "use-select.tsx",
      "content": "\"use client\"\n\nimport type { MouseEvent, ReactNode } from \"react\"\nimport type { HTMLProps, PropGetter, Dict } from \"@yamada-ui/react\"\nimport type {\n  ComboboxItem,\n  ComboboxItemWithValue,\n  UseComboboxItemProps,\n  UseComboboxProps,\n} from \"../../hooks/use-combobox\"\nimport type { FieldProps } from \"../field\"\nimport { cloneElement, isValidElement, useCallback, useMemo } from \"react\"\nimport { useCombobox, useComboboxItem } from \"../../hooks/use-combobox\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport {\n  createContext,\n  cx,\n  dataAttr,\n  handlerAll,\n  isArray,\n  isNumber,\n  isString,\n  isUndefined,\n  runKeyAction,\n  toArray,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\ninterface SelectRenderProps extends ComboboxItemWithValue {\n  count: number\n  index: number\n  separator: string\n  onClear: () => void\n}\n\nexport interface SelectItemRender {\n  (props: SelectRenderProps): ReactNode\n}\n\nconst defaultRender: SelectItemRender = ({\n  count,\n  index,\n  label,\n  separator,\n  value,\n}) => {\n  const last = count - 1 === index\n\n  return (\n    <span\n      style={{ marginInlineEnd: \"var(--gap)\" }}\n      data-placeholder={dataAttr(value === \"\")}\n    >\n      {label}\n      {!last ? separator : null}\n    </span>\n  )\n}\n\ninterface SelectContext extends Pick<UseSelectReturn, \"max\" | \"value\"> {}\n\nconst [SelectContext, useSelectContext] = createContext<SelectContext>({\n  name: \"SelectContext\",\n})\n\nexport { SelectContext, useSelectContext }\n\nexport interface UseSelectProps<Multiple extends boolean = false>\n  extends Omit<HTMLProps, \"defaultValue\" | \"onChange\" | \"value\">,\n    Omit<\n      UseComboboxProps,\n      \"defaultValue\" | \"initialFocusValue\" | \"onChange\" | \"value\"\n    >,\n    FieldProps {\n  /**\n   * The initial value of the select.\n   */\n  defaultValue?: Multiple extends true ? string[] : string\n  /**\n   * If `true`, include placeholder in options.\n   *\n   * @default true\n   */\n  includePlaceholder?: boolean\n  /**\n   * If provided, generate options based on items.\n   *\n   * @default []\n   */\n  items?: ComboboxItem[]\n  /**\n   * The maximum selectable value.\n   */\n  max?: number\n  /**\n   * If `true`, the select will be multiple.\n   *\n   * @default false\n   */\n  multiple?: Multiple\n  /**\n   * The placeholder for select.\n   */\n  placeholder?: string\n  /**\n   * The function to render the selected items.\n   */\n  render?: (props: SelectRenderProps) => ReactNode\n  /**\n   * The visual separator between each value.\n   *\n   * @default ','\n   */\n  separator?: string\n  /**\n   * The value of the select.\n   */\n  value?: Multiple extends true ? string[] : string\n  /**\n   * The callback invoked when value state changes.\n   */\n  onChange?: (value: Multiple extends true ? string[] : string) => void\n}\n\nexport const useSelect = <Multiple extends boolean = false>(\n  props: UseSelectProps<Multiple> = {},\n) => {\n  type MaybeValue = Multiple extends true ? string[] : string\n\n  const { t } = useI18n(\"select\")\n  const {\n    context: { labelId } = {},\n    props: {\n      multiple = false,\n      closeOnSelect = !multiple,\n      defaultValue = (multiple ? [] : \"\") as MaybeValue,\n      disabled,\n      includePlaceholder = !multiple,\n      items: itemProp = [],\n      max,\n      placeholder,\n      readOnly,\n      render = defaultRender,\n      separator = \",\",\n      value: valueProp,\n      onChange: onChangeProp,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const onChange = useCallback(\n    (value: string) => {\n      setValue((prev) => {\n        if (isArray(prev)) {\n          if (prev.includes(value)) {\n            return prev.filter((prevValue) => prevValue !== value) as MaybeValue\n          } else if (!isNumber(max) || prev.length < max) {\n            return [...prev, value] as MaybeValue\n          } else {\n            return prev\n          }\n        } else {\n          return value as MaybeValue\n        }\n      })\n    },\n    [max, setValue],\n  )\n  const items = useMemo<ComboboxItem[]>(() => {\n    const items = [...itemProp]\n\n    if (placeholder)\n      items.unshift({\n        hidden: !includePlaceholder,\n        label: placeholder,\n        value: \"\",\n      })\n\n    return items\n  }, [itemProp, placeholder, includePlaceholder])\n  const empty = useMemo(\n    () => !items.filter(({ hidden }) => !hidden).length,\n    [items],\n  )\n  const {\n    descendants,\n    interactive,\n    open,\n    getContentProps: getComboboxContentProps,\n    getSeparatorProps,\n    getTriggerProps,\n    onActiveDescendant,\n    onClose,\n    onOpen,\n    onSelect,\n  } = useCombobox({\n    closeOnSelect,\n    disabled,\n    initialFocusValue: isArray(value) ? value[0] : value,\n    readOnly,\n    onChange,\n    ...ariaProps,\n    ...dataProps,\n    ...eventProps,\n    ...rest,\n  })\n  const valueMap = useMemo<{ [key: string]: ComboboxItemWithValue }>(() => {\n    const valueMap: { [key: string]: ComboboxItemWithValue } = {}\n\n    items.forEach((item) => {\n      if (\"items\" in item) {\n        item.items.forEach((item) => {\n          item.value ??= isString(item.label) ? item.label : undefined\n\n          if (!isUndefined(item.value)) valueMap[item.value] = item\n        })\n      } else {\n        item.value ??= isString(item.label) ? item.label : undefined\n\n        if (!isUndefined(item.value)) valueMap[item.value] = item\n      }\n    })\n\n    return valueMap\n  }, [items])\n  const selectedItems = useMemo<ComboboxItemWithValue[]>(() => {\n    if (isArray(value)) {\n      if (value.length) {\n        return toArray(value.map((value) => valueMap[value]))\n      } else {\n        return placeholder ? [{ label: placeholder, value: \"\" }] : []\n      }\n    } else {\n      return isString(value) ? toArray(valueMap[value]) : []\n    }\n  }, [placeholder, value, valueMap])\n  const children = useMemo<ReactNode>(() => {\n    const count = selectedItems.length\n\n    return selectedItems.map((item, index) => {\n      const onClear = (ev?: MouseEvent<HTMLElement>) => {\n        ev?.preventDefault()\n        ev?.stopPropagation()\n\n        if (item.value) onChange(item.value)\n      }\n\n      const component = render({\n        count,\n        index,\n        separator,\n        onClear,\n        ...item,\n      })\n\n      if (isValidElement<Dict>(component)) {\n        return cloneElement(component, { ...component.props, key: index })\n      } else {\n        return component\n      }\n    })\n  }, [onChange, render, selectedItems, separator])\n\n  const onClear = useCallback(() => {\n    setValue((prev) => (isArray(prev) ? [] : \"\") as MaybeValue)\n  }, [setValue])\n\n  const getRootProps: PropGetter = useCallback(\n    (props) => ({ ...dataProps, ...props }),\n    [dataProps],\n  )\n\n  const getFieldProps: PropGetter = useCallback(\n    ({ \"aria-labelledby\": ariaLabelledby, ...props } = {}) =>\n      getTriggerProps({\n        \"aria-label\": placeholder,\n        \"aria-labelledby\": cx(ariaLabelledby, labelId),\n        ...props,\n        children,\n      }),\n    [children, getTriggerProps, labelId, placeholder],\n  )\n\n  const getContentProps: PropGetter = useCallback(\n    (props) => getComboboxContentProps({ hidden: empty, ...props }),\n    [empty, getComboboxContentProps],\n  )\n\n  const getIconProps: PropGetter = useCallback(\n    (props) => ({ ...dataProps, ...props }),\n    [dataProps],\n  )\n\n  const getClearIconProps: PropGetter = useCallback(\n    (props = {}) =>\n      getIconProps({\n        \"aria-label\": t(\"Clear value\"),\n        role: \"button\",\n        tabIndex: 0,\n        ...props,\n        onClick: handlerAll(props.onClick, onClear),\n        onKeyDown: handlerAll(props.onKeyDown, (ev) =>\n          runKeyAction(ev, { Enter: onClear, Space: onClear }),\n        ),\n      }),\n    [getIconProps, onClear, t],\n  )\n\n  return {\n    descendants,\n    includePlaceholder,\n    interactive,\n    items,\n    max,\n    open,\n    placeholder,\n    setValue,\n    value,\n    valueMap,\n    getClearIconProps,\n    getContentProps,\n    getFieldProps,\n    getIconProps,\n    getRootProps,\n    getSeparatorProps,\n    onActiveDescendant,\n    onChange,\n    onClose,\n    onOpen,\n    onSelect,\n  }\n}\n\nexport type UseSelectReturn = ReturnType<typeof useSelect>\n\nexport interface UseSelectOptionProps extends UseComboboxItemProps {}\n\nexport const useSelectOption = ({\n  children,\n  closeOnSelect,\n  disabled,\n  hidden,\n  value,\n  ...rest\n}: UseSelectOptionProps = {}) => {\n  const { max, value: selectedValue } = useSelectContext()\n\n  value ??= isString(children) ? children : undefined\n\n  const selected = isArray(selectedValue)\n    ? !isUndefined(value) && selectedValue.includes(value)\n    : selectedValue === value\n  const completed =\n    isNumber(max) && isArray(selectedValue) && selectedValue.length >= max\n  const { getIndicatorProps, getItemProps } = useComboboxItem({\n    children,\n    closeOnSelect,\n    disabled: disabled || hidden || (completed && !selected),\n    hidden,\n    selected,\n    value,\n    ...rest,\n  })\n\n  const getOptionProps: PropGetter = useCallback(\n    (props = {}) => getItemProps(props),\n    [getItemProps],\n  )\n\n  return { getIndicatorProps, getOptionProps }\n}\n\nexport type UseSelectOptionReturn = ReturnType<typeof useSelectOption>\n"
    }
  ]
}
