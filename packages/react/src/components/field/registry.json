{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["fieldset"],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "dependents": {
    "components": [
      "autocomplete",
      "calendar",
      "checkbox",
      "color-picker",
      "date-picker",
      "dropzone",
      "editable",
      "fieldset",
      "file-button",
      "file-input",
      "input",
      "native-select",
      "number-input",
      "password-input",
      "pin-input",
      "radio",
      "rating",
      "saturation-slider",
      "segmented-control",
      "select",
      "slider",
      "switch",
      "textarea",
      "toggle"
    ],
    "hooks": [],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "field.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const fieldStyle = defineComponentSlotStyle({\n  base: {\n    errorMessage: {\n      alignItems: \"center\",\n      color: \"fg.error\",\n      display: \"inline-flex\",\n      fontSize: \"xs\",\n      gap: \"1\",\n    },\n    helperMessage: {\n      alignItems: \"center\",\n      color: \"fg.muted\",\n      display: \"inline-flex\",\n      fontSize: \"xs\",\n      gap: \"1\",\n    },\n    label: {\n      alignItems: \"center\",\n      display: \"inline-flex\",\n      fontSize: \"sm\",\n      fontWeight: \"medium\",\n      gap: \"1\",\n      _readOnly: { pointerEvents: \"none\" },\n      _disabled: { layerStyle: \"disabled\" },\n    },\n    requiredIndicator: {\n      color: \"fg.error\",\n    },\n    root: {\n      display: \"grid\",\n      gap: \"1.5\",\n      position: \"relative\",\n      w: \"100%\",\n    },\n  },\n\n  props: {\n    /**\n     * The orientation of the field.\n     */\n    orientation: {\n      horizontal: {\n        errorMessage: { gridColumn: \"2 / 3\" },\n        helperMessage: { gridColumn: \"2 / 3\" },\n        label: { gridColumn: \"1 / 2\" },\n        root: { gridTemplateColumns: \"{field-label-width, spaces.32} 1fr\" },\n      },\n      vertical: {\n        errorMessage: { gridColumn: \"initial\" },\n        helperMessage: { gridColumn: \"initial\" },\n        label: { gridColumn: \"initial\" },\n        root: { gridTemplateColumns: \"initial\" },\n      },\n    },\n  },\n\n  defaultProps: {\n    orientation: \"vertical\",\n  },\n})\n\nexport type FieldStyle = typeof fieldStyle\n"
    },
    {
      "name": "field.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport type { HTMLStyledProps, ThemeProps } from \"@yamada-ui/react\"\nimport type { FieldStyle } from \"./field.style\"\nimport { isValidElement, useId, useMemo, useState } from \"react\"\nimport {\n  createSlotComponent,\n  styled,\n  createContext,\n  dataAttr,\n  useSplitChildren,\n} from \"@yamada-ui/react\"\nimport { useFieldsetContext } from \"../fieldset\"\nimport { fieldStyle } from \"./field.style\"\n\nexport interface FieldContext\n  extends FieldProps,\n    Pick<FieldRootProps, \"replace\"> {\n  id: string\n  errorMessageId: string\n  focused: boolean\n  helperMessageId: string\n  labelId: string\n  onBlur: () => void\n  onFocus: () => void\n}\n\nconst [FieldContext, useFieldContext] = createContext<FieldContext>({\n  name: \"FieldContext\",\n  strict: false,\n})\n\nexport { FieldContext, useFieldContext }\n\nexport interface FieldProps {\n  /**\n   * If `true`, the field will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * If `true`, the field will be invalid.\n   *\n   * @default false\n   */\n  invalid?: boolean\n  /**\n   * If `true`, the field will be readonly.\n   *\n   * @default false\n   */\n  readOnly?: boolean\n  /**\n   * If `true`, the field will be required.\n   *\n   * @default false\n   */\n  required?: boolean\n}\n\nexport interface FieldRootProps\n  extends HTMLStyledProps,\n    ThemeProps<FieldStyle>,\n    Pick<FieldLabelProps, \"optionalIndicator\" | \"requiredIndicator\">,\n    FieldProps {\n  /**\n   * The field error message to use.\n   */\n  errorMessage?: ReactNode\n  /**\n   * The field helper message to use.\n   */\n  helperMessage?: ReactNode\n  /**\n   * The field label to use.\n   */\n  label?: ReactNode\n  /**\n   * If `true`, switch between helper message and error message using invalid.\n   *\n   * @default true\n   */\n  replace?: boolean\n  /**\n   * Props the error message component.\n   */\n  errorMessageProps?: FieldErrorMessageProps\n  /**\n   * Props the helper message component.\n   */\n  helperMessageProps?: FieldHelperMessageProps\n  /**\n   * Props the label component.\n   */\n  labelProps?: FieldLabelProps\n}\n\nconst {\n  PropsContext: FieldPropsContext,\n  usePropsContext: useFieldPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<FieldRootProps, FieldStyle>(\"field\", fieldStyle)\n\nexport { FieldPropsContext, useFieldPropsContext }\n\n/**\n * `Field` is a component used to group form elements with label, helper message, error message, etc.\n *\n * @see https://yamada-ui.com/docs/components/field\n */\nexport const FieldRoot = withProvider<\"div\", FieldRootProps>(\n  ({\n    id,\n    children,\n    disabled,\n    errorMessage,\n    helperMessage,\n    invalid,\n    label,\n    optionalIndicator,\n    readOnly,\n    replace = true,\n    required,\n    requiredIndicator,\n    errorMessageProps,\n    helperMessageProps,\n    labelProps,\n    ...rest\n  }) => {\n    const uuid = useId()\n    const labelId = useId()\n    const helperMessageId = useId()\n    const errorMessageId = useId()\n    const [focused, setFocused] = useState<boolean>(false)\n    const [\n      omittedChildren,\n      customLabel,\n      customHelperMessage,\n      customErrorMessage,\n    ] = useSplitChildren(\n      children,\n      FieldLabel,\n      FieldHelperMessage,\n      FieldErrorMessage,\n    )\n\n    id ??= uuid\n\n    const context = useMemo(\n      () => ({\n        id,\n        disabled,\n        errorMessageId,\n        focused,\n        helperMessageId,\n        invalid,\n        labelId,\n        readOnly,\n        replace,\n        required,\n        onBlur: () => setFocused(false),\n        onFocus: () => setFocused(true),\n      }),\n      [\n        id,\n        disabled,\n        labelId,\n        focused,\n        invalid,\n        helperMessageId,\n        errorMessageId,\n        readOnly,\n        replace,\n        required,\n      ],\n    )\n\n    return (\n      <FieldContext value={context}>\n        <styled.div\n          data-disabled={dataAttr(disabled)}\n          data-focus={dataAttr(focused)}\n          data-invalid={dataAttr(invalid)}\n          data-readonly={dataAttr(readOnly)}\n          {...rest}\n        >\n          {customLabel ||\n            (label ? (\n              <FieldLabel\n                optionalIndicator={optionalIndicator}\n                requiredIndicator={requiredIndicator}\n                {...labelProps}\n              >\n                {label}\n              </FieldLabel>\n            ) : null)}\n\n          {omittedChildren}\n\n          {customHelperMessage ||\n            (helperMessage ? (\n              <FieldHelperMessage {...helperMessageProps}>\n                {helperMessage}\n              </FieldHelperMessage>\n            ) : null)}\n\n          {customErrorMessage ||\n            (errorMessage ? (\n              <FieldErrorMessage {...errorMessageProps}>\n                {errorMessage}\n              </FieldErrorMessage>\n            ) : null)}\n        </styled.div>\n      </FieldContext>\n    )\n  },\n  \"root\",\n)()\n\nexport interface FieldLabelProps extends HTMLStyledProps<\"label\"> {\n  /**\n   * The optional indicator to use.\n   */\n  optionalIndicator?: ReactNode\n  /**\n   * If `true`, the field will be required.\n   *\n   * @default false\n   */\n  required?: boolean\n  /**\n   * The required indicator to use.\n   */\n  requiredIndicator?: ReactNode\n}\n\nexport const FieldLabel = withContext<\"label\", FieldLabelProps>(\n  ({\n    id,\n    htmlFor,\n    children,\n    optionalIndicator = null,\n    required,\n    requiredIndicator = null,\n    ...rest\n  }) => {\n    const fieldsetContext = useFieldsetContext()\n    const fieldContext = useFieldContext()\n\n    id ??= fieldContext?.labelId\n    htmlFor ??= fieldContext?.id\n    required ??= fieldContext?.required ?? fieldsetContext?.required\n\n    const disabled = fieldContext?.disabled ?? fieldsetContext?.disabled\n    const invalid = fieldContext?.invalid ?? fieldsetContext?.invalid\n    const readOnly = fieldContext?.readOnly ?? fieldsetContext?.readOnly\n    const focused = fieldContext?.focused\n\n    return (\n      <styled.label\n        id={id}\n        htmlFor={htmlFor}\n        data-disabled={dataAttr(disabled)}\n        data-focus={dataAttr(focused)}\n        data-invalid={dataAttr(invalid)}\n        data-readonly={dataAttr(readOnly)}\n        {...rest}\n      >\n        {children}\n\n        {required ? (\n          requiredIndicator ? (\n            <FieldRequiredIndicator>{requiredIndicator}</FieldRequiredIndicator>\n          ) : (\n            <FieldRequiredIndicator />\n          )\n        ) : (\n          optionalIndicator\n        )}\n      </styled.label>\n    )\n  },\n  \"label\",\n)()\n\ninterface FieldRequiredIndicatorProps extends HTMLStyledProps<\"span\"> {}\n\nconst FieldRequiredIndicator = withContext<\"span\", FieldRequiredIndicatorProps>(\n  ({ children, ...rest }) => {\n    if (!isValidElement(children)) {\n      return (\n        <styled.span aria-hidden role=\"presentation\" {...rest}>\n          {children ?? <>*</>}\n        </styled.span>\n      )\n    } else {\n      return children\n    }\n  },\n  \"requiredIndicator\",\n)()\n\nexport interface FieldHelperMessageProps extends HTMLStyledProps<\"span\"> {}\n\nexport const FieldHelperMessage = withContext<\"span\", FieldHelperMessageProps>(\n  (props) => {\n    const fieldsetContext = useFieldsetContext()\n    const {\n      helperMessageId,\n      invalid = fieldsetContext?.invalid,\n      replace,\n    } = useFieldContext() ?? {}\n\n    return (\n      <styled.span\n        id={helperMessageId}\n        hidden={replace && invalid ? true : false}\n        {...props}\n      />\n    )\n  },\n  \"helperMessage\",\n)()\n\nexport interface FieldErrorMessageProps extends HTMLStyledProps<\"span\"> {}\n\nexport const FieldErrorMessage = withContext<\"span\", FieldErrorMessageProps>(\n  (props) => {\n    const fieldsetContext = useFieldsetContext()\n    const { errorMessageId, invalid = fieldsetContext?.invalid } =\n      useFieldContext() ?? {}\n\n    return (\n      <styled.span\n        id={errorMessageId}\n        aria-live={invalid ? \"polite\" : undefined}\n        hidden={!invalid}\n        {...props}\n      />\n    )\n  },\n  \"errorMessage\",\n)()\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./field.style\"\nexport {\n  FieldErrorMessage,\n  FieldHelperMessage,\n  FieldLabel,\n  FieldPropsContext,\n  FieldRoot,\n  useFieldPropsContext,\n} from \"./field\"\nexport type {\n  FieldErrorMessageProps,\n  FieldHelperMessageProps,\n  FieldLabelProps,\n  FieldProps,\n  FieldRootProps,\n} from \"./field\"\nexport * as Field from \"./namespace\"\nexport * from \"./use-field-props\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  FieldErrorMessage as ErrorMessage,\n  FieldHelperMessage as HelperMessage,\n  FieldLabel as Label,\n  FieldPropsContext as PropsContext,\n  FieldRoot as Root,\n  useFieldPropsContext as usePropsContext,\n} from \"./field\"\nexport type {\n  FieldErrorMessageProps as ErrorMessageProps,\n  FieldHelperMessageProps as HelperMessageProps,\n  FieldLabelProps as LabelProps,\n  FieldRootProps as RootProps,\n} from \"./field\"\n"
    },
    {
      "name": "use-field-props.ts",
      "content": "\"use client\"\n\nimport type { FocusEventHandler } from \"react\"\nimport type { Dict } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"./field\"\nimport { useMemo, useState } from \"react\"\nimport {\n  useEnvironment,\n  ariaAttr,\n  cx,\n  dataAttr,\n  handlerAll,\n  useSafeLayoutEffect,\n} from \"@yamada-ui/react\"\nimport { useFieldsetContext } from \"../fieldset\"\nimport { useFieldContext } from \"./field\"\n\nexport interface UseFieldProps<Y extends HTMLElement> extends FieldProps {\n  id?: string\n  notSupportReadOnly?: boolean\n  onBlur?: FocusEventHandler<Y>\n  onFocus?: FocusEventHandler<Y>\n}\n\nexport const useFieldProps = <Y extends HTMLElement, M extends Dict>(\n  {\n    id,\n    \"aria-describedby\": ariaDescribedby,\n    disabled,\n    invalid,\n    notSupportReadOnly,\n    readOnly,\n    required,\n    onBlur,\n    onFocus,\n    ...rest\n  }: M & UseFieldProps<Y> = {} as M & UseFieldProps<Y>,\n) => {\n  const { getDocument } = useEnvironment()\n  const fieldsetContext = useFieldsetContext()\n  const fieldContext = useFieldContext()\n  const [errorMessageId, setErrorMessageId] = useState<string | undefined>(\n    undefined,\n  )\n  const [helperMessageId, setHelperMessageId] = useState<string | undefined>(\n    undefined,\n  )\n\n  id ??= fieldContext?.id\n  disabled ??= fieldContext?.disabled ?? fieldsetContext?.disabled\n  required ??= fieldContext?.required ?? fieldsetContext?.required\n  readOnly ??= fieldContext?.readOnly ?? fieldsetContext?.readOnly\n  invalid ??= fieldContext?.invalid ?? fieldsetContext?.invalid\n\n  useSafeLayoutEffect(() => {\n    const hasErrorMessage =\n      !!fieldContext?.errorMessageId &&\n      !!getDocument()?.getElementById(fieldContext.errorMessageId)\n    const hasHelperMessage =\n      !!fieldContext?.helperMessageId &&\n      !!getDocument()?.getElementById(fieldContext.helperMessageId)\n\n    setErrorMessageId(\n      invalid && hasErrorMessage ? fieldContext.errorMessageId : undefined,\n    )\n    setHelperMessageId(\n      (!fieldContext?.replace || !invalid) && hasHelperMessage\n        ? fieldContext.helperMessageId\n        : undefined,\n    )\n  }, [\n    fieldContext?.errorMessageId,\n    fieldContext?.helperMessageId,\n    fieldContext?.replace,\n    invalid,\n  ])\n\n  const props = useMemo(\n    () => ({\n      id,\n      disabled,\n      readOnly,\n      required,\n      ...rest,\n    }),\n    [id, disabled, readOnly, required, rest],\n  )\n  const dataProps = useMemo(\n    () => ({\n      \"data-disabled\": dataAttr(disabled),\n      \"data-invalid\": dataAttr(invalid),\n      \"data-readonly\": dataAttr(readOnly),\n      \"data-required\": dataAttr(required),\n    }),\n    [disabled, invalid, readOnly, required],\n  )\n  const ariaProps = useMemo(\n    () => ({\n      \"aria-describedby\": cx(errorMessageId, helperMessageId, ariaDescribedby),\n      \"aria-disabled\": ariaAttr(\n        notSupportReadOnly ? readOnly || disabled : disabled,\n      ),\n      \"aria-invalid\": ariaAttr(invalid),\n      \"aria-readonly\": notSupportReadOnly ? undefined : ariaAttr(readOnly),\n      \"aria-required\": ariaAttr(required),\n    }),\n    [\n      errorMessageId,\n      helperMessageId,\n      ariaDescribedby,\n      notSupportReadOnly,\n      readOnly,\n      disabled,\n      invalid,\n      required,\n    ],\n  )\n  const eventProps = useMemo(\n    () => ({\n      onBlur: handlerAll(fieldContext?.onBlur, onBlur),\n      onFocus: handlerAll(fieldContext?.onFocus, onFocus),\n    }),\n    [fieldContext?.onBlur, fieldContext?.onFocus, onBlur, onFocus],\n  )\n\n  return {\n    context: fieldContext,\n    props,\n    ariaProps,\n    dataProps,\n    eventProps,\n  }\n}\n\nexport const resetFieldProps = {\n  disabled: false,\n  invalid: false,\n  readOnly: false,\n  required: false,\n}\n"
    }
  ]
}
