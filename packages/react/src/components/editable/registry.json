{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["input", "field"],
    "externals": [],
    "hooks": ["use-controllable-state", "use-focus"],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "editable.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const editableStyle = defineComponentSlotStyle({\n  base: {\n    control: {\n      alignItems: \"start\",\n      display: \"inline-flex\",\n      gap: \"sm\",\n    },\n    input: {\n      bg: \"transparent\",\n      focusRingColor: \"{focus-border-color}\",\n      focusVisibleRing: \"inside\",\n      fontSize: \"inherit\",\n      fontWeight: \"inherit\",\n      minH: \"1lh\",\n      p: \"1\",\n      rounded: \"l2\",\n      textAlign: \"inherit\",\n      transitionDuration: \"moderate\",\n      transitionProperty: \"common\",\n      w: \"full\",\n      _invalid: {\n        borderColor: \"{error-border-color}\",\n        focusRingColor: \"{error-border-color}\",\n      },\n      _disabled: {\n        layerStyle: \"disabled\",\n      },\n    },\n    preview: {\n      bg: \"transparent\",\n      cursor: \"text\",\n      display: \"inline-block\",\n      fontSize: \"inherit\",\n      fontWeight: \"inherit\",\n      minH: \"1lh\",\n      p: \"1\",\n      rounded: \"l2\",\n      textAlign: \"inherit\",\n      transitionDuration: \"moderate\",\n      transitionProperty: \"common\",\n      whiteSpace: \"pre-line\",\n      _hover: {\n        bg: \"bg.subtle\",\n      },\n      _readOnly: {\n        pointerEvents: \"none\",\n      },\n      _disabled: {\n        layerStyle: \"disabled\",\n      },\n    },\n    root: {\n      \"--error-border-color\": \"colors.border.error\",\n      \"--focus-border-color\": \"colorScheme.outline\",\n      alignItems: \"start\",\n      display: \"inline-flex\",\n      gap: \"sm\",\n      position: \"relative\",\n      w: \"full\",\n    },\n    textarea: {\n      bg: \"transparent\",\n      boxSizing: \"content-box\",\n      focusRingColor: \"{focus-border-color}\",\n      focusVisibleRing: \"inside\",\n      fontSize: \"inherit\",\n      fontWeight: \"inherit\",\n      minH: \"1lh\",\n      p: \"1\",\n      rounded: \"l2\",\n      textAlign: \"inherit\",\n      transitionDuration: \"moderate\",\n      transitionProperty: \"common\",\n      w: \"full\",\n      _invalid: {\n        borderColor: \"{error-border-color}\",\n        focusRingColor: \"{error-border-color}\",\n      },\n      _disabled: {\n        layerStyle: \"disabled\",\n      },\n    },\n  },\n})\n\nexport type EditableStyle = typeof editableStyle\n"
    },
    {
      "name": "editable.tsx",
      "content": "\"use client\"\n\nimport type {\n  HTMLStyledProps,\n  ThemeProps,\n  ReactNodeOrFunction,\n} from \"@yamada-ui/react\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { EditableStyle } from \"./editable.style\"\nimport type { UseEditableProps, UseEditableReturn } from \"./use-editable\"\nimport { createSlotComponent, styled, runIfFn } from \"@yamada-ui/react\"\nimport { useInputBorder } from \"../input\"\nimport { editableStyle } from \"./editable.style\"\nimport {\n  EditableContext,\n  useEditable,\n  useEditableContext,\n} from \"./use-editable\"\n\ninterface EditableElementProps\n  extends Pick<\n    UseEditableReturn,\n    \"editing\" | \"onCancel\" | \"onEdit\" | \"onSubmit\"\n  > {}\n\nexport interface EditableRootProps\n  extends Omit<\n      HTMLStyledProps,\n      \"children\" | \"defaultValue\" | \"onChange\" | \"onSubmit\" | \"value\"\n    >,\n    ThemeProps<EditableStyle>,\n    UseInputBorderProps,\n    UseEditableProps {\n  /**\n   * The editable children to use.\n   */\n  children?: ReactNodeOrFunction<EditableElementProps>\n}\n\nconst {\n  PropsContext: EditablePropsContext,\n  usePropsContext: useEditablePropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<EditableRootProps, EditableStyle>(\n  \"editable\",\n  editableStyle,\n)\n\nexport { EditablePropsContext, useEditablePropsContext }\n\n/**\n * `Editable` is a component used to obtain inline editable text input.\n *\n * @see https://yamada-ui.com/components/editable\n */\nexport const EditableRoot = withProvider(\n  ({ children, errorBorderColor, focusBorderColor, ...props }) => {\n    const {\n      editing,\n      value: _value,\n      getRootProps,\n      onCancel,\n      onEdit,\n      onSubmit,\n      ...rest\n    } = useEditable(props)\n    const varProps = useInputBorder({ errorBorderColor, focusBorderColor })\n    const cloneChildren = runIfFn(children, {\n      editing,\n      onCancel,\n      onEdit,\n      onSubmit,\n    })\n\n    return (\n      <EditableContext value={{ editing, ...rest }}>\n        <styled.div {...getRootProps()} {...varProps}>\n          {cloneChildren}\n        </styled.div>\n      </EditableContext>\n    )\n  },\n)()\n\nexport interface EditablePreviewProps extends HTMLStyledProps<\"span\"> {}\n\nexport const EditablePreview = withContext<\"span\", EditablePreviewProps>(\n  \"span\",\n  \"preview\",\n)(undefined, (props) => {\n  const { getPreviewProps } = useEditableContext()\n\n  return { ...getPreviewProps(props) }\n})\n\nexport interface EditableInputProps extends HTMLStyledProps<\"input\"> {}\n\nexport const EditableInput = withContext<\"input\", EditableInputProps>(\n  \"input\",\n  \"input\",\n)(undefined, (props) => {\n  const { getInputProps } = useEditableContext()\n\n  return { ...getInputProps(props) }\n})\n\nexport interface EditableTextareaProps extends HTMLStyledProps<\"textarea\"> {}\n\nexport const EditableTextarea = withContext<\"textarea\", EditableTextareaProps>(\n  \"textarea\",\n  \"textarea\",\n)(undefined, (props) => {\n  const { getTextareaProps } = useEditableContext()\n\n  return { ...getTextareaProps(props) }\n})\n\nexport interface EditableControlProps extends HTMLStyledProps {}\n\nexport const EditableControl = withContext<\"div\", EditableControlProps>(\n  \"div\",\n  \"control\",\n)(undefined, (props) => {\n  const { getControlProps } = useEditableContext()\n\n  return { ...getControlProps(props) }\n})\n\nexport interface EditableEditTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const EditableEditTrigger = withContext<\n  \"button\",\n  EditableEditTriggerProps\n>(\"button\", { name: \"EditTrigger\", slot: [\"trigger\", \"edit\"] })(\n  undefined,\n  (props) => {\n    const { getEditProps } = useEditableContext()\n\n    return { asChild: true, ...getEditProps(props) }\n  },\n)\n\nexport interface EditableCancelTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const EditableCancelTrigger = withContext<\n  \"button\",\n  EditableCancelTriggerProps\n>(\"button\", { name: \"CancelTrigger\", slot: [\"trigger\", \"cancel\"] })(\n  undefined,\n  (props) => {\n    const { getCancelProps } = useEditableContext()\n\n    return { asChild: true, ...getCancelProps(props) }\n  },\n)\n\nexport interface EditableSubmitTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const EditableSubmitTrigger = withContext<\n  \"button\",\n  EditableSubmitTriggerProps\n>(\"button\", { name: \"SubmitTrigger\", slot: [\"trigger\", \"submit\"] })(\n  undefined,\n  (props) => {\n    const { getSubmitProps } = useEditableContext()\n\n    return { asChild: true, ...getSubmitProps(props) }\n  },\n)\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./editable.style\"\nexport {\n  EditableCancelTrigger,\n  EditableControl,\n  EditableEditTrigger,\n  EditableInput,\n  EditablePreview,\n  EditablePropsContext,\n  EditableRoot,\n  EditableSubmitTrigger,\n  EditableTextarea,\n  useEditablePropsContext,\n} from \"./editable\"\nexport type {\n  EditableCancelTriggerProps,\n  EditableControlProps,\n  EditableEditTriggerProps,\n  EditableInputProps,\n  EditablePreviewProps,\n  EditableRootProps,\n  EditableSubmitTriggerProps,\n  EditableTextareaProps,\n} from \"./editable\"\nexport * as Editable from \"./namespace\"\nexport * from \"./use-editable\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  EditableCancelTrigger as CancelTrigger,\n  EditableControl as Control,\n  EditableEditTrigger as EditTrigger,\n  EditableInput as Input,\n  EditablePreview as Preview,\n  EditablePropsContext as PropsContext,\n  EditableRoot as Root,\n  EditableSubmitTrigger as SubmitTrigger,\n  EditableTextarea as Textarea,\n  useEditablePropsContext as usePropsContext,\n} from \"./editable\"\nexport type {\n  EditableCancelTriggerProps as CancelTriggerProps,\n  EditableControlProps as ControlProps,\n  EditableEditTriggerProps as EditTriggerProps,\n  EditableInputProps as InputProps,\n  EditablePreviewProps as PreviewProps,\n  EditableRootProps as RootProps,\n  EditableSubmitTriggerProps as SubmitTriggerProps,\n  EditableTextareaProps as TextareaProps,\n} from \"./editable\"\nexport {\n  EditableContext as Context,\n  useEditableContext as useContext,\n} from \"./use-editable\"\n"
    },
    {
      "name": "use-editable.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent, FocusEvent, KeyboardEvent } from \"react\"\nimport type { PropGetter } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { useFocusOnPointerDown } from \"../../hooks/use-focus\"\nimport {\n  contains,\n  createContext,\n  handlerAll,\n  mergeRefs,\n  useCallbackRef,\n  useSafeLayoutEffect,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\ninterface EditableContext\n  extends Omit<\n    UseEditableReturn,\n    \"getRootProps\" | \"onCancel\" | \"onEdit\" | \"onSubmit\" | \"value\"\n  > {}\n\nconst [EditableContext, useEditableContext] = createContext<EditableContext>({\n  name: \"EditableContext\",\n})\n\nexport { EditableContext, useEditableContext }\n\nexport interface UseEditableProps extends FieldProps {\n  /**\n   * The initial value of the Editable in both edit & preview mode.\n   */\n  defaultValue?: string\n  /**\n   * The placeholder text when the value is empty.\n   */\n  placeholder?: string\n  /**\n   * If `true`, the read only view, has a `tabIndex` set to `0`\n   * so it can receive focus via the keyboard or click.\n   *\n   * @default true\n   */\n  previewFocusable?: boolean\n  /**\n   * If `true`, the input's text will be highlighted on focus.\n   *\n   * @default true\n   */\n  selectAllOnFocus?: boolean\n  /**\n   * If `true`, the Editable will start with edit mode by default.\n   */\n  startWithEditView?: boolean\n  /**\n   * If `true`, it'll update the value onBlur and turn off the edit mode.\n   *\n   * @default true\n   */\n  submitOnBlur?: boolean\n  /**\n   * The value of the Editable in both edit & preview mode.\n   */\n  value?: string\n  /**\n   * Callback invoked when user cancels input with the `Esc` key.\n   * It provides the last confirmed value as argument.\n   */\n  onCancel?: (preValue: string) => void\n  /**\n   * A callback invoked when user changes input.\n   */\n  onChange?: (value: string) => void\n  /**\n   * A callback invoked once the user enters edit mode.\n   */\n  onEdit?: () => void\n  /**\n   * A callback invoked when user confirms value with `enter` key or by blurring input.\n   */\n  onSubmit?: (value: string) => void\n}\n\nexport const useEditable = (props: UseEditableProps = {}) => {\n  const {\n    props: {\n      id,\n      defaultValue,\n      disabled,\n      placeholder,\n      previewFocusable = true,\n      readOnly,\n      required,\n      selectAllOnFocus = true,\n      startWithEditView,\n      submitOnBlur = true,\n      value: valueProp,\n      onCancel: onCancelProp,\n      onChange: onChangeProp,\n      onEdit: onEditProp,\n      onSubmit: onSubmitProp,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const onEditRef = useCallbackRef(onEditProp)\n  const [editing, setEditing] = useState<boolean>(\n    !!startWithEditView && !disabled,\n  )\n  const [value, setValue] = useControllableState({\n    defaultValue: defaultValue || \"\",\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const interactive = !editing && !disabled\n  const emptyValue = value.length === 0\n  const [prevValue, setPrevValue] = useState(value)\n  const inputRef = useRef<HTMLInputElement | HTMLTextAreaElement>(null)\n  const previewRef = useRef<HTMLElement>(null)\n  const editRef = useRef<HTMLButtonElement>(null)\n  const cancelRef = useRef<HTMLButtonElement>(null)\n  const submitRef = useRef<HTMLButtonElement>(null)\n\n  const onChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) =>\n      setValue(ev.currentTarget.value),\n    [setValue],\n  )\n\n  const onUpdatePrevValue = useCallback(() => setPrevValue(value), [value])\n\n  const onEdit = useCallback(() => {\n    if (interactive) setEditing(true)\n  }, [interactive])\n\n  const onCancel = useCallback(() => {\n    setEditing(false)\n    setValue(prevValue)\n    onCancelProp?.(prevValue)\n  }, [prevValue, onCancelProp, setValue])\n\n  const onSubmit = useCallback(() => {\n    setEditing(false)\n    setPrevValue(value)\n    onSubmitProp?.(value)\n  }, [onSubmitProp, value])\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent) => {\n      if (ev.key !== \"Escape\" && ev.key !== \"Enter\") return\n\n      ev.preventDefault()\n\n      if (ev.key === \"Escape\") {\n        onCancel()\n      } else {\n        const { metaKey, shiftKey } = ev\n\n        if (!shiftKey && !metaKey) onSubmit()\n      }\n    },\n    [onCancel, onSubmit],\n  )\n\n  const onKeyDownWithoutSubmit = useCallback(\n    (ev: KeyboardEvent) => {\n      if (ev.key !== \"Escape\") return\n\n      ev.preventDefault()\n      onCancel()\n    },\n    [onCancel],\n  )\n\n  const onBlur = useCallback(\n    (ev: FocusEvent) => {\n      if (!editing) return\n\n      const ownerDocument = ev.currentTarget.ownerDocument\n      const relatedTarget = (ev.relatedTarget ??\n        ownerDocument.activeElement) as HTMLElement\n      const targetIsCancel = contains(cancelRef.current, relatedTarget)\n      const targetIsSubmit = contains(submitRef.current, relatedTarget)\n      const validBlur = !targetIsCancel && !targetIsSubmit\n\n      if (!validBlur) return\n\n      if (submitOnBlur) {\n        onSubmit()\n      } else {\n        onCancel()\n      }\n    },\n    [editing, submitOnBlur, onSubmit, onCancel],\n  )\n\n  useFocusOnPointerDown({\n    ref: inputRef,\n    elements: [cancelRef, submitRef],\n    enabled: editing,\n  })\n\n  useSafeLayoutEffect(() => {\n    if (!editing) return\n\n    inputRef.current?.focus()\n\n    if (selectAllOnFocus) inputRef.current?.select()\n  }, [])\n\n  useUpdateEffect(() => {\n    if (!editing) {\n      editRef.current?.focus()\n\n      return\n    }\n\n    inputRef.current?.focus()\n\n    if (selectAllOnFocus) inputRef.current?.select()\n\n    onEditRef()\n  }, [editing, onEditRef, selectAllOnFocus])\n\n  useEffect(() => {\n    if (editing) return\n\n    const el = inputRef.current\n    const activeEl = el?.ownerDocument.activeElement\n\n    if (activeEl === el) el?.blur()\n  }, [editing])\n\n  const getRootProps: PropGetter = useCallback(\n    (props) => ({\n      ...rest,\n      ...dataProps,\n      ...props,\n    }),\n    [rest, dataProps],\n  )\n\n  const getPreviewProps: PropGetter<\"span\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...dataProps,\n      ...props,\n      ref: mergeRefs(previewRef, ref),\n      children: emptyValue ? placeholder : value,\n      hidden: editing,\n      tabIndex: interactive && previewFocusable ? 0 : undefined,\n      onFocus: handlerAll(props.onFocus, onEdit, onUpdatePrevValue),\n    }),\n    [\n      dataProps,\n      editing,\n      interactive,\n      previewFocusable,\n      emptyValue,\n      onEdit,\n      onUpdatePrevValue,\n      placeholder,\n      value,\n    ],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...dataProps,\n      ...ariaProps,\n      ...props,\n      id,\n      ref: mergeRefs(inputRef, ref),\n      disabled,\n      hidden: !editing,\n      placeholder,\n      readOnly,\n      required,\n      value,\n      onBlur: handlerAll(eventProps.onBlur, props.onBlur, onBlur),\n      onChange: handlerAll(props.onChange, onChange),\n      onFocus: handlerAll(eventProps.onFocus, props.onFocus, onUpdatePrevValue),\n      onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n    }),\n    [\n      dataProps,\n      ariaProps,\n      id,\n      disabled,\n      editing,\n      placeholder,\n      readOnly,\n      required,\n      value,\n      eventProps.onBlur,\n      eventProps.onFocus,\n      onBlur,\n      onChange,\n      onUpdatePrevValue,\n      onKeyDown,\n    ],\n  )\n\n  const getTextareaProps: PropGetter<\"textarea\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...dataProps,\n      ...ariaProps,\n      ...props,\n      id,\n      ref: mergeRefs(inputRef, ref),\n      disabled,\n      hidden: !editing,\n      placeholder,\n      readOnly,\n      required,\n      value,\n      onBlur: handlerAll(eventProps.onBlur, props.onBlur, onBlur),\n      onChange: handlerAll(props.onChange, onChange),\n      onFocus: handlerAll(eventProps.onFocus, props.onFocus, onUpdatePrevValue),\n      onKeyDown: handlerAll(props.onKeyDown, onKeyDownWithoutSubmit),\n    }),\n    [\n      dataProps,\n      ariaProps,\n      id,\n      disabled,\n      editing,\n      placeholder,\n      readOnly,\n      required,\n      value,\n      eventProps.onBlur,\n      eventProps.onFocus,\n      onBlur,\n      onChange,\n      onUpdatePrevValue,\n      onKeyDownWithoutSubmit,\n    ],\n  )\n\n  const getControlProps: PropGetter = useCallback(\n    (props) => ({\n      ...dataProps,\n      role: \"group\",\n      ...props,\n    }),\n    [dataProps],\n  )\n\n  const getEditProps: PropGetter<\"button\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...dataProps,\n      ...props,\n      ref: mergeRefs(editRef, ref),\n      disabled,\n      hidden: editing,\n      onClick: handlerAll(props.onClick, onEdit),\n    }),\n    [dataProps, disabled, editing, onEdit],\n  )\n\n  const getSubmitProps: PropGetter<\"button\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...dataProps,\n      ...props,\n      ref: mergeRefs(submitRef, ref),\n      disabled,\n      hidden: !editing,\n      onClick: handlerAll(props.onClick, onSubmit),\n    }),\n    [dataProps, disabled, editing, onSubmit],\n  )\n\n  const getCancelProps: PropGetter<\"button\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...dataProps,\n      ...props,\n      ref: mergeRefs(cancelRef, ref),\n      disabled,\n      hidden: !editing,\n      onClick: handlerAll(props.onClick, onCancel),\n    }),\n    [dataProps, disabled, editing, onCancel],\n  )\n\n  return {\n    editing,\n    value,\n    getCancelProps,\n    getControlProps,\n    getEditProps,\n    getInputProps,\n    getPreviewProps,\n    getRootProps,\n    getSubmitProps,\n    getTextareaProps,\n    onCancel,\n    onEdit,\n    onSubmit,\n  }\n}\n\nexport type UseEditableReturn = ReturnType<typeof useEditable>\n"
    }
  ]
}
