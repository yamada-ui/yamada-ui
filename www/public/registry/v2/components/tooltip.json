{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["motion", "popover", "portal"],
    "externals": ["motion@12.18.1"],
    "hooks": [
      "use-disclosure",
      "use-popper",
      "use-event-listener",
      "use-outside-click"
    ],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./tooltip.style\"\nexport { Tooltip, TooltipPropsContext, useTooltipPropsContext } from \"./tooltip\"\nexport type { TooltipProps } from \"./tooltip\"\nexport * from \"./use-tooltip\"\n"
    },
    {
      "name": "tooltip.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const tooltipStyle = defineComponentSlotStyle({\n  base: {\n    content: {\n      bg: \"bg.float\",\n      borderColor: \"border.muted\",\n      borderWidth: \"1px\",\n      boxShadow: \"sm\",\n      fontSize: \"sm\",\n      maxW: \"xs\",\n      position: \"relative\",\n      px: \"sm\",\n      py: \"xs\",\n      rounded: \"l2\",\n    },\n    positioner: {\n      zIndex: \"ginyu\",\n    },\n  },\n})\n\nexport type TooltipStyle = typeof tooltipStyle\n"
    },
    {
      "name": "tooltip.tsx",
      "content": "\"use client\"\n\nimport type { FC, PropsWithChildren, ReactNode } from \"react\"\nimport type { HTMLProps, HTMLStyledProps, ThemeProps } from \"@yamada-ui/react\"\nimport type { HTMLMotionProps } from \"../motion\"\nimport type { PopupAnimationProps } from \"../popover\"\nimport type { PortalProps } from \"../portal\"\nimport type { TooltipStyle } from \"./tooltip.style\"\nimport type { UseTooltipProps } from \"./use-tooltip\"\nimport { AnimatePresence } from \"motion/react\"\nimport { createSlotComponent, cast } from \"@yamada-ui/react\"\nimport { motion } from \"../motion\"\nimport { getPopupAnimationProps } from \"../popover\"\nimport { Portal } from \"../portal\"\nimport { tooltipStyle } from \"./tooltip.style\"\nimport { useTooltip } from \"./use-tooltip\"\n\nexport interface TooltipProps\n  extends UseTooltipProps,\n    PropsWithChildren,\n    PopupAnimationProps,\n    ThemeProps<TooltipStyle> {\n  /**\n   * The content of the tooltip.\n   */\n  content?: ReactNode\n  /**\n   * The animation duration.\n   *\n   * @default 0.1\n   */\n  duration?: PopupAnimationProps[\"duration\"]\n  /**\n   * Props for content element.\n   */\n  contentProps?: HTMLMotionProps\n  /**\n   * Props for portal component.\n   */\n  portalProps?: Omit<PortalProps, \"children\">\n}\n\nconst {\n  PropsContext: TooltipPropsContext,\n  StyleContext,\n  usePropsContext: useTooltipPropsContext,\n  withContext,\n  useRootComponentProps,\n} = createSlotComponent<TooltipProps, TooltipStyle>(\"tooltip\", tooltipStyle)\n\nexport { TooltipPropsContext, useTooltipPropsContext }\n\n/**\n * `Tooltip` is a component that displays short information, such as supplementary details for an element.\n *\n * @see https://yamada-ui.com/docs/components/tooltip\n */\nexport const Tooltip: FC<TooltipProps> = (props) => {\n  const [\n    context,\n    {\n      animationScheme = \"scale\",\n      children,\n      content,\n      duration = 0.1,\n      contentProps,\n      portalProps,\n      ...rest\n    },\n  ] = useRootComponentProps(props)\n  const { open, getContentProps, getPositionerProps, getTriggerProps } =\n    useTooltip(rest)\n\n  if (!content) return children\n\n  return (\n    <StyleContext value={context}>\n      <TooltipTrigger asChild {...getTriggerProps()}>\n        {children}\n      </TooltipTrigger>\n\n      <AnimatePresence>\n        {open ? (\n          <Portal {...portalProps}>\n            <TooltipPositioner {...getPositionerProps()}>\n              <TooltipContent\n                {...getPopupAnimationProps(animationScheme, duration)}\n                {...cast<HTMLMotionProps>(\n                  getContentProps(cast<HTMLProps>(contentProps)),\n                )}\n              >\n                {content}\n              </TooltipContent>\n            </TooltipPositioner>\n          </Portal>\n        ) : null}\n      </AnimatePresence>\n    </StyleContext>\n  )\n}\n\ninterface TooltipPositionerProps extends HTMLStyledProps {}\n\nconst TooltipPositioner = withContext<\"div\", TooltipPositionerProps>(\n  \"div\",\n  \"positioner\",\n)()\n\ninterface TooltipTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nconst TooltipTrigger = withContext<\"button\", TooltipTriggerProps>(\n  \"button\",\n  \"trigger\",\n)()\n\ninterface TooltipContentProps\n  extends Omit<HTMLMotionProps, \"children\" | \"offset\" | \"transform\"> {}\n\nconst TooltipContent = withContext<\"div\", TooltipContentProps>(\n  motion.div,\n  \"content\",\n)()\n"
    },
    {
      "name": "use-tooltip.tsx",
      "content": "\"use client\"\n\nimport type { PropGetter } from \"@yamada-ui/react\"\nimport type { UseDisclosureProps } from \"../../hooks/use-disclosure\"\nimport type { UsePopperProps } from \"../../hooks/use-popper\"\nimport { useCallback, useId, useRef } from \"react\"\nimport { useDisclosure } from \"../../hooks/use-disclosure\"\nimport { useEventListener } from \"../../hooks/use-event-listener\"\nimport { useOutsideClick } from \"../../hooks/use-outside-click\"\nimport { usePopper, usePopperProps } from \"../../hooks/use-popper\"\nimport {\n  cx,\n  dataAttr,\n  getDocument,\n  getWindow,\n  handlerAll,\n  mergeRefs,\n  useUnmountEffect,\n} from \"@yamada-ui/react\"\n\nexport interface UseTooltipProps\n  extends Omit<UseDisclosureProps, \"timing\">,\n    UsePopperProps<\"button\"> {\n  /**\n   * The delay before hiding the tooltip.\n   *\n   * @default 100\n   */\n  closeDelay?: number\n  /**\n   * If `true`, the tooltip will hide on click.\n   *\n   * @default true\n   */\n  closeOnClick?: boolean\n  /**\n   * If `true`, the tooltip will hide on pressing Esc key.\n   *\n   * @default true\n   */\n  closeOnEsc?: boolean\n  /**\n   * If `true`, the tooltip will hide on scroll.\n   *\n   * @default false\n   */\n  closeOnScroll?: boolean\n  /**\n   * If `true`, the tooltip will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * The delay before showing the tooltip.\n   *\n   * @default 400\n   */\n  openDelay?: number\n}\n\nexport const useTooltip = (props: UseTooltipProps = {}) => {\n  const [\n    popperProps,\n    {\n      closeDelay = 0,\n      closeOnClick = true,\n      closeOnEsc = true,\n      closeOnScroll,\n      defaultOpen,\n      disabled,\n      open: openProp,\n      openDelay = 0,\n      onClose: onCloseProp,\n      onOpen: onOpenProp,\n    },\n  ] = usePopperProps(props, [\"open\"])\n  const describedbyId = useId()\n  const triggerRef = useRef<HTMLElement>(null)\n  const openTimeout = useRef<NodeJS.Timeout>(undefined)\n  const closeTimeout = useRef<NodeJS.Timeout>(undefined)\n  const { open, onClose, onOpen } = useDisclosure({\n    defaultOpen,\n    open: openProp,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n  })\n  const { getPopperProps, getReferenceProps } = usePopper({\n    open,\n    ...popperProps,\n  })\n\n  const onForceClose = useCallback(() => {\n    if (closeTimeout.current) {\n      clearTimeout(closeTimeout.current)\n\n      closeTimeout.current = undefined\n    }\n\n    onClose()\n  }, [onClose])\n\n  const onDelayOpen = useCallback(() => {\n    if (!disabled && !openTimeout.current) {\n      if (open) onForceClose()\n\n      openTimeout.current = getWindow(triggerRef.current).setTimeout(\n        onOpen,\n        openDelay,\n      )\n    }\n  }, [disabled, open, onForceClose, onOpen, openDelay])\n\n  const onDelayClose = useCallback(() => {\n    if (openTimeout.current) {\n      clearTimeout(openTimeout.current)\n      openTimeout.current = undefined\n    }\n\n    closeTimeout.current = getWindow(triggerRef.current).setTimeout(() => {\n      onForceClose()\n    }, closeDelay)\n  }, [closeDelay, onForceClose])\n\n  useEventListener(\n    () => getDocument(triggerRef.current),\n    \"keydown\",\n    ({ key }) => {\n      if (closeOnEsc && key === \"Escape\") onDelayClose()\n    },\n  )\n\n  useEventListener(\n    () => getDocument(triggerRef.current),\n    \"scroll\",\n    () => {\n      if (open && closeOnScroll) onForceClose()\n    },\n  )\n\n  useOutsideClick({\n    ref: triggerRef,\n    enabled: open,\n    handler: () => {\n      onDelayClose()\n    },\n  })\n\n  useUnmountEffect(() => {\n    clearTimeout(openTimeout.current)\n    clearTimeout(closeTimeout.current)\n  })\n\n  const getTriggerProps: PropGetter<\"button\"> = useCallback(\n    ({ \"aria-describedby\": ariaDescribedby, ...props } = {}) => {\n      return getReferenceProps({\n        ...props,\n        ref: mergeRefs(props.ref, triggerRef),\n        \"aria-describedby\": cx(\n          ariaDescribedby,\n          open ? describedbyId : undefined,\n        ),\n        onBlur: handlerAll(props.onBlur, onDelayClose),\n        onClick: handlerAll(\n          props.onClick,\n          closeOnClick ? onDelayClose : undefined,\n        ),\n        onFocus: handlerAll(props.onFocus, onDelayOpen),\n        onPointerEnter: handlerAll(props.onPointerEnter, (ev) => {\n          if (ev.pointerType !== \"touch\") onDelayOpen()\n        }),\n        onPointerLeave: handlerAll(props.onPointerLeave, (ev) => {\n          if (ev.pointerType !== \"touch\") onDelayClose()\n        }),\n      })\n    },\n    [\n      getReferenceProps,\n      describedbyId,\n      onDelayOpen,\n      open,\n      closeOnClick,\n      onDelayClose,\n    ],\n  )\n\n  const getPositionerProps: PropGetter = useCallback(\n    (props) => {\n      return getPopperProps(props)\n    },\n    [getPopperProps],\n  )\n\n  const getContentProps: PropGetter = useCallback(\n    (props = {}) => ({\n      id: describedbyId,\n      \"data-close\": dataAttr(!open),\n      \"data-open\": dataAttr(open),\n      role: \"tooltip\",\n      onPointerLeave: handlerAll(props.onPointerLeave, onDelayClose),\n      ...props,\n    }),\n    [describedbyId, onDelayClose, open],\n  )\n\n  return {\n    open,\n    getContentProps,\n    getPositionerProps,\n    getTriggerProps,\n    onClose: onForceClose,\n    onDelayClose,\n    onDelayOpen,\n    onOpen,\n  }\n}\n\nexport type UseTooltipReturn = ReturnType<typeof useTooltip>\n"
    }
  ]
}
