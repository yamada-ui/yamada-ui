{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["group", "loading", "ripple"],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "dependents": {
    "components": [
      "calendar",
      "carousel",
      "close-button",
      "drawer",
      "file-button",
      "modal",
      "number-input",
      "pagination",
      "password-input",
      "toggle"
    ],
    "hooks": [],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "button-group.tsx",
      "content": "\"use client\"\n\nimport type { Component, ThemeProps, WithoutThemeProps } from \"@yamada-ui/react\"\nimport type { GroupProps } from \"../group\"\nimport type { ButtonProps } from \"./button\"\nimport type { ButtonStyle } from \"./button.style\"\nimport { useMemo } from \"react\"\nimport { Group } from \"../group\"\nimport { ButtonPropsContext } from \"./button\"\nimport { IconButtonPropsContext } from \"./icon-button\"\n\nexport interface ButtonGroupRootProps\n  extends WithoutThemeProps<GroupProps, ButtonStyle>,\n    ThemeProps<ButtonStyle> {\n  /**\n   * If `true`, all wrapped button will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n}\n\n/**\n * `Button` is an interactive component that allows users to perform actions such as submitting forms and toggling modals.\n *\n * @see https://yamada-ui.com/docs/components/button\n */\nexport const ButtonGroupRoot = (({\n  size,\n  variant,\n  attached,\n  disabled,\n  ...rest\n}: ButtonGroupRootProps) => {\n  const context = useMemo<ButtonProps>(\n    () => ({\n      size,\n      variant,\n      disabled,\n      focusVisibleRing: attached ? \"inside\" : undefined,\n    }),\n    [size, variant, disabled, attached],\n  )\n\n  return (\n    <ButtonPropsContext value={context}>\n      <IconButtonPropsContext value={context}>\n        <Group attached={attached} {...rest} />\n      </IconButtonPropsContext>\n    </ButtonPropsContext>\n  )\n}) as Component<\"div\", ButtonGroupRootProps>\n"
    },
    {
      "name": "button.style.ts",
      "content": "import { defineComponentStyle } from \"@yamada-ui/react\"\n\nexport const buttonStyle = defineComponentStyle({\n  base: {\n    alignItems: \"center\",\n    appearance: \"none\",\n    cursor: \"pointer\",\n    display: \"inline-flex\",\n    fontWeight: \"medium\",\n    justifyContent: \"center\",\n    overflow: \"hidden\",\n    position: \"relative\",\n    rounded: \"l2\",\n    transitionDuration: \"moderate\",\n    transitionProperty: \"common\",\n    userSelect: \"none\",\n    verticalAlign: \"middle\",\n    whiteSpace: \"nowrap\",\n    _readOnly: { layerStyle: \"readOnly\" },\n    _disabled: { layerStyle: \"disabled\" },\n  },\n\n  props: {\n    /**\n     * If `true`, the button is full rounded. Else, it'll be slightly round.\n     *\n     * @default false\n     */\n    fullRounded: {\n      true: { rounded: \"full\" },\n    },\n  },\n\n  variants: {\n    ghost: {\n      layerStyle: \"ghost\",\n      _hover: { layerStyle: \"ghost.hover\" },\n    },\n    outline: {\n      layerStyle: \"outline\",\n      _hover: { layerStyle: \"outline.hover\" },\n    },\n    solid: {\n      layerStyle: \"solid\",\n      _hover: { layerStyle: \"solid.hover\" },\n    },\n    subtle: {\n      layerStyle: \"subtle\",\n      _hover: { layerStyle: \"subtle.hover\" },\n    },\n    surface: {\n      layerStyle: \"surface\",\n      _hover: { layerStyle: \"surface.hover\" },\n    },\n  },\n\n  sizes: {\n    xs: {\n      fontSize: \"xs\",\n      gap: \"1\",\n      h: \"8\",\n      lineHeight: \"{sizes.8}\",\n      minW: \"8\",\n      px: \"2\",\n      _icon: { fontSize: \"md\" },\n    },\n    sm: {\n      fontSize: \"sm\",\n      gap: \"2\",\n      h: \"9\",\n      lineHeight: \"{sizes.9}\",\n      minW: \"9\",\n      px: \"3\",\n      _icon: { fontSize: \"md\" },\n    },\n    md: {\n      fontSize: \"md\",\n      gap: \"2\",\n      h: \"10\",\n      lineHeight: \"{sizes.10}\",\n      minW: \"10\",\n      px: \"3\",\n      _icon: { fontSize: \"lg\" },\n    },\n    lg: {\n      fontSize: \"lg\",\n      gap: \"2.5\",\n      h: \"11\",\n      lineHeight: \"{sizes.11}\",\n      minW: \"11\",\n      px: \"4\",\n      _icon: { fontSize: \"2xl\" },\n    },\n    xl: {\n      fontSize: \"xl\",\n      gap: \"3\",\n      h: \"12\",\n      lineHeight: \"{sizes.12}\",\n      minW: \"12\",\n      px: \"5\",\n      _icon: { fontSize: \"2xl\" },\n    },\n    \"2xl\": {\n      fontSize: \"xl\",\n      gap: \"3\",\n      h: \"14\",\n      lineHeight: \"{sizes.14}\",\n      minW: \"14\",\n      px: \"5\",\n      _icon: { fontSize: \"2xl\" },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"solid\",\n  },\n})\n\nexport type ButtonStyle = typeof buttonStyle\n"
    },
    {
      "name": "button.tsx",
      "content": "\"use client\"\n\nimport type { ElementType, PropsWithChildren, ReactNode } from \"react\"\nimport type {\n  CSSObject,\n  HTMLProps,\n  HTMLStyledProps,\n  ThemeProps,\n} from \"@yamada-ui/react\"\nimport type { Loading } from \"../loading\"\nimport type { ButtonStyle } from \"./button.style\"\nimport {\n  Children,\n  cloneElement,\n  isValidElement,\n  useCallback,\n  useMemo,\n  useRef,\n} from \"react\"\nimport {\n  createComponent,\n  getClassName,\n  mergeCSS,\n  styled,\n  bem,\n  dataAttr,\n  mergeRefs,\n} from \"@yamada-ui/react\"\nimport { getLoadingComponent, isLoadingScheme } from \"../loading\"\nimport { Ripple, useRipple } from \"../ripple\"\nimport { buttonStyle } from \"./button.style\"\n\ninterface ComponentContext\n  extends Pick<\n    ButtonProps,\n    \"endIcon\" | \"iconProps\" | \"loadingIcon\" | \"loadingMessage\" | \"startIcon\"\n  > {}\n\nconst useButtonType = (value?: ElementType) => {\n  const buttonRef = useRef(!value)\n\n  const ref = useCallback((node: HTMLElement | null) => {\n    if (node) buttonRef.current = node.tagName === \"BUTTON\"\n  }, [])\n\n  const type = buttonRef.current ? \"button\" : undefined\n\n  return { ref, type } as const\n}\n\nexport interface ButtonProps\n  extends HTMLStyledProps<\"button\">,\n    ThemeProps<ButtonStyle> {\n  /**\n   * The type of button. Accepts `button`, `reset`, or `submit`.\n   *\n   * @default 'button'\n   */\n  type?: HTMLProps<\"button\">[\"type\"]\n  /**\n   * If `true`, the button is represented as active.\n   *\n   * @default false\n   */\n  active?: boolean\n  /**\n   * If `true`, the button is disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * If `true`, disable ripple effects when pressing a element.\n   *\n   * @default false\n   */\n  disableRipple?: boolean\n  /**\n   * The icon to display at the end side of the button.\n   */\n  endIcon?: ReactNode\n  /**\n   * If `true`, the loading state of the button is represented.\n   *\n   * @default false\n   */\n  loading?: boolean\n  /**\n   * The icon to display when the button is loading.\n   *\n   * @default 'oval'\n   */\n  loadingIcon?: Loading.Scheme | ReactNode\n  /**\n   * The message to display when the button is loading.\n   */\n  loadingMessage?: ReactNode\n  /**\n   * The placement of the loading indicator. Accepts `start` or `end`.\n   *\n   * @default 'start'\n   */\n  loadingPlacement?: \"end\" | \"start\"\n  /**\n   * The icon to display at the start side of the button.\n   */\n  startIcon?: ReactNode\n  /**\n   * The props of the icon element.\n   */\n  iconProps?: ButtonIconProps\n  /**\n   * The props of the loading icon element.\n   */\n  loadingProps?: ButtonLoadingProps\n}\n\nconst {\n  component,\n  ComponentContext,\n  PropsContext: ButtonPropsContext,\n  useComponentContext,\n  usePropsContext: useButtonPropsContext,\n  withContext,\n} = createComponent<ButtonProps, ButtonStyle>(\"button\", buttonStyle)\n\nexport { ButtonPropsContext, useButtonPropsContext }\n\n/**\n * `Button` is an interactive component that allows users to perform actions such as submitting forms and toggling modals.\n *\n * @see https://yamada-ui.com/docs/components/button\n */\nexport const Button = withContext<\"button\", ButtonProps>(\n  ({\n    ref,\n    as,\n    active,\n    children,\n    disabled,\n    disableRipple,\n    endIcon = null,\n    loading,\n    loadingIcon = \"oval\",\n    loadingMessage,\n    loadingPlacement = \"start\",\n    startIcon = null,\n    iconProps,\n    loadingProps,\n    ...rest\n  }) => {\n    const trulyDisabled = disabled || loading\n    const { ref: buttonRef, type } = useButtonType(as)\n    const { onClick, ...rippleProps } = useRipple({\n      ...rest,\n      disabled: disableRipple || trulyDisabled,\n    })\n    const startLoading = loading && loadingPlacement === \"start\"\n    const endLoading = loading && loadingPlacement === \"end\"\n\n    const context = useMemo(\n      () => ({ endIcon, loadingIcon, loadingMessage, startIcon, iconProps }),\n      [loadingIcon, loadingMessage, startIcon, endIcon, iconProps],\n    )\n\n    return (\n      <ComponentContext value={context}>\n        <styled.button\n          ref={mergeRefs(ref, buttonRef)}\n          as={as}\n          type={type}\n          data-active={dataAttr(active)}\n          data-loading={dataAttr(loading)}\n          disabled={trulyDisabled}\n          {...rest}\n          onClick={onClick}\n        >\n          {startLoading ? <ButtonStartLoading {...loadingProps} /> : null}\n\n          {loading ? (\n            loadingMessage || (\n              <styled.span opacity={0}>\n                <ButtonContent>{children}</ButtonContent>\n              </styled.span>\n            )\n          ) : (\n            <ButtonContent>{children}</ButtonContent>\n          )}\n\n          {endLoading ? <ButtonEndLoading {...loadingProps} /> : null}\n\n          <Ripple {...rippleProps} />\n        </styled.button>\n      </ComponentContext>\n    )\n  },\n)()\n\nconst ButtonContent = component<\"fragment\", PropsWithChildren>(\n  ({ children }) => {\n    const { endIcon, startIcon, iconProps } = useComponentContext()\n\n    return (\n      <>\n        {startIcon ? (\n          <ButtonStartIcon {...iconProps}>{startIcon}</ButtonStartIcon>\n        ) : null}\n        {children}\n        {endIcon ? (\n          <ButtonEndIcon {...iconProps}>{endIcon}</ButtonEndIcon>\n        ) : null}\n      </>\n    )\n  },\n  { name: \"ButtonContent\", className: getClassName(bem(\"button\", \"content\")) },\n)()\n\ninterface ButtonLoadingProps extends HTMLStyledProps<\"svg\"> {}\n\nconst ButtonLoading = component<\"svg\", ButtonLoadingProps>(\n  (props) => {\n    const { loadingIcon, loadingMessage } = useComponentContext()\n\n    const css = useMemo<CSSObject>(\n      () => ({\n        position: loadingMessage ? \"relative\" : \"absolute\",\n      }),\n      [loadingMessage],\n    )\n\n    if (isLoadingScheme(loadingIcon)) {\n      const Component = getLoadingComponent(loadingIcon)\n\n      return (\n        <Component\n          color=\"currentColor\"\n          {...props}\n          css={mergeCSS(css, props.css)}\n        />\n      )\n    }\n\n    if (isValidElement<HTMLStyledProps<\"svg\">>(loadingIcon))\n      return cloneElement(loadingIcon, {\n        ...props,\n        ...loadingIcon.props,\n        css: mergeCSS(css, props.css, loadingIcon.props.css),\n      })\n\n    return null\n  },\n  { name: \"ButtonLoading\", className: getClassName(bem(\"button\", \"loading\")) },\n)()\n\nconst ButtonStartLoading = component<\"svg\", ButtonLoadingProps>(ButtonLoading, {\n  name: \"ButtonStartLoading\",\n  className: getClassName(bem(\"button\", \"loading\", \"start\")),\n})()\n\nconst ButtonEndLoading = component<\"svg\", ButtonLoadingProps>(ButtonLoading, {\n  name: \"ButtonEndLoading\",\n  className: getClassName(bem(\"button\", \"loading\", \"end\")),\n})()\n\ninterface ButtonIconProps extends HTMLStyledProps<\"svg\"> {}\n\nconst ButtonIcon = component<\"svg\", ButtonIconProps>(\n  ({ children, ...rest }) => {\n    if (isValidElement<HTMLProps<\"svg\">>(children))\n      return cloneElement(children, {\n        \"aria-hidden\": true,\n        role: \"img\",\n        ...rest,\n        ...children.props,\n      })\n\n    return Children.count(children) > 1 ? Children.only(null) : null\n  },\n  { name: \"ButtonIcon\", className: getClassName(bem(\"button\", \"icon\")) },\n)()\n\nconst ButtonStartIcon = component<\"svg\", ButtonIconProps>(ButtonIcon, {\n  name: \"ButtonStartIcon\",\n  className: getClassName(bem(\"button\", \"icon\", \"start\")),\n})()\n\nconst ButtonEndIcon = component<\"svg\", ButtonIconProps>(ButtonIcon, {\n  name: \"ButtonEndIcon\",\n  className: getClassName(bem(\"button\", \"icon\", \"end\")),\n})()\n"
    },
    {
      "name": "icon-button.style.ts",
      "content": "import { defineComponentStyle } from \"@yamada-ui/react\"\nimport { buttonStyle } from \"./button.style\"\n\nexport const iconButtonStyle = defineComponentStyle({\n  variants: buttonStyle.variants,\n\n  sizes: {\n    \"2xs\": {\n      fontSize: \"md\",\n      minBoxSize: \"6\",\n    },\n    xs: {\n      fontSize: \"lg\",\n      minBoxSize: \"8\",\n    },\n    sm: {\n      fontSize: \"xl\",\n      minBoxSize: \"9\",\n    },\n    md: {\n      fontSize: \"2xl\",\n      minBoxSize: \"10\",\n    },\n    lg: {\n      fontSize: \"3xl\",\n      minBoxSize: \"11\",\n    },\n    xl: {\n      fontSize: \"4xl\",\n      minBoxSize: \"12\",\n    },\n    \"2xl\": {\n      fontSize: \"4xl\",\n      minBoxSize: \"14\",\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"solid\",\n  },\n})\n\nexport type IconButtonStyle = typeof iconButtonStyle\n"
    },
    {
      "name": "icon-button.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport type { ThemeProps, WithoutThemeProps } from \"@yamada-ui/react\"\nimport type { ButtonProps } from \"./button\"\nimport type { IconButtonStyle } from \"./icon-button.style\"\nimport { createComponent } from \"@yamada-ui/react\"\nimport { Button } from \"./button\"\nimport { iconButtonStyle } from \"./icon-button.style\"\n\nexport interface IconButtonProps\n  extends Omit<\n      WithoutThemeProps<ButtonProps, IconButtonStyle>,\n      | \"endIcon\"\n      | \"iconProps\"\n      | \"loadingIcon\"\n      | \"loadingMessage\"\n      | \"loadingPlacement\"\n      | \"loadingProps\"\n      | \"startIcon\"\n    >,\n    ThemeProps<IconButtonStyle> {\n  /**\n   * The icon to be used in the button.\n   */\n  icon?: ReactNode\n}\n\nconst {\n  PropsContext: IconButtonPropsContext,\n  usePropsContext: useIconButtonPropsContext,\n  withContext,\n} = createComponent<IconButtonProps, IconButtonStyle>(\n  \"icon-button\",\n  iconButtonStyle,\n)\n\nexport { IconButtonPropsContext, useIconButtonPropsContext }\n\n/**\n * `IconButton` is a component that displays an icon within a button.\n *\n * @see https://yamada-ui.com/docs/components/icon-button\n */\nexport const IconButton = withContext<\"button\", IconButtonProps>(Button)(\n  undefined,\n  ({ children, icon, ...rest }) => ({\n    children: icon || children,\n    ...rest,\n  }),\n)\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./button.style\"\nexport * from \"./icon-button.style\"\nexport { Button, ButtonPropsContext, useButtonPropsContext } from \"./button\"\nexport type { ButtonProps } from \"./button\"\nexport { ButtonGroupRoot } from \"./button-group\"\nexport type { ButtonGroupRootProps } from \"./button-group\"\nexport {\n  IconButton,\n  IconButtonPropsContext,\n  useIconButtonPropsContext,\n} from \"./icon-button\"\nexport type { IconButtonProps } from \"./icon-button\"\nexport * as ButtonGroup from \"./namespace\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  Button as Item,\n  ButtonPropsContext as PropsContext,\n  useButtonPropsContext as usePropsContext,\n} from \"./button\"\nexport type { ButtonProps as ItemProps } from \"./button\"\nexport { ButtonGroupRoot as Root } from \"./button-group\"\nexport type { ButtonGroupRootProps as RootProps } from \"./button-group\"\nexport {\n  IconButton as IconItem,\n  IconButtonPropsContext as IconPropsContext,\n  useIconButtonPropsContext as useIconPropsContext,\n} from \"./icon-button\"\nexport type { IconButtonProps as IconItemProps } from \"./icon-button\"\n"
    }
  ]
}
