{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["input", "field"],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./textarea.style\"\nexport {\n  Textarea,\n  TextareaPropsContext,\n  useTextareaPropsContext,\n} from \"./textarea\"\nexport type { TextareaProps } from \"./textarea\"\nexport * from \"./use-autosize\"\nexport * from \"./use-textarea\"\n"
    },
    {
      "name": "textarea.style.ts",
      "content": "import { defineComponentStyle } from \"@yamada-ui/react\"\nimport { getInputPaddingResetStyle, inputStyle } from \"../input\"\n\nexport const textareaStyle = defineComponentStyle({\n  base: {\n    ...inputStyle.base,\n    resize: \"vertical\",\n  },\n\n  variants: {\n    filled: { ...inputStyle.variants?.filled },\n    flushed: {\n      ...inputStyle.variants?.flushed,\n      ...getInputPaddingResetStyle(),\n    },\n    outline: { ...inputStyle.variants?.outline },\n    plain: { ...inputStyle.variants?.plain },\n  },\n\n  sizes: {\n    xs: {\n      ...inputStyle.sizes?.xs,\n      py: \"{--space-y}\",\n    },\n    sm: {\n      ...inputStyle.sizes?.sm,\n      py: \"{--space-y}\",\n    },\n    md: {\n      ...inputStyle.sizes?.md,\n      py: \"{--space-y}\",\n    },\n    lg: {\n      ...inputStyle.sizes?.lg,\n      py: \"{--space-y}\",\n    },\n    xl: {\n      ...inputStyle.sizes?.xl,\n      py: \"{--space-y}\",\n    },\n    \"2xl\": {\n      ...inputStyle.sizes?.[\"2xl\"],\n      py: \"{--space-y}\",\n    },\n  },\n\n  compounds: [\n    {\n      css: getInputPaddingResetStyle(),\n      variant: \"flushed\",\n    },\n  ],\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"outline\",\n  },\n})\n\nexport type TextareaStyle = typeof textareaStyle\n"
    },
    {
      "name": "textarea.tsx",
      "content": "\"use client\"\n\nimport type { HTMLStyledProps, ThemeProps } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { TextareaStyle } from \"./textarea.style\"\nimport type { UseTextareaProps } from \"./use-textarea\"\nimport { createComponent } from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\nimport { useInputBorder, useInputPropsContext } from \"../input\"\nimport { textareaStyle } from \"./textarea.style\"\nimport { useTextarea } from \"./use-textarea\"\n\nexport interface TextareaProps\n  extends HTMLStyledProps<\"textarea\">,\n    ThemeProps<TextareaStyle>,\n    UseInputBorderProps,\n    FieldProps,\n    UseTextareaProps {}\n\nconst {\n  PropsContext: TextareaPropsContext,\n  usePropsContext: useTextareaPropsContext,\n  withContext,\n} = createComponent<TextareaProps, TextareaStyle>(\"textarea\", textareaStyle)\n\nexport { TextareaPropsContext, useTextareaPropsContext }\n\n/**\n * `Textarea` is a component used to obtain multi-line text input.\n *\n * @see https://yamada-ui.com/docs/components/textarea\n */\nexport const Textarea = withContext(\"textarea\")(\n  (props) => {\n    const context = useInputPropsContext()\n\n    return { rows: 2, ...context, ...props }\n  },\n  (props) => {\n    const {\n      props: { errorBorderColor, focusBorderColor, ...rest },\n      ariaProps,\n      dataProps,\n      eventProps,\n    } = useFieldProps(props)\n    const { getTextareaProps } = useTextarea({\n      ...ariaProps,\n      ...dataProps,\n      ...eventProps,\n      ...rest,\n    })\n    const varProps = useInputBorder({ errorBorderColor, focusBorderColor })\n\n    return {\n      ...varProps,\n      ...getTextareaProps(),\n    }\n  },\n)\n"
    },
    {
      "name": "use-autosize.ts",
      "content": "\"use client\"\n\nimport type { PropGetter } from \"@yamada-ui/react\"\nimport { useCallback, useRef } from \"react\"\nimport {\n  addDomEvent,\n  createdDom,\n  handlerAll,\n  mergeRefs,\n  noop,\n  pickObject,\n  useSafeLayoutEffect,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\n\nconst SIZING_STYLE_PROPERTIES = [\n  \"borderBottomWidth\",\n  \"borderLeftWidth\",\n  \"borderRightWidth\",\n  \"borderTopWidth\",\n  \"boxSizing\",\n  \"fontFamily\",\n  \"fontSize\",\n  \"fontStyle\",\n  \"fontWeight\",\n  \"letterSpacing\",\n  \"lineHeight\",\n  \"paddingBottom\",\n  \"paddingLeft\",\n  \"paddingRight\",\n  \"paddingTop\",\n  // non-standard\n  \"tabSize\",\n  \"textIndent\",\n  // non-standard\n  \"textRendering\",\n  \"textTransform\",\n  \"width\",\n  \"wordBreak\",\n] as const\n\nconst HIDDEN_STYLE = {\n  height: \"0\",\n  \"max-height\": \"none\",\n  \"min-height\": \"0\",\n  overflow: \"hidden\",\n  position: \"absolute\",\n  right: \"0\",\n  top: \"0\",\n  visibility: \"hidden\",\n  \"z-index\": \"-1000\",\n} as const\n\ntype SizingProperties = Extract<\n  (typeof SIZING_STYLE_PROPERTIES)[number],\n  keyof CSSStyleDeclaration\n>\n\ninterface SizingStyle {\n  style: Pick<CSSStyleDeclaration, SizingProperties>\n  border: number\n  padding: number\n  rowHeight: number\n}\n\nconst getSizingStyle = (el: HTMLElement): null | SizingStyle => {\n  const style = window.getComputedStyle(el) as CSSStyleDeclaration | undefined\n\n  if (style == null) return null\n\n  const computedStyle = pickObject(style, SIZING_STYLE_PROPERTIES)\n\n  if (computedStyle.boxSizing === \"\") return null\n\n  const padding =\n    parseFloat(computedStyle.paddingBottom!) +\n    parseFloat(computedStyle.paddingTop!)\n\n  const border =\n    parseFloat(computedStyle.borderBottomWidth!) +\n    parseFloat(computedStyle.borderTopWidth!)\n\n  const rowHeight = parseFloat(computedStyle.lineHeight!)\n\n  return {\n    style: computedStyle,\n    border,\n    padding,\n    rowHeight,\n  }\n}\n\nconst setHiddenStyle = (el: HTMLElement) => {\n  Object.keys(HIDDEN_STYLE).forEach((key) => {\n    el.style.setProperty(\n      key,\n      HIDDEN_STYLE[key as keyof typeof HIDDEN_STYLE],\n      \"important\",\n    )\n  })\n}\n\nconst calcRows = (\n  el: HTMLTextAreaElement,\n  sizingStyle: SizingStyle,\n  value: string,\n  maxRows: number,\n  minRows: number,\n) => {\n  const cloneEl = el.cloneNode() as HTMLTextAreaElement\n\n  Object.assign(cloneEl.style, sizingStyle.style)\n\n  setHiddenStyle(cloneEl)\n\n  cloneEl.value = value\n\n  document.body.appendChild(cloneEl)\n\n  let rows: number\n\n  if (cloneEl.scrollHeight) {\n    const rowHeight = sizingStyle.rowHeight\n\n    rows = Math.min(\n      maxRows,\n      Math.max(minRows, Math.floor(cloneEl.scrollHeight / rowHeight)),\n    )\n  } else {\n    const lineBreaks = (value.match(/\\n/g) || []).length\n\n    rows = Math.min(maxRows, Math.max(minRows, lineBreaks + 1))\n  }\n\n  document.body.removeChild(cloneEl)\n\n  return rows\n}\n\nexport interface UseAutosizeProps {\n  /**\n   * If `true`, the Textarea height will not be adjusted.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * Autosize up to maxRows rows.\n   *\n   * @default Infinity\n   */\n  maxRows?: number\n  /**\n   * Autosize up to minRows rows.\n   *\n   * @default 2\n   */\n  minRows?: number\n}\n\nexport const useAutosize = ({\n  disabled = false,\n  maxRows = Infinity,\n  minRows = 2,\n}: UseAutosizeProps = {}) => {\n  const ref = useRef<HTMLTextAreaElement>(null)\n  const beforeValueRef = useRef<string>(null)\n  const value = ref.current?.value ?? \"\"\n\n  const onResizeTextarea = useCallback(() => {\n    const el = ref.current\n\n    if (!el) return\n\n    let { placeholder, value } = el\n\n    if (value === beforeValueRef.current) return\n\n    beforeValueRef.current = value\n\n    value ||= placeholder || \"x\"\n\n    const sizingStyle = getSizingStyle(el)\n\n    if (!sizingStyle) return\n\n    const rows = calcRows(el, sizingStyle, value, maxRows, minRows)\n\n    el.rows = rows\n  }, [ref, maxRows, minRows])\n\n  const getTextareaProps: PropGetter<\"textarea\"> = useCallback(\n    (props = {}) => ({\n      ...props,\n      ref: mergeRefs(props.ref, ref),\n      style: { resize: !disabled ? \"none\" : undefined, ...props.style },\n      onChange: handlerAll(props.onChange, !disabled ? onResizeTextarea : noop),\n    }),\n    [ref, onResizeTextarea, disabled],\n  )\n\n  useSafeLayoutEffect(() => {\n    if (!createdDom() || disabled) return\n\n    onResizeTextarea()\n\n    const unsubscribeResize = addDomEvent(window, \"resize\", onResizeTextarea)\n    const unsubscribeLoadingdone = addDomEvent(\n      document.fonts,\n      \"loadingdone\",\n      onResizeTextarea,\n    )\n\n    return () => {\n      unsubscribeResize()\n      unsubscribeLoadingdone()\n    }\n  }, [])\n\n  useUpdateEffect(() => {\n    if (disabled) return\n\n    onResizeTextarea()\n  }, [value])\n\n  return { ref, getTextareaProps, onResizeTextarea }\n}\n\nexport type UseAutosizeReturn = ReturnType<typeof useAutosize>\n"
    },
    {
      "name": "use-textarea.ts",
      "content": "\"use client\"\n\nimport type { ForwardedRef } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type { UseAutosizeProps } from \"./use-autosize\"\nimport { useCallback } from \"react\"\nimport { assignRef, handlerAll, mergeRefs, noop } from \"@yamada-ui/react\"\nimport { useAutosize } from \"./use-autosize\"\n\nexport interface UseTextareaProps\n  extends HTMLProps<\"textarea\">,\n    Omit<UseAutosizeProps, \"disabled\" | \"ref\"> {\n  /**\n   * If `true`, the Textarea height auto-adjusts to text height.\n   */\n  autosize?: boolean\n  /**\n   * Ref to a resize function.\n   */\n  resizeRef?: ForwardedRef<() => void>\n}\n\nexport const useTextarea = ({\n  autosize,\n  maxRows,\n  minRows,\n  resizeRef,\n  ...rest\n}: UseTextareaProps = {}) => {\n  const { ref, onResizeTextarea } = useAutosize({\n    disabled: !autosize,\n    maxRows,\n    minRows,\n  })\n\n  assignRef(resizeRef, onResizeTextarea)\n\n  const getTextareaProps: PropGetter<\"textarea\"> = useCallback(\n    ({ style, ...props } = {}) => ({\n      ...rest,\n      ...props,\n      ref: mergeRefs(props.ref, rest.ref, ref),\n      style: { resize: autosize ? \"none\" : undefined, ...rest.style, ...style },\n      onChange: handlerAll(\n        props.onChange,\n        rest.onChange,\n        autosize ? onResizeTextarea : noop,\n      ),\n    }),\n    [autosize, onResizeTextarea, rest, ref],\n  )\n\n  return {\n    getTextareaProps,\n    onResizeTextarea,\n  }\n}\n\nexport type UseTextareaReturn = ReturnType<typeof useTextarea>\n"
    }
  ]
}
