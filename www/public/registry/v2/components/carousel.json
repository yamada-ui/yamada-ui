{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["button", "icon"],
    "externals": ["embla-carousel@^8.6.0", "embla-carousel-react@^8.6.0"],
    "hooks": ["use-boolean", "use-controllable-state"],
    "providers": ["i18n-provider"]
  },
  "section": "components",
  "sources": [
    {
      "name": "carousel.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const carouselStyle = defineComponentSlotStyle({\n  base: {\n    indicator: {\n      bg: \"colorScheme.solid/40\",\n      cursor: \"pointer\",\n      rounded: \"full\",\n      transitionDuration: \"moderate\",\n      transitionProperty: \"common\",\n      _horizontal: { w: \"10\" },\n      _vertical: { h: \"10\" },\n      _hover: {\n        _notSelected: {\n          bg: \"colorScheme.solid/70\",\n        },\n      },\n      _selected: {\n        bg: \"colorScheme.solid\",\n      },\n      _disabled: {\n        layerStyle: \"disabled\",\n      },\n    },\n    indicators: {\n      display: \"flex\",\n      gap: \"2\",\n      justifyContent: \"center\",\n      position: \"absolute\",\n      zIndex: \"yamcha\",\n      _horizontal: {\n        bottom: \"4\",\n        flexDirection: \"row\",\n        h: \"2\",\n        left: \"50%\",\n        px: \"4\",\n        transform: \"translateX(-50%)\",\n        w: \"full\",\n      },\n      _vertical: {\n        flexDirection: \"column\",\n        h: \"full\",\n        py: \"4\",\n        right: \"4\",\n        top: \"50%\",\n        transform: \"translateY(-50%)\",\n        w: \"2\",\n      },\n    },\n    item: {\n      \"&:not([data-include-gap-in-size])\": {\n        _horizontal: { mr: \"{slide-gap}\" },\n        _vertical: { mb: \"{slide-gap}\" },\n      },\n      \"&[data-include-gap-in-size]\": {\n        _horizontal: { pr: \"{slide-gap}\" },\n        _vertical: { pb: \"{slide-gap}\" },\n      },\n      boxSize: \"full\",\n      flex: \"0 0 {slide-size}\",\n      position: \"relative\",\n    },\n    list: {\n      \"&[data-include-gap-in-size]\": {\n        _horizontal: { mr: \"calc({slide-gap} * -1)\" },\n        _vertical: { mb: \"calc({slide-gap} * -1)\" },\n      },\n      display: \"flex\",\n      h: \"full\",\n      _horizontal: { flexDirection: \"row\" },\n      _vertical: { flexDirection: \"column\" },\n    },\n    next: {\n      _horizontal: {\n        right: \"4\",\n      },\n      _vertical: {\n        bottom: \"4\",\n      },\n    },\n    prev: {\n      _horizontal: {\n        left: \"4\",\n      },\n      _vertical: {\n        top: \"4\",\n      },\n    },\n    root: {\n      \"--slide-gap\": \"spaces.4\",\n      \"--slide-size\": \"sizes.full\",\n      overflow: \"hidden\",\n      position: \"relative\",\n      w: \"full\",\n    },\n    trigger: {\n      position: \"absolute\",\n      zIndex: \"kurillin\",\n      _horizontal: {\n        top: \"50%\",\n        transform: \"translateY(-50%)\",\n      },\n      _vertical: {\n        left: \"50%\",\n        transform: \"translateX(-50%) rotate(90deg)\",\n      },\n    },\n  },\n\n  sizes: {\n    sm: {\n      root: { h: \"sm\" },\n    },\n    md: {\n      root: { h: \"md\" },\n    },\n    lg: {\n      root: { h: \"lg\" },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n  },\n})\n\nexport type CarouselStyle = typeof carouselStyle\n"
    },
    {
      "name": "carousel.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport type {\n  CSSProps,\n  HTMLProps,\n  HTMLStyledProps,\n  Orientation,\n  ThemeProps,\n} from \"@yamada-ui/react\"\nimport type { IconButtonProps } from \"../button\"\nimport type { CarouselStyle } from \"./carousel.style\"\nimport type {\n  CarouselAlign,\n  CarouselContainScroll,\n  CarouselInViewThreshold,\n  UseCarouselProps,\n} from \"./use-carousel\"\nimport { cloneElement, isValidElement, useMemo } from \"react\"\nimport {\n  createSlotComponent,\n  styled,\n  varAttr,\n  dataAttr,\n} from \"@yamada-ui/react\"\nimport { IconButton } from \"../button\"\nimport { ChevronLeftIcon, ChevronRightIcon } from \"../icon\"\nimport { carouselStyle } from \"./carousel.style\"\nimport {\n  CarouselContext,\n  useCarousel,\n  useCarouselContext,\n} from \"./use-carousel\"\n\ninterface ComponentContext\n  extends Pick<CarouselRootProps, \"includeGapInSize\"> {}\n\nexport interface CarouselRootProps\n  extends Omit<HTMLStyledProps<\"section\">, \"draggable\" | \"onChange\">,\n    Omit<\n      UseCarouselProps,\n      | \"align\"\n      | \"autoplay\"\n      | \"containScroll\"\n      | \"delay\"\n      | \"dragFree\"\n      | \"draggable\"\n      | \"duration\"\n      | \"inViewThreshold\"\n      | \"loop\"\n      | \"orientation\"\n      | \"skipSnaps\"\n      | \"slidesToScroll\"\n      | \"stopMouseEnterAutoplay\"\n    >,\n    ThemeProps<CarouselStyle> {\n  /**\n   * The alignment of the carousel.\n   *\n   * @default 'center'\n   */\n  align?: CarouselAlign\n  /**\n   * If `true`, the carousel will be autoplay.\n   *\n   * @default false\n   */\n  autoplay?: boolean\n  /**\n   * Clear leading and trailing empty space that causes excessive scrolling.\n   * Use trimSnaps to only use snap points that trigger scrolling or keepSnaps to keep them.\n   *\n   * @default false\n   */\n  containScroll?: CarouselContainScroll\n  /**\n   * The number for the autoplay interval of the carousel.\n   *\n   * @default 4000\n   */\n  delay?: number\n  /**\n   * If `true`, momentum scrolling will be enabled.\n   *\n   * @default false\n   */\n  dragFree?: boolean\n  /**\n   * If `true`, carousel can be scrolled with mouse and touch interactions.\n   *\n   * @default true\n   */\n  draggable?: boolean\n  /**\n   * Set scroll duration when triggered by any of the API methods.\n   * Higher numbers enables slower scrolling.\n   * Drag interactions are not affected because duration is then determined by the drag force.\n   *\n   * @default 25\n   */\n  duration?: number\n  /**\n   * If `true`, gap will be treated as part of the carousel slide size.\n   *\n   * @default true\n   */\n  includeGapInSize?: boolean\n  /**\n   * Choose a fraction representing the percentage portion of a slide that needs to be visible in order to be considered in view.\n   *\n   * @default 0\n   */\n  inViewThreshold?: CarouselInViewThreshold\n  /**\n   * If `true`, infinite looping.\n   * Automatically falls back to false if slide content isn't enough to loop.\n   *\n   * @default true\n   */\n  loop?: boolean\n  /**\n   * The orientation of the carousel.\n   *\n   * @default 'horizontal'\n   */\n  orientation?: Orientation\n  /**\n   * If `true`, allow the carousel to skip scroll snaps if it's dragged vigorously.\n   * Note that this option will be ignored if the dragFree option is set to true.\n   *\n   * @default false\n   */\n  skipSnaps?: boolean\n  /**\n   * The size of the carousel item.\n   */\n  slideSize?: CSSProps[\"width\"]\n  /**\n   * The number of slides that should be scrolled with next or previous buttons.\n   *\n   * @default 1\n   */\n  slidesToScroll?: number\n  /**\n   * If `true`, autoplay will pause when the mouse entries over.\n   *\n   * @default true\n   */\n  stopMouseEnterAutoplay?: boolean\n}\n\nconst {\n  ComponentContext,\n  PropsContext: CarouselPropsContext,\n  useComponentContext,\n  usePropsContext: useCarouselPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<CarouselRootProps, CarouselStyle>(\n  \"carousel\",\n  carouselStyle,\n)\n\nexport { CarouselPropsContext, useCarouselPropsContext }\n\n/**\n * `Carousel` is a component that displays multiple elements like a slideshow.\n *\n * @see https://yamada-ui.com/docs/components/carousel\n */\nexport const CarouselRoot = withProvider<\"section\", CarouselRootProps>(\n  ({ includeGapInSize = true, ...rest }) => {\n    const {\n      carousel,\n      index,\n      setIndex,\n      snapCount,\n      total,\n      getIndicatorProps,\n      getIndicatorsProps,\n      getItemProps,\n      getListProps,\n      getNextTriggerProps,\n      getPrevTriggerProps,\n      getRootProps,\n    } = useCarousel(rest)\n    const componentContext = useMemo(\n      () => ({ includeGapInSize }),\n      [includeGapInSize],\n    )\n    const carouselContext = useMemo(\n      () => ({\n        carousel,\n        index,\n        setIndex,\n        snapCount,\n        total,\n        getIndicatorProps,\n        getIndicatorsProps,\n        getItemProps,\n        getListProps,\n        getNextTriggerProps,\n        getPrevTriggerProps,\n      }),\n      [\n        carousel,\n        total,\n        index,\n        setIndex,\n        snapCount,\n        getIndicatorProps,\n        getIndicatorsProps,\n        getItemProps,\n        getListProps,\n        getNextTriggerProps,\n        getPrevTriggerProps,\n      ],\n    )\n\n    return (\n      <CarouselContext value={carouselContext}>\n        <ComponentContext value={componentContext}>\n          <styled.section {...getRootProps()} />\n        </ComponentContext>\n      </CarouselContext>\n    )\n  },\n  \"root\",\n)(undefined, ({ gap, slideSize, ...rest }) => {\n  return {\n    ...rest,\n    \"--slide-gap\": varAttr(gap, \"spaces\"),\n    \"--slide-size\": varAttr(slideSize, \"sizes\"),\n  }\n})\n\nexport interface CarouselListProps extends HTMLStyledProps {}\n\nexport const CarouselList = withContext<\"div\", CarouselListProps>(\n  \"div\",\n  \"list\",\n)(undefined, (props) => {\n  const { includeGapInSize } = useComponentContext()\n  const { getListProps } = useCarouselContext()\n\n  return {\n    \"data-include-gap-in-size\": dataAttr(includeGapInSize),\n    ...getListProps(props),\n  }\n})\n\nexport interface CarouselItemProps extends HTMLStyledProps {\n  /**\n   * The index of the carousel item.\n   */\n  index: number\n  /**\n   * The size of the carousel item.\n   */\n  slideSize?: CSSProps[\"width\"]\n}\n\nexport const CarouselItem = withContext<\"div\", CarouselItemProps>(\n  \"div\",\n  \"item\",\n)(undefined, ({ slideSize, ...rest }) => {\n  const { includeGapInSize } = useComponentContext()\n  const { getItemProps } = useCarouselContext()\n\n  return {\n    \"data-include-gap-in-size\": dataAttr(includeGapInSize),\n    \"--slide-size\": varAttr(slideSize, \"sizes\"),\n    ...getItemProps(rest),\n  }\n})\n\nexport interface CarouselPrevTriggerProps extends IconButtonProps {}\n\nexport const CarouselPrevTrigger = withContext<\n  \"button\",\n  CarouselPrevTriggerProps\n>(IconButton, { name: \"PrevTrigger\", slot: [\"trigger\", \"prev\"] })(\n  undefined,\n  (props) => {\n    const { getPrevTriggerProps } = useCarouselContext()\n\n    return {\n      fullRounded: true,\n      icon: <ChevronLeftIcon />,\n      ...getPrevTriggerProps(props),\n    }\n  },\n)\n\nexport interface CarouselNextTriggerProps extends IconButtonProps {}\n\nexport const CarouselNextTrigger = withContext<\n  \"button\",\n  CarouselNextTriggerProps\n>(IconButton, { name: \"NextTrigger\", slot: [\"trigger\", \"next\"] })(\n  undefined,\n  (props) => {\n    const { getNextTriggerProps } = useCarouselContext()\n\n    return {\n      fullRounded: true,\n      icon: <ChevronRightIcon />,\n      ...getNextTriggerProps(props),\n    }\n  },\n)\n\nexport interface CarouselIndicatorsProps extends HTMLStyledProps {\n  /**\n   * The function used to generate children.\n   * it will be called with `{ index: number; selected: boolean }`.\n   */\n  render?: (props: { index: number; selected: boolean }) => ReactNode\n}\n\nexport const CarouselIndicators = withContext<\"div\", CarouselIndicatorsProps>(\n  \"div\",\n  \"indicators\",\n)(undefined, ({ children, render, ...rest }) => {\n  const {\n    index: selectedIndex,\n    snapCount,\n    getIndicatorProps,\n    getIndicatorsProps,\n  } = useCarouselContext()\n  const computedChildren = useMemo(() => {\n    if (children) {\n      return children\n    } else {\n      return Array.from({ length: snapCount }, (_, index) => {\n        if (render) {\n          const component = render({ index, selected: index === selectedIndex })\n\n          if (isValidElement<HTMLProps<\"button\">>(component)) {\n            return cloneElement(component, {\n              ...getIndicatorProps({ key: index, index }),\n            })\n          } else {\n            return component\n          }\n        } else {\n          return <CarouselIndicator key={index} index={index} />\n        }\n      })\n    }\n  }, [children, getIndicatorProps, render, selectedIndex, snapCount])\n\n  return {\n    children: computedChildren,\n    ...getIndicatorsProps(rest),\n  }\n})\n\nexport interface CarouselIndicatorProps extends HTMLStyledProps<\"button\"> {\n  /**\n   * The index of the carousel indicator.\n   */\n  index: number\n}\n\nexport const CarouselIndicator = withContext<\"button\", CarouselIndicatorProps>(\n  \"button\",\n  \"indicator\",\n)(undefined, (props) => {\n  const { getIndicatorProps } = useCarouselContext()\n\n  return getIndicatorProps(props)\n})\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./carousel.style\"\nexport {\n  CarouselIndicator,\n  CarouselIndicators,\n  CarouselItem,\n  CarouselList,\n  CarouselNextTrigger,\n  CarouselPrevTrigger,\n  CarouselPropsContext,\n  CarouselRoot,\n  useCarouselPropsContext,\n} from \"./carousel\"\nexport type {\n  CarouselIndicatorProps,\n  CarouselIndicatorsProps,\n  CarouselItemProps,\n  CarouselListProps,\n  CarouselNextTriggerProps,\n  CarouselPrevTriggerProps,\n  CarouselRootProps,\n} from \"./carousel\"\nexport * as Carousel from \"./namespace\"\nexport * from \"./use-carousel\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  CarouselIndicator as Indicator,\n  CarouselIndicators as Indicators,\n  CarouselItem as Item,\n  CarouselList as List,\n  CarouselNextTrigger as NextTrigger,\n  CarouselPrevTrigger as PrevTrigger,\n  CarouselPropsContext as PropsContext,\n  CarouselRoot as Root,\n  useCarouselPropsContext as usePropsContext,\n} from \"./carousel\"\nexport type {\n  CarouselIndicatorProps as IndicatorProps,\n  CarouselIndicatorsProps as IndicatorsProps,\n  CarouselItemProps as ItemProps,\n  CarouselListProps as ListProps,\n  CarouselNextTriggerProps as NextTriggerProps,\n  CarouselPrevTriggerProps as PrevTriggerProps,\n  CarouselRootProps as RootProps,\n} from \"./carousel\"\nexport type { CarouselControl as Control } from \"./use-carousel\"\n"
    },
    {
      "name": "use-carousel.ts",
      "content": "\"use client\"\n\nimport type {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType,\n} from \"embla-carousel\"\nimport type { KeyboardEvent, RefObject } from \"react\"\nimport type {\n  HTMLProps,\n  Orientation,\n  PropGetter,\n  RequiredPropGetter,\n} from \"@yamada-ui/react\"\nimport useEmblaCarousel from \"embla-carousel-react\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport { useBoolean } from \"../../hooks/use-boolean\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport {\n  assignRef,\n  createContext,\n  dataAttr,\n  handlerAll,\n  isFunction,\n  mergeRefs,\n  runKeyAction,\n  useIds,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\n\ntype EmblaOptions = Required<EmblaOptionsType>\nexport type CarouselAlign = EmblaOptions[\"align\"]\nexport type CarouselContainScroll = EmblaOptions[\"containScroll\"]\nexport type CarouselInViewThreshold = EmblaOptions[\"inViewThreshold\"]\nexport type CarouselWatchDrag = EmblaOptions[\"watchDrag\"]\nexport type CarouselWatchResize = EmblaOptions[\"watchResize\"]\nexport type CarouselWatchSlides = EmblaOptions[\"watchSlides\"]\nexport type CarouselControl = EmblaCarouselType\nexport type CarouselPlugin = EmblaPluginType\n\nexport interface CarouselContext\n  extends Omit<UseCarouselReturn, \"getRootProps\"> {}\n\nconst [CarouselContext, useCarouselContext] = createContext<CarouselContext>({\n  name: \"CarouselContext\",\n})\n\nexport { CarouselContext, useCarouselContext }\n\nexport interface UseCarouselProps\n  extends Omit<HTMLProps<\"section\">, \"onChange\"> {\n  /**\n   * The alignment of the carousel.\n   *\n   * @default 'center'\n   */\n  align?: CarouselAlign\n  /**\n   * If `true`, the carousel will be autoplay.\n   *\n   * @default false\n   */\n  autoplay?: boolean\n  /**\n   * Clear leading and trailing empty space that causes excessive scrolling.\n   * Use trimSnaps to only use snap points that trigger scrolling or keepSnaps to keep them.\n   *\n   * @default false\n   */\n  containScroll?: CarouselContainScroll\n  /**\n   * Ref of the resizable item callback.\n   */\n  controlRef?: RefObject<CarouselControl | null>\n  /**\n   * The initial index of the carousel slide.\n   *\n   * @default 0\n   */\n  defaultIndex?: number\n  /**\n   * The number for the autoplay interval of the carousel.\n   *\n   * @default 4000\n   */\n  delay?: number\n  /**\n   * If `true`, momentum scrolling will be enabled.\n   *\n   * @default false\n   */\n  dragFree?: boolean\n  /**\n   * If `true`, carousel can be scrolled with mouse and touch interactions.\n   *\n   * @default true\n   */\n  draggable?: boolean\n  /**\n   * Set scroll duration when triggered by any of the API methods.\n   * Higher numbers enables slower scrolling.\n   * Drag interactions are not affected because duration is then determined by the drag force.\n   *\n   * @default 25\n   */\n  duration?: number\n  /**\n   * The index of the carousel slide.\n   */\n  index?: number\n  /**\n   * Choose a fraction representing the percentage portion of a slide that needs to be visible in order to be considered in view.\n   *\n   * @default 0\n   */\n  inViewThreshold?: CarouselInViewThreshold\n  /**\n   * If `true`, infinite looping.\n   * Automatically falls back to false if slide content isn't enough to loop.\n   *\n   * @default true\n   */\n  loop?: boolean\n  /**\n   * The orientation of the carousel.\n   *\n   * @default 'horizontal'\n   */\n  orientation?: Orientation\n  /**\n   * Embla plugins to use.\n   */\n  plugins?: CarouselPlugin[]\n  /**\n   * If `true`, allow the carousel to skip scroll snaps if it's dragged vigorously.\n   * Note that this option will be ignored if the dragFree option is set to true.\n   *\n   * @default false\n   */\n  skipSnaps?: boolean\n  /**\n   * The number of slides that should be scrolled with next or previous buttons.\n   *\n   * @default 1\n   */\n  slidesToScroll?: number\n  /**\n   * If `true`, autoplay will pause when the mouse entries over.\n   *\n   * @default true\n   */\n  stopMouseEnterAutoplay?: boolean\n  /**\n   * Enables for scrolling the carousel with mouse and touch interactions.\n   * Set this to `false` to disable drag events or pass a custom callback to add your own drag logic.\n   *\n   * @default true\n   */\n  watchDrag?: CarouselWatchDrag\n  /**\n   * Embla automatically watches the container and slides for size changes and runs `reInit` when any size has changed.\n   * Set this to `false` to disable this behaviour or pass a custom callback to add your own resize logic.\n   *\n   * @default true\n   */\n  watchResize?: CarouselWatchResize\n  /**\n   * Embla automatically watches the container for added and/or removed slides and runs `reInit` if needed.\n   * Set this to `false` to disable this behaviour or pass a custom callback to add your own slides changed logic.\n   *\n   * @default true\n   */\n  watchSlides?: CarouselWatchSlides\n  /**\n   * The callback invoked when carousel slide selected.\n   */\n  onChange?: (index: number) => void\n  /**\n   * A callback that return the current scroll amount when the carousel is scrolled.\n   */\n  onScrollProgress?: (progress: number) => void\n}\n\nexport const useCarousel = ({\n  id,\n  align = \"center\",\n  autoplay = false,\n  containScroll = false,\n  controlRef,\n  defaultIndex = 0,\n  delay = 4000,\n  dragFree = false,\n  draggable = true,\n  duration = 25,\n  index: indexProp,\n  inViewThreshold = 0,\n  loop = true,\n  orientation = \"horizontal\",\n  plugins = [],\n  skipSnaps = false,\n  slidesToScroll = 1,\n  stopMouseEnterAutoplay = true,\n  watchDrag = draggable,\n  watchResize: watchResizeProp = true,\n  watchSlides = true,\n  onChange,\n  onScrollProgress,\n  ...rest\n}: UseCarouselProps = {}) => {\n  const { t } = useI18n(\"carousel\")\n  const [index, setIndex] = useControllableState({\n    defaultValue: defaultIndex,\n    value: indexProp,\n    onChange,\n  })\n  const [rootId, listId] = useIds()\n  const [hover, { off: onMouseLeave, on: onMouseEnter }] = useBoolean()\n  const timeoutId = useRef<NodeJS.Timeout | null>(null)\n  const indicatorMapRef = useRef<Map<number, HTMLButtonElement | null>>(\n    new Map(),\n  )\n  const listRef = useRef<HTMLDivElement>(null)\n  const horizontal = orientation === \"horizontal\"\n  const axis = horizontal ? \"x\" : \"y\"\n  const [snapCount, setSnapCount] = useState(0)\n  const [total, setTotal] = useState(0)\n  const watchResize = useCallback<Extract<CarouselWatchResize, Function>>(\n    (methods, entries) => {\n      const result = isFunction(watchResizeProp)\n        ? watchResizeProp(methods, entries)\n        : true\n      const snapCount = methods.scrollSnapList().length\n      const total = methods.slideNodes().length\n\n      setSnapCount(snapCount)\n      setTotal(total)\n\n      return result\n    },\n    [watchResizeProp],\n  )\n  const [carouselRef, carousel] = useEmblaCarousel(\n    {\n      align,\n      axis,\n      container: listRef.current,\n      containScroll,\n      dragFree,\n      duration,\n      inViewThreshold,\n      loop,\n      skipSnaps,\n      slidesToScroll,\n      startIndex: defaultIndex,\n      watchDrag,\n      watchResize,\n      watchSlides,\n    },\n    plugins,\n  )\n\n  id ??= rootId\n\n  const onInit = useCallback((methods: CarouselControl) => {\n    const snapCount = methods.scrollSnapList().length\n    const total = methods.slideNodes().length\n\n    setSnapCount(snapCount)\n    setTotal(total)\n  }, [])\n\n  const onScroll = useCallback(() => {\n    if (!carousel) return\n\n    const progress = Math.round(\n      Math.max(0, Math.min(1, carousel.scrollProgress())) * 100,\n    )\n\n    onScrollProgress?.(progress)\n  }, [carousel, onScrollProgress])\n\n  const onSelect = useCallback(() => {\n    if (!carousel) return\n\n    const index = carousel.selectedScrollSnap()\n\n    setIndex(index)\n  }, [carousel, setIndex])\n\n  const onFocusIndicator = useCallback(\n    (index: number) => {\n      const el = indicatorMapRef.current.get(index)\n\n      el?.focus()\n      carousel?.scrollTo(index)\n    },\n    [carousel],\n  )\n\n  const onKeyDown = useCallback(\n    (index: number) => (ev: KeyboardEvent<HTMLButtonElement>) => {\n      const lastIndex = snapCount - 1\n\n      runKeyAction(ev, {\n        ArrowDown: () => {\n          if (horizontal) return\n\n          index = index === lastIndex ? 0 : index + 1\n\n          onFocusIndicator(index)\n        },\n        ArrowLeft: () => {\n          if (!horizontal) return\n\n          index = index === 0 ? lastIndex : index - 1\n\n          onFocusIndicator(index)\n        },\n        ArrowRight: () => {\n          if (!horizontal) return\n\n          index = index === lastIndex ? 0 : index + 1\n\n          onFocusIndicator(index)\n        },\n        ArrowUp: () => {\n          if (horizontal) return\n\n          index = index === 0 ? lastIndex : index - 1\n\n          onFocusIndicator(index)\n        },\n        End: () => {\n          onFocusIndicator(lastIndex)\n        },\n        Home: () => {\n          onFocusIndicator(0)\n        },\n      })\n    },\n    [snapCount, horizontal, onFocusIndicator],\n  )\n\n  assignRef(controlRef, carousel)\n\n  useEffect(() => {\n    if (carousel) {\n      carousel.on(\"reInit\", onInit)\n      carousel.on(\"select\", onSelect)\n      carousel.on(\"scroll\", onScroll)\n\n      onScroll()\n\n      return () => {\n        carousel.off(\"reInit\", onInit)\n        carousel.off(\"select\", onSelect)\n        carousel.off(\"scroll\", onScroll)\n      }\n    }\n  }, [carousel, onInit, onScroll, onSelect])\n\n  useEffect(() => {\n    const stop = hover && stopMouseEnterAutoplay\n    const last = !carousel?.canScrollNext()\n\n    if (carousel && autoplay && !stop && !last) {\n      timeoutId.current = setInterval(() => {\n        carousel.scrollNext()\n      }, delay)\n    } else {\n      if (timeoutId.current) clearInterval(timeoutId.current)\n\n      timeoutId.current = null\n    }\n\n    return () => {\n      if (timeoutId.current) clearInterval(timeoutId.current)\n    }\n  }, [autoplay, carousel, delay, hover, stopMouseEnterAutoplay])\n\n  useUpdateEffect(() => {\n    if (!carousel) return\n\n    if (indexProp === undefined) return\n\n    carousel.scrollTo(indexProp)\n  }, [indexProp])\n\n  useUpdateEffect(() => {\n    if (!carousel) return\n\n    carousel.reInit()\n  }, [\n    carousel,\n    total,\n    align,\n    axis,\n    containScroll,\n    dragFree,\n    duration,\n    inViewThreshold,\n    loop,\n    skipSnaps,\n    slidesToScroll,\n  ])\n\n  const getRootProps: PropGetter<\"section\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      id,\n      \"aria-roledescription\": \"carousel\",\n      \"data-orientation\": orientation,\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref, carouselRef),\n      onMouseEnter: handlerAll(props.onMouseEnter, onMouseEnter),\n      onMouseLeave: handlerAll(props.onMouseLeave, onMouseLeave),\n    }),\n    [id, onMouseEnter, onMouseLeave, rest, carouselRef, orientation],\n  )\n\n  const getListProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      id: listId,\n      \"aria-live\": autoplay ? \"off\" : \"polite\",\n      \"data-orientation\": orientation,\n      ...props,\n      ref: mergeRefs(ref, listRef),\n    }),\n    [autoplay, listId, orientation],\n  )\n\n  const getItemProps: RequiredPropGetter<\"div\", { index: number }> =\n    useCallback(\n      ({ index: indexProp, ...props }) => {\n        const page = indexProp + 1\n        const selected = index === indexProp\n\n        return {\n          id: `${listId}-${indexProp}`,\n          \"aria-label\": t(\"{page} of {total}\", { page, total }),\n          \"aria-roledescription\": \"slide\",\n          \"data-index\": indexProp.toString(),\n          \"data-orientation\": orientation,\n          \"data-selected\": dataAttr(selected),\n          role: \"tabpanel\",\n          ...props,\n        }\n      },\n      [index, listId, total, orientation, t],\n    )\n\n  const getPrevTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      \"aria-controls\": listId,\n      \"aria-label\": t(\"Go to previous slide\"),\n      \"data-orientation\": orientation,\n      disabled: !carousel?.canScrollPrev(),\n      ...props,\n      onClick: handlerAll(props.onClick, () => carousel?.scrollPrev()),\n    }),\n    [carousel, listId, orientation, t],\n  )\n\n  const getNextTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      \"aria-controls\": listId,\n      \"aria-label\": t(\"Go to next slide\"),\n      \"data-orientation\": orientation,\n      disabled: !carousel?.canScrollNext(),\n      ...props,\n      onClick: handlerAll(props.onClick, () => carousel?.scrollNext()),\n    }),\n    [carousel, listId, orientation, t],\n  )\n\n  const getIndicatorsProps: PropGetter = useCallback(\n    (props = {}) => ({\n      \"aria-label\": t(\"Slides\"),\n      \"aria-orientation\": orientation,\n      role: \"tablist\",\n      ...props,\n    }),\n    [orientation, t],\n  )\n\n  const getIndicatorProps: RequiredPropGetter<\"button\", { index: number }> =\n    useCallback(\n      ({ ref, index: indexProp, ...props }) => {\n        const page = indexProp + 1\n        const selected = index === indexProp\n\n        return {\n          type: \"button\" as const,\n          \"aria-controls\": `${listId}-${indexProp}`,\n          \"aria-label\": t(\"Go to {page} slide\", { page }),\n          \"aria-selected\": selected,\n          \"data-index\": indexProp.toString(),\n          \"data-orientation\": orientation,\n          \"data-selected\": dataAttr(selected),\n          role: \"tab\",\n          tabIndex: selected ? 0 : -1,\n          ...props,\n          ref: mergeRefs(ref, (node) => {\n            indicatorMapRef.current.set(indexProp, node)\n          }),\n          onClick: handlerAll(props.onClick, () =>\n            carousel?.scrollTo(indexProp),\n          ),\n          onKeyDown: handlerAll(props.onKeyDown, onKeyDown(indexProp)),\n        }\n      },\n      [index, listId, t, orientation, onKeyDown, carousel],\n    )\n\n  return {\n    carousel,\n    index,\n    setIndex,\n    snapCount,\n    total,\n    getIndicatorProps,\n    getIndicatorsProps,\n    getItemProps,\n    getListProps,\n    getNextTriggerProps,\n    getPrevTriggerProps,\n    getRootProps,\n  }\n}\n\nexport type UseCarouselReturn = ReturnType<typeof useCarousel>\n"
    }
  ]
}
