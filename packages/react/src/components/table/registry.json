{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["checkbox", "icon", "native-table"],
    "externals": ["@tanstack/react-table@^8.21.3"],
    "hooks": ["use-controllable-state"],
    "providers": ["i18n-provider"]
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export type { TableProps } from \"./table\"\nexport {\n  createColumnHelper,\n  Table,\n  TablePropsContext,\n  useTablePropsContext,\n} from \"./table\"\n"
    },
    {
      "name": "table.tsx",
      "content": "\"use client\"\n\nimport type {\n  AccessorFn,\n  Cell,\n  CellContext,\n  ColumnDef,\n  ColumnDefTemplate,\n  ColumnFiltersColumnDef,\n  ColumnFiltersState,\n  ColumnMeta,\n  ColumnPinningColumnDef,\n  ColumnSizingColumnDef,\n  GlobalFilterColumnDef,\n  GroupingColumnDef,\n  Header,\n  HeaderContext,\n  HeaderGroup,\n  OnChangeFn,\n  SortingState as OriginalSortingState,\n  PaginationState,\n  Table as ReactTable,\n  Row,\n  RowData,\n  RowSelectionState,\n  SortDirection,\n  SortingColumnDef,\n  TableOptions,\n  VisibilityColumnDef,\n} from \"@tanstack/react-table\"\nimport type { FC, FocusEvent, KeyboardEvent, ReactElement } from \"react\"\nimport type {\n  CSSProps,\n  GenericsComponent,\n  HTMLStyledProps,\n  ReactNodeOrFunction,\n  TransformProps,\n} from \"@yamada-ui/react\"\nimport type { CheckboxProps } from \"../checkbox\"\nimport {\n  createColumnHelper,\n  flexRender,\n  getCoreRowModel,\n  getFilteredRowModel,\n  getPaginationRowModel,\n  getSortedRowModel,\n  useReactTable,\n} from \"@tanstack/react-table\"\nimport { useMemo, useRef } from \"react\"\nimport {\n  createComponent,\n  focusRingStyle,\n  mergeProps,\n  styled,\n  ariaAttr,\n  dataAttr,\n  isFunction,\n  runIfFn,\n  runKeyAction,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport { Checkbox } from \"../checkbox\"\nimport { ChevronsUpDownIcon, ChevronUpIcon } from \"../icon\"\nimport { NativeTable } from \"../native-table\"\n\ndeclare module \"@tanstack/react-table\" {\n  interface ColumnDefExtensions<TData extends RowData, TValue = unknown>\n    extends\n      VisibilityColumnDef,\n      ColumnPinningColumnDef,\n      ColumnFiltersColumnDef<TData>,\n      GlobalFilterColumnDef,\n      SortingColumnDef<TData>,\n      GroupingColumnDef<TData, TValue>,\n      ColumnSizingColumnDef {}\n\n  interface ColumnDefBase<TData extends RowData, TValue = unknown>\n    extends\n      ColumnDefExtensions<TData, TValue>,\n      Pick<CSSProps, \"lineClamp\" | \"truncated\">,\n      Pick<NativeTable.TdProps, \"numeric\"> {\n    cell?: ColumnDefTemplate<CellContext<TData, TValue>>\n    footer?: ColumnDefTemplate<HeaderContext<TData, TValue>>\n    getUniqueValues?: AccessorFn<TData, unknown[]>\n    meta?: ColumnMeta<TData, TValue>\n    cellProps?: NativeTable.TdProps\n    footerProps?: NativeTable.ThProps\n    headerProps?: NativeTable.ThProps\n  }\n}\n\nexport { createColumnHelper }\nexport type {\n  ColumnDef,\n  ColumnFiltersState,\n  PaginationState,\n  RowSelectionState,\n  SortDirection,\n}\n\nfunction getMergeHeaderGroups(\n  headerGroups: HeaderGroup<any>[],\n): HeaderGroup<any>[] {\n  if (headerGroups.length <= 1) return headerGroups\n\n  const columnsIds = new Set()\n\n  return headerGroups.map((headerGroup, depth, { length: fullDepth }) => {\n    return {\n      ...headerGroup,\n      headers: headerGroup.headers\n        .filter((header) => !columnsIds.has(header.column.id))\n        .map((header) => {\n          columnsIds.add(header.column.id)\n\n          return header.isPlaceholder\n            ? { ...header, isPlaceholder: false, rowSpan: fullDepth - depth }\n            : { ...header, rowSpan: 1 }\n        }),\n    }\n  })\n}\n\nfunction getMergeFooterGroups(\n  headerGroups: HeaderGroup<any>[],\n): HeaderGroup<any>[] {\n  if (headerGroups.length <= 1) return headerGroups\n\n  return headerGroups.map((headerGroup, depth) => {\n    const nextHeaderGroups = headerGroups.slice(depth + 1)\n\n    return {\n      ...headerGroup,\n      headers: headerGroup.headers\n        .filter((header) => !header.isPlaceholder)\n        .map((header) => {\n          if (nextHeaderGroups.length === 0) return header\n\n          const rowSpan = nextHeaderGroups.reduce((acc, nextHeaderGroup) => {\n            const hasNextHeader = nextHeaderGroup.headers.some(\n              (nextHeader) => nextHeader.column.id === header.column.id,\n            )\n\n            return acc + (hasNextHeader ? 1 : 0)\n          }, 1)\n\n          return { ...header, rowSpan }\n        }),\n    }\n  })\n}\n\nexport interface ColumnSort<Y extends RowData> {\n  id: keyof Y\n  desc: boolean\n}\nexport type SortingState<Y extends RowData> = ColumnSort<Y>[]\n\ninterface ComponentContext extends Pick<\n  TableProps<any>,\n  | \"columnResizeMode\"\n  | \"resizableTriggerProps\"\n  | \"sortingIcon\"\n  | \"sortingIconProps\"\n> {\n  table: ReactTable<any>\n}\n\ninterface OmittedTableOptions<Y extends RowData> extends Omit<\n  TableOptions<Y>,\n  | \"getCoreRowModel\"\n  | \"onColumnFiltersChange\"\n  | \"onPaginationChange\"\n  | \"onSortingChange\"\n> {}\n\ninterface PickedNativeTableProps extends Pick<\n  NativeTable.RootProps,\n  | \"highlightOnHover\"\n  | \"highlightOnSelected\"\n  | \"layout\"\n  | \"scrollAreaProps\"\n  | \"size\"\n  | \"stickyFooter\"\n  | \"stickyHeader\"\n  | \"striped\"\n  | \"variant\"\n  | \"withBorder\"\n  | \"withColumnBorders\"\n  | \"withScrollArea\"\n> {}\n\nexport interface TableProps<Y extends RowData>\n  extends\n    OmittedTableOptions<Y>,\n    PickedNativeTableProps,\n    Pick<CSSProps, \"colorScheme\" | \"lineClamp\" | \"truncated\"> {\n  /**\n   * The column filters state of the table.\n   */\n  columnFilters?: ColumnFiltersState\n  /**\n   * The default column filters state of the table.\n   */\n  defaultColumnFilters?: ColumnFiltersState\n  /**\n   * The default pagination state of the table.\n   */\n  defaultPagination?: PaginationState\n  /**\n   * The default row selection state of the table.\n   */\n  defaultRowSelection?: RowSelectionState\n  /**\n   * The default sorting state of the table.\n   */\n  defaultSorting?: SortingState<Y>\n  /**\n   * If `true`, the table width will be automatically resized to the content.\n   *\n   * @default false\n   */\n  enableAutoResizeTableWidth?: boolean\n  /**\n   * If `true`, the keyboard navigation will be enabled.\n   *\n   * @default true\n   */\n  enableKeyboardNavigation?: boolean\n  /**\n   * If `true`, the pagination will be enabled.\n   *\n   * @default false\n   */\n  enablePagination?: boolean\n  /**\n   * The footer of the table.\n   */\n  footer?: ReactNodeOrFunction<ReactTable<Y>>\n  /**\n   * The header of the table.\n   */\n  header?: ReactNodeOrFunction<ReactTable<Y>>\n  /**\n   * The initial focusable cell of the table.\n   *\n   * @default {rowIndex: 0, colIndex: 0}\n   */\n  initialFocusableCell?: { colIndex: number; rowIndex: number }\n  /**\n   * The pagination state of the table.\n   */\n  pagination?: PaginationState\n  /**\n   * The row selection state of the table.\n   */\n  rowSelection?: RowSelectionState\n  /**\n   * If `true`, the row will be selected when the row is clicked.\n   *\n   * @default false\n   */\n  selectOnClickRow?: boolean\n  /**\n   * The sorting state of the table.\n   */\n  sorting?: SortingState<Y>\n  /**\n   * The sorting icon of the table.\n   */\n  sortingIcon?: ReactNodeOrFunction<false | SortDirection>\n  /**\n   * If `true`, the table will have a checkbox column.\n   *\n   * @default true\n   */\n  withCheckbox?: boolean\n  /**\n   * If `true`, the table will have a checkbox in the footer.\n   *\n   * @default false\n   */\n  withFooterCheckbox?: boolean\n  /**\n   * If `true`, the table will have footer groups.\n   *\n   * @default false\n   */\n  withFooterGroups?: boolean\n  /**\n   * The props for the table cell.\n   */\n  cellProps?: TransformProps<NativeTable.TdProps, Cell<Y, unknown>>\n  /**\n   * The props for the checkbox.\n   */\n  checkboxProps?: CheckboxProps\n  /**\n   * The props for the table footer group.\n   */\n  footerGroupProps?: TransformProps<NativeTable.TrProps, HeaderGroup<Y>>\n  /**\n   * The props for the table footer.\n   */\n  footerProps?: TransformProps<NativeTable.ThProps, Header<Y, unknown>>\n  /**\n   * The props for the table header checkbox.\n   */\n  headerCheckboxProps?: TransformProps<CheckboxProps, Header<Y, unknown>>\n  /**\n   * The props for the table header group.\n   */\n  headerGroupProps?: TransformProps<NativeTable.TrProps, HeaderGroup<Y>>\n  /**\n   * The props for the table header.\n   */\n  headerProps?: TransformProps<NativeTable.ThProps, Header<Y, unknown>>\n  /**\n   * The props for the resizable trigger.\n   */\n  resizableTriggerProps?: TransformProps<\n    Omit<ResizableTriggerProps, \"resizing\">,\n    Header<Y, unknown>\n  >\n  /**\n   * The props for the table row checkbox.\n   */\n  rowCheckboxProps?: TransformProps<CheckboxProps, Row<Y>>\n  /**\n   * The props for the table row.\n   */\n  rowProps?: TransformProps<NativeTable.TrProps, Row<Y>>\n  /**\n   * The props for the sorting icon.\n   */\n  sortingIconProps?: TransformProps<\n    Omit<SortingIconProps, \"sorted\">,\n    Header<Y, unknown>\n  >\n  /**\n   * The props for the table.\n   */\n  tableProps?: NativeTable.RootProps\n  /**\n   * The props for the table tbody.\n   */\n  tbodyProps?: NativeTable.TbodyProps\n  /**\n   * The props for the table tfoot.\n   */\n  tfootProps?: NativeTable.TfootProps\n  /**\n   * The props for the table thead.\n   */\n  theadProps?: NativeTable.TheadProps\n  /**\n   * The callback invoked when the column filters state changes.\n   */\n  onColumnFiltersChange?: (columnFilters: ColumnFiltersState) => void\n  /**\n   * The callback invoked when the pagination state changes.\n   */\n  onPaginationChange?: (pagination: PaginationState) => void\n  /**\n   * The callback invoked when the row is clicked.\n   */\n  onRowClick?: (row: Row<Y>) => void\n  /**\n   * The callback invoked when the row is double clicked.\n   */\n  onRowDoubleClick?: (row: Row<Y>) => void\n  /**\n   * The callback invoked when the sorting state changes.\n   */\n  onSortingChange?: (sorting: SortingState<Y>) => void\n}\n\nconst {\n  ComponentContext,\n  PropsContext: TablePropsContext,\n  useComponentContext,\n  usePropsContext: useTablePropsContext,\n  withContext,\n} = createComponent<TableProps<any>, any, ComponentContext>(\"table\")\n\nexport { TablePropsContext, useTablePropsContext }\n\n/**\n * `Table` is a table component equipped with column sorting, row selection, and click event features.\n *\n * @see https://yamada-ui.com/docs/components/table\n */\nexport const Table = withContext(\n  <Y extends RowData>({\n    colorScheme,\n    size,\n    variant,\n    columnFilters: columnFiltersProp,\n    columnResizeMode = \"onChange\",\n    columns: columnsProp,\n    data,\n    defaultColumnFilters,\n    defaultPagination = { pageIndex: 0, pageSize: 20 },\n    defaultRowSelection = {},\n    defaultSorting,\n    enableAutoResizeTableWidth = false,\n    enableColumnResizing = false,\n    enableKeyboardNavigation = true,\n    enablePagination = false,\n    enableRowSelection = false,\n    footer,\n    header,\n    highlightOnHover = !!enableRowSelection,\n    highlightOnSelected = !!enableRowSelection,\n    initialFocusableCell = { colIndex: 0, rowIndex: 0 },\n    layout,\n    lineClamp,\n    manualPagination,\n    pagination: paginationProp,\n    rowCount: totalRowCount,\n    rowSelection: rowSelectionProp,\n    selectOnClickRow = false,\n    sortDescFirst = false,\n    sorting: sortingProp,\n    sortingIcon,\n    state,\n    stickyFooter,\n    stickyHeader,\n    striped,\n    truncated,\n    withBorder,\n    withCheckbox = true,\n    withColumnBorders,\n    withFooterCheckbox = false,\n    withFooterGroups = false,\n    withScrollArea,\n    cellProps,\n    checkboxProps,\n    footerGroupProps,\n    footerProps,\n    headerCheckboxProps,\n    headerGroupProps,\n    headerProps,\n    resizableTriggerProps,\n    rowCheckboxProps,\n    rowProps,\n    scrollAreaProps,\n    sortingIconProps,\n    tableProps,\n    tbodyProps,\n    tfootProps,\n    theadProps,\n    onColumnFiltersChange: onColumnFiltersChangeProp,\n    onPaginationChange: onPaginationChangeProp,\n    onRowClick,\n    onRowDoubleClick,\n    onRowSelectionChange: onRowSelectionChangeProp,\n    onSortingChange: onSortingChangeProp,\n    ...rest\n  }: TableProps<Y>) => {\n    const { t } = useI18n(\"table\")\n    const initialFocus = useRef<boolean>(false)\n    const ref = useRef<HTMLTableElement>(null)\n    const focusedCell = useRef<null | { colIndex: number; rowIndex: number }>(\n      null,\n    )\n    const [rowSelection, onRowSelectionChange] = useControllableState({\n      defaultValue: defaultRowSelection,\n      value: rowSelectionProp,\n      onChange: onRowSelectionChangeProp,\n    })\n    const [sorting, onSortingChange] = useControllableState({\n      defaultValue: defaultSorting,\n      value: sortingProp,\n      onChange: onSortingChangeProp,\n    })\n    const [pagination, onPaginationChange] = useControllableState({\n      defaultValue: defaultPagination,\n      value: paginationProp,\n      onChange: onPaginationChangeProp,\n    })\n    const [columnFilters, onColumnFiltersChange] = useControllableState({\n      defaultValue: defaultColumnFilters,\n      value: columnFiltersProp,\n      onChange: onColumnFiltersChangeProp,\n    })\n    const columns = useMemo(() => {\n      if (!enableRowSelection || !withCheckbox) return columnsProp\n\n      const clonedColumns = [...columnsProp]\n\n      const header = ({ header, table }: HeaderContext<Y, any>) => {\n        return (\n          <Checkbox\n            {...mergeProps(\n              {\n                checked: table.getIsAllRowsSelected(),\n                indeterminate: table.getIsSomeRowsSelected(),\n                indicatorProps: { outline: \"none\" },\n                inputProps: {\n                  \"aria-label\": t(\"Select all rows\"),\n                  \"data-focusable\": \"\",\n                  tabIndex: -1,\n                },\n                onChange: table.getToggleAllRowsSelectedHandler(),\n              },\n              checkboxProps ?? {},\n              runIfFn(headerCheckboxProps, header) ?? {},\n            )()}\n          />\n        )\n      }\n\n      const cell = ({ row }: CellContext<Y, any>) => {\n        return (\n          <Checkbox\n            {...mergeProps(\n              {\n                checked: row.getIsSelected(),\n                disabled: !row.getCanSelect(),\n                indeterminate: row.getIsSomeSelected(),\n                indicatorProps: { outline: \"none\" },\n                inputProps: {\n                  \"aria-label\": t(\"Select row\"),\n                  \"data-focusable\": \"\",\n                  tabIndex: -1,\n                },\n                onChange: row.getToggleSelectedHandler(),\n              },\n              checkboxProps ?? {},\n              runIfFn(rowCheckboxProps, row) ?? {},\n            )()}\n          />\n        )\n      }\n\n      clonedColumns.unshift({\n        id: \"select\",\n        cell,\n        header,\n        ...(withFooterCheckbox\n          ? { footer: header }\n          : { footerProps: { \"aria-hidden\": \"true\" } }),\n        cellProps: { verticalAlign: \"middle\" },\n        headerProps: { w: \"calc({spaces.4} + {space-x} * 2)\" },\n      })\n\n      return clonedColumns\n    }, [\n      checkboxProps,\n      columnsProp,\n      enableRowSelection,\n      headerCheckboxProps,\n      rowCheckboxProps,\n      t,\n      withCheckbox,\n      withFooterCheckbox,\n    ])\n    const table = useReactTable<Y>({\n      columnResizeMode,\n      columns,\n      data,\n      enableColumnResizing,\n      enableRowSelection,\n      getCoreRowModel: getCoreRowModel(),\n      getFilteredRowModel: getFilteredRowModel(),\n      getSortedRowModel: getSortedRowModel(),\n      manualPagination,\n      rowCount: totalRowCount,\n      sortDescFirst,\n      state: {\n        columnFilters,\n        pagination: enablePagination ? pagination : undefined,\n        rowSelection,\n        sorting: sorting as OriginalSortingState,\n        ...state,\n      },\n      onColumnFiltersChange,\n      onPaginationChange,\n      onRowSelectionChange,\n      onSortingChange: onSortingChange as OnChangeFn<OriginalSortingState>,\n      ...(enablePagination\n        ? { getPaginationRowModel: getPaginationRowModel() }\n        : {}),\n      ...rest,\n    })\n    const headerGroups = table.getHeaderGroups()\n    const mergedHeaderGroups = getMergeHeaderGroups(headerGroups)\n    const rows = table.getRowModel().rows\n    const footerGroups = table.getFooterGroups()\n    const mergedFooterGroups = getMergeFooterGroups(\n      withFooterGroups ? footerGroups : [],\n    )\n    const headerGroupCount = headerGroups.length\n    const rowCount = rows.length\n    const colCount = table.getAllLeafColumns().length\n    const maxColIndex = colCount - 1\n    const pageIndex = enablePagination\n      ? table.getState().pagination.pageIndex\n      : 0\n    const cellMap = useMemo(() => {\n      const cellMap = new Map<string, string>()\n\n      if (!enableKeyboardNavigation) return cellMap\n\n      const insertCellMap = (\n        id: string,\n        colSpan: number,\n        rowSpan: number,\n        colIndex: number,\n        rowIndex: number,\n      ) => {\n        for (let i = 0; i < colSpan; i++) {\n          cellMap.set(`${colIndex + i}-${rowIndex}`, `${colIndex}-${rowIndex}`)\n        }\n\n        for (let i = 1; i < rowSpan; i++) {\n          cellMap.set(`${colIndex}-${rowIndex + i}`, `${colIndex}-${rowIndex}`)\n        }\n      }\n\n      const insertCellMapByHeaderGroup = (\n        headerGroup: HeaderGroup<Y>,\n        rowIndex: number,\n      ) => {\n        let placeholderCount = 0\n\n        headerGroup.headers.forEach((header) => {\n          const colSpan = header.colSpan || 1\n          const rowSpan = header.rowSpan || 1\n          const colIndex = header.index + placeholderCount\n\n          placeholderCount += colSpan - 1\n\n          insertCellMap(header.id, colSpan, rowSpan, colIndex, rowIndex)\n        })\n      }\n\n      mergedHeaderGroups.forEach((headerGroup, rowIndex) => {\n        insertCellMapByHeaderGroup(headerGroup, rowIndex)\n      })\n\n      rows.forEach((row, rowIndex) => {\n        rowIndex += headerGroupCount\n\n        row.getVisibleCells().forEach((cell) => {\n          const colIndex = cell.column.getIndex()\n\n          insertCellMap(cell.id, 1, 1, colIndex, rowIndex)\n        })\n      })\n\n      mergedFooterGroups.forEach((footerGroup, rowIndex) => {\n        rowIndex += headerGroupCount + rowCount\n\n        insertCellMapByHeaderGroup(footerGroup, rowIndex)\n      })\n\n      return cellMap\n    }, [\n      enableKeyboardNavigation,\n      headerGroupCount,\n      mergedFooterGroups,\n      mergedHeaderGroups,\n      rows,\n      rowCount,\n    ])\n    const context = useMemo(\n      () => ({\n        columnResizeMode,\n        sortingIcon,\n        table,\n        resizableTriggerProps,\n        sortingIconProps,\n      }),\n      [\n        columnResizeMode,\n        sortingIcon,\n        sortingIconProps,\n        resizableTriggerProps,\n        table,\n      ],\n    )\n    const getCell = (\n      evOrEl:\n        | Element\n        | FocusEvent<HTMLTableElement>\n        | KeyboardEvent<HTMLTableElement>\n        | null\n        | undefined,\n    ) => {\n      if (!evOrEl) return\n\n      const el =\n        evOrEl instanceof HTMLElement\n          ? evOrEl.closest(\"th, td\")\n          : \"target\" in evOrEl && evOrEl.target instanceof HTMLElement\n            ? evOrEl.target.closest(\"th, td\")\n            : null\n\n      if (!(el instanceof HTMLTableCellElement)) return\n\n      const { colindex, rowindex } = el.dataset\n      const { colSpan, rowSpan } = el\n\n      if (!colindex || !rowindex) return\n\n      const colIndex = parseInt(colindex)\n      const rowIndex = parseInt(rowindex)\n\n      return { colIndex, colSpan, el, rowIndex, rowSpan }\n    }\n    const getShouldFocusCell = (colIndex: number, rowIndex: number) => {\n      const [trulyColIndex, trulyRowIndex] =\n        cellMap.get(`${colIndex}-${rowIndex}`)?.split(\"-\") ?? []\n\n      if (!trulyColIndex || !trulyRowIndex) return\n\n      const targetEl = ref.current?.querySelector(\n        `[data-colindex=\"${trulyColIndex}\"][data-rowindex=\"${trulyRowIndex}\"]`,\n      )\n\n      if (!targetEl || !(targetEl instanceof HTMLTableCellElement)) return\n\n      return targetEl\n    }\n    const removeTabIndex = (el: Element | null | undefined) => {\n      if (!el || !(el instanceof HTMLElement)) return\n\n      el.tabIndex = -1\n      el.querySelectorAll(\"[data-focusable]\").forEach((el) => {\n        if (el instanceof HTMLElement) el.tabIndex = -1\n      })\n    }\n    const onCellFocus = (\n      el: HTMLTableCellElement | null | undefined,\n      colIndex: number,\n      rowIndex: number,\n    ) => {\n      const targetEl = getShouldFocusCell(colIndex, rowIndex)\n\n      if (!targetEl) return\n\n      focusedCell.current = { colIndex, rowIndex }\n\n      removeTabIndex(el)\n\n      const shouldFocusEl =\n        targetEl.querySelector(\"[data-focusable]\") ?? targetEl\n\n      if (shouldFocusEl instanceof HTMLElement) {\n        shouldFocusEl.tabIndex = 0\n        shouldFocusEl.focus()\n      }\n    }\n    const onFocus = (ev: FocusEvent<HTMLTableElement>) => {\n      if (initialFocus.current) return\n\n      initialFocus.current = true\n\n      const cell = getCell(ev)\n\n      if (!cell) return\n\n      onCellFocus(cell.el, cell.colIndex, cell.rowIndex)\n    }\n    const onKeyDown = (ev: KeyboardEvent<HTMLTableElement>) => {\n      if (!enableKeyboardNavigation) return\n\n      const cell = getCell(ev)\n\n      if (!cell) return\n\n      runKeyAction(ev, {\n        ArrowDown: () =>\n          onCellFocus(cell.el, cell.colIndex, cell.rowIndex + cell.rowSpan),\n        ArrowLeft: () => onCellFocus(cell.el, cell.colIndex - 1, cell.rowIndex),\n        ArrowRight: () =>\n          onCellFocus(cell.el, cell.colIndex + cell.colSpan, cell.rowIndex),\n        ArrowUp: () => onCellFocus(cell.el, cell.colIndex, cell.rowIndex - 1),\n        End: () => onCellFocus(cell.el, maxColIndex, cell.rowIndex),\n        Home: () => onCellFocus(cell.el, 0, cell.rowIndex),\n        ...(enablePagination\n          ? {\n              PageDown: () => {\n                if (!table.getCanNextPage()) return\n\n                table.setPageIndex(pageIndex + 1)\n              },\n              PageUp: () => {\n                if (!table.getCanPreviousPage()) return\n\n                table.setPageIndex(pageIndex - 1)\n              },\n            }\n          : {}),\n      })\n    }\n    const getTabIndex = (colIndex: number, rowIndex: number) => {\n      if (!enableKeyboardNavigation) return undefined\n\n      return colIndex === initialFocusableCell.colIndex &&\n        rowIndex === initialFocusableCell.rowIndex\n        ? 0\n        : undefined\n    }\n\n    useUpdateEffect(() => {\n      if (!enableKeyboardNavigation) return\n\n      const { colIndex, rowIndex } = focusedCell.current ?? initialFocusableCell\n      const targetEl = getShouldFocusCell(colIndex, rowIndex)\n\n      if (targetEl) targetEl.tabIndex = 0\n    }, [pageIndex, enableKeyboardNavigation])\n\n    return (\n      <ComponentContext value={context}>\n        {header ? runIfFn(header, table) : null}\n\n        <NativeTable.Root\n          {...mergeProps(\n            {\n              ref,\n              style:\n                enableColumnResizing && enableAutoResizeTableWidth\n                  ? { width: table.getCenterTotalSize() }\n                  : {},\n              colorScheme,\n              size,\n              variant,\n              \"aria-colcount\": colCount,\n              \"aria-multiselectable\": enableRowSelection ? \"true\" : undefined,\n              \"aria-rowcount\": totalRowCount || data.length,\n              highlightOnHover,\n              highlightOnSelected,\n              layout,\n              role: \"grid\",\n              stickyFooter,\n              stickyHeader,\n              striped,\n              withBorder,\n              withColumnBorders,\n              withScrollArea,\n              scrollAreaProps,\n              onFocus,\n              onKeyDown,\n            },\n            tableProps ?? {},\n          )()}\n        >\n          <NativeTable.Thead role=\"rowgroup\" {...theadProps}>\n            {mergedHeaderGroups.map((headerGroup, rowIndex) => {\n              let placeholderCount = 0\n\n              return (\n                <NativeTable.Tr\n                  key={headerGroup.id}\n                  aria-rowindex={rowIndex + 1}\n                  role=\"row\"\n                  {...runIfFn(headerGroupProps, headerGroup)}\n                >\n                  {headerGroup.headers.map((header) => {\n                    const { columnDef } = header.column\n                    const colIndex = header.index + placeholderCount\n                    const tabIndex = getTabIndex(colIndex, rowIndex)\n                    const canSort = header.column.getCanSort()\n                    const sorted = header.column.getIsSorted()\n                    const canResize = header.column.getCanResize()\n                    const resizing = header.column.getIsResizing()\n                    const children = header.isPlaceholder\n                      ? null\n                      : flexRender(\n                          header.column.columnDef.header,\n                          header.getContext(),\n                        )\n\n                    placeholderCount += (header.colSpan || 1) - 1\n\n                    return (\n                      <NativeTable.Th\n                        key={header.id}\n                        aria-colindex={colIndex + 1}\n                        aria-rowindex={rowIndex + 1}\n                        aria-sort={\n                          sorted\n                            ? sorted === \"asc\"\n                              ? \"ascending\"\n                              : \"descending\"\n                            : \"none\"\n                        }\n                        data-colindex={colIndex}\n                        data-rowindex={rowIndex}\n                        colSpan={header.colSpan || undefined}\n                        numeric={columnDef.numeric}\n                        pe={\n                          canSort\n                            ? \"calc((1rem * {lineHeights.moderate}) + {space-x})\"\n                            : undefined\n                        }\n                        position=\"relative\"\n                        role=\"columnheader\"\n                        rowSpan={header.rowSpan || undefined}\n                        tabIndex={tabIndex}\n                        {...mergeProps(\n                          {\n                            css: {\n                              \"&:has([data-focusable]:focus-visible)\":\n                                focusRingStyle.outline,\n                            },\n                            style: enableColumnResizing\n                              ? { width: header.getSize() }\n                              : {},\n                          },\n                          runIfFn(headerProps, header) ?? {},\n                          columnDef.headerProps ?? {},\n                        )()}\n                      >\n                        <TruncatedText\n                          lineClamp={columnDef.lineClamp ?? lineClamp}\n                          truncated={columnDef.truncated ?? truncated}\n                        >\n                          {children}\n                        </TruncatedText>\n\n                        {canSort ? (\n                          <SortingIcon\n                            sorted={sorted}\n                            onClick={header.column.getToggleSortingHandler()}\n                          />\n                        ) : null}\n\n                        {canResize ? (\n                          <ResizableTrigger\n                            resizing={resizing}\n                            onDoubleClick={header.column.resetSize}\n                            onMouseDown={header.getResizeHandler()}\n                            onTouchStart={header.getResizeHandler()}\n                          />\n                        ) : null}\n                      </NativeTable.Th>\n                    )\n                  })}\n                </NativeTable.Tr>\n              )\n            })}\n          </NativeTable.Thead>\n\n          <NativeTable.Tbody role=\"rowgroup\" {...tbodyProps}>\n            {rows.map((row, rowIndex) => {\n              rowIndex += headerGroupCount\n\n              const selected = !!rowSelection[row.id]\n              const disabled =\n                isFunction(enableRowSelection) && !enableRowSelection(row)\n\n              return (\n                <NativeTable.Tr\n                  id={row.id}\n                  key={row.id}\n                  aria-disabled={ariaAttr(disabled)}\n                  aria-rowindex={rowIndex + 1}\n                  aria-selected={ariaAttr(selected)}\n                  data-disabled={dataAttr(disabled)}\n                  data-selected={dataAttr(selected)}\n                  role=\"row\"\n                  {...mergeProps(\n                    {\n                      onClick:\n                        !disabled && selectOnClickRow\n                          ? () => row.toggleSelected(!selected)\n                          : undefined,\n                    },\n                    {\n                      onClick: !disabled ? () => onRowClick?.(row) : undefined,\n                      onDoubleClick: !disabled\n                        ? () => onRowDoubleClick?.(row)\n                        : undefined,\n                    },\n                    runIfFn(rowProps, row) ?? {},\n                  )()}\n                >\n                  {row.getVisibleCells().map((cell) => {\n                    const { columnDef } = cell.column\n                    const colIndex = cell.column.getIndex()\n                    const tabIndex = getTabIndex(colIndex, rowIndex)\n                    const children = flexRender(\n                      cell.column.columnDef.cell,\n                      cell.getContext(),\n                    )\n\n                    return (\n                      <NativeTable.Td\n                        key={cell.id}\n                        aria-colindex={colIndex + 1}\n                        aria-rowindex={rowIndex + 1}\n                        data-colindex={colIndex}\n                        data-rowindex={rowIndex}\n                        numeric={columnDef.numeric}\n                        role=\"gridcell\"\n                        tabIndex={tabIndex}\n                        {...mergeProps(\n                          {\n                            css: {\n                              \"&:has([data-focusable]:focus-visible)\":\n                                focusRingStyle.outline,\n                            },\n                          },\n                          runIfFn(cellProps, cell) ?? {},\n                          columnDef.cellProps ?? {},\n                        )()}\n                      >\n                        <TruncatedText\n                          lineClamp={columnDef.lineClamp ?? lineClamp}\n                          truncated={columnDef.truncated ?? truncated}\n                        >\n                          {children}\n                        </TruncatedText>\n                      </NativeTable.Td>\n                    )\n                  })}\n                </NativeTable.Tr>\n              )\n            })}\n          </NativeTable.Tbody>\n\n          {withFooterGroups ? (\n            <NativeTable.Tfoot role=\"rowgroup\" {...tfootProps}>\n              {mergedFooterGroups.map((footerGroup, rowIndex) => {\n                rowIndex += headerGroupCount + rowCount\n\n                let placeholderCount = 0\n\n                return (\n                  <NativeTable.Tr\n                    key={footerGroup.id}\n                    aria-rowindex={rowIndex + 1}\n                    role=\"row\"\n                    {...runIfFn(footerGroupProps, footerGroup)}\n                  >\n                    {footerGroup.headers.map((header) => {\n                      const { columnDef } = header.column\n                      const colIndex = header.index + placeholderCount\n                      const tabIndex = getTabIndex(colIndex, rowIndex)\n                      const children = header.isPlaceholder\n                        ? null\n                        : flexRender(\n                            header.column.columnDef.footer,\n                            header.getContext(),\n                          )\n\n                      placeholderCount += (header.colSpan || 1) - 1\n\n                      return (\n                        <NativeTable.Td\n                          key={header.id}\n                          aria-colindex={colIndex + 1}\n                          aria-rowindex={rowIndex + 1}\n                          data-colindex={colIndex}\n                          data-rowindex={rowIndex}\n                          colSpan={header.colSpan || undefined}\n                          numeric={columnDef.numeric}\n                          role=\"gridcell\"\n                          rowSpan={header.rowSpan || undefined}\n                          tabIndex={tabIndex}\n                          {...mergeProps(\n                            {\n                              css: {\n                                \"&:has([data-focusable]:focus-visible)\":\n                                  focusRingStyle.outline,\n                              },\n                            },\n                            runIfFn(footerProps, header) ?? {},\n                            columnDef.footerProps ?? {},\n                          )()}\n                        >\n                          <TruncatedText\n                            lineClamp={columnDef.lineClamp ?? lineClamp}\n                            truncated={columnDef.truncated ?? truncated}\n                          >\n                            {children}\n                          </TruncatedText>\n                        </NativeTable.Td>\n                      )\n                    })}\n                  </NativeTable.Tr>\n                )\n              })}\n            </NativeTable.Tfoot>\n          ) : null}\n        </NativeTable.Root>\n\n        {footer ? runIfFn(footer, table) : null}\n      </ComponentContext>\n    )\n  },\n)() as GenericsComponent<{\n  <Y extends RowData>(props: TableProps<Y>): ReactElement\n}>\n\ninterface SortingIconProps extends HTMLStyledProps<\"button\"> {\n  sorted: false | SortDirection\n}\n\nconst SortingIcon: FC<SortingIconProps> = ({ sorted, ...rest }) => {\n  const { t } = useI18n(\"table\")\n  const { sortingIcon, sortingIconProps = {} } = useComponentContext()\n  const Icon = sorted ? ChevronUpIcon : ChevronsUpDownIcon\n\n  return (\n    <styled.button\n      type=\"button\"\n      layerStyle=\"ghost\"\n      colorScheme=\"mono\"\n      aria-label={t(\n        sorted\n          ? sorted === \"desc\"\n            ? \"Sort descending\"\n            : \"Sort ascending\"\n          : \"Clear sorting\",\n      )}\n      data-focusable\n      aspectRatio=\"1\"\n      cursor=\"pointer\"\n      display=\"center\"\n      focusVisibleRing=\"none\"\n      h=\"calc(1em * {lineHeights.moderate})\"\n      position=\"absolute\"\n      right=\"{space-x}\"\n      rounded=\"l1\"\n      tabIndex={-1}\n      top=\"50%\"\n      transform=\"translateY(-50%)\"\n      transitionDuration=\"moderate\"\n      transitionProperty=\"common\"\n      _hover={{ layerStyle: \"ghost.hover\" }}\n      {...mergeProps(rest, sortingIconProps)()}\n    >\n      {runIfFn(sortingIcon, sorted) ?? (\n        <Icon transform={`rotate(${sorted === \"desc\" ? 180 : 0}deg)`} />\n      )}\n    </styled.button>\n  )\n}\n\ninterface ResizableTriggerProps extends HTMLStyledProps {\n  resizing: boolean\n}\n\nconst ResizableTrigger: FC<ResizableTriggerProps> = ({ resizing, ...rest }) => {\n  const {\n    columnResizeMode,\n    table,\n    resizableTriggerProps = {},\n  } = useComponentContext()\n  const offset = table.getState().columnSizingInfo.deltaOffset\n\n  return (\n    <styled.div\n      data-active={dataAttr(resizing)}\n      bg=\"colorScheme.solid\"\n      cursor=\"col-resize\"\n      insetY=\"0\"\n      opacity={{ base: \"0\", _hover: \"1\", _active: \"1\" }}\n      position=\"absolute\"\n      right=\"0\"\n      touchAction=\"none\"\n      transform={`translateX(${columnResizeMode === \"onEnd\" && resizing && offset ? `${offset}px` : \"50%\"})`}\n      userSelect=\"none\"\n      w=\"1\"\n      {...mergeProps(rest, resizableTriggerProps)()}\n    />\n  )\n}\n\ninterface TruncatedTextProps extends HTMLStyledProps<\"span\"> {}\n\nconst TruncatedText: FC<TruncatedTextProps> = ({\n  children,\n  lineClamp,\n  truncated,\n  ...rest\n}) => {\n  if (lineClamp || truncated) {\n    return (\n      <styled.span\n        lineClamp={lineClamp}\n        truncated={truncated}\n        wordBreak=\"break-all\"\n        {...rest}\n      >\n        {children}\n      </styled.span>\n    )\n  } else {\n    return children\n  }\n}\n"
    }
  ]
}
