{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["button", "input", "group", "icon", "field"],
    "externals": [],
    "hooks": ["use-counter", "use-event-listener", "use-interval"],
    "providers": ["i18n-provider"]
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./number-input.style\"\nexport {\n  NumberInput,\n  NumberInputPropsContext,\n  useNumberInputPropsContext,\n} from \"./number-input\"\nexport type { NumberInputProps } from \"./number-input\"\nexport * from \"./use-number-input\"\n"
    },
    {
      "name": "number-input.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\nimport { buttonStyle } from \"../button\"\nimport {\n  getInputHeightStyle,\n  getInputPaddingResetStyle,\n  inputStyle,\n} from \"../input\"\n\nexport const numberInputStyle = defineComponentSlotStyle({\n  base: {\n    button: {\n      ...buttonStyle.base,\n      flex: \"1\",\n      lineHeight: \"1\",\n      rounded: \"l1\",\n    },\n    control: {\n      display: \"flex\",\n      flexDirection: \"column\",\n    },\n    decrement: {},\n    field: inputStyle.base,\n    increment: {},\n    root: {},\n  },\n\n  variants: {\n    base: {\n      button: {\n        layerStyle: \"ghost\",\n        focusVisibleRing: \"none\",\n        _hover: {\n          layerStyle: \"ghost.hover\",\n        },\n        _focusVisible: {\n          layerStyle: \"ghost.hover\",\n        },\n      },\n    },\n\n    filled: {\n      field: inputStyle.variants?.filled,\n    },\n    flushed: {\n      field: inputStyle.variants?.flushed,\n      root: getInputPaddingResetStyle(\"& > input\"),\n    },\n    outline: {\n      field: inputStyle.variants?.outline,\n    },\n    plain: {\n      field: inputStyle.variants?.plain,\n    },\n  },\n\n  sizes: {\n    xs: {\n      control: {\n        boxSize: `calc({--height} - {spaces.2})`,\n        fontSize: inputStyle.sizes?.xs.fontSize,\n      },\n      field: inputStyle.sizes?.xs,\n      root: getInputHeightStyle(inputStyle.sizes?.xs.minH, \"& > input\"),\n    },\n    sm: {\n      control: {\n        boxSize: `calc({--height} - {spaces.2})`,\n        fontSize: inputStyle.sizes?.sm.fontSize,\n      },\n      field: inputStyle.sizes?.sm,\n      root: getInputHeightStyle(inputStyle.sizes?.sm.minH, \"& > input\"),\n    },\n    md: {\n      control: {\n        boxSize: `calc({--height} - {spaces.2})`,\n        fontSize: inputStyle.sizes?.md.fontSize,\n      },\n      field: inputStyle.sizes?.md,\n      root: getInputHeightStyle(inputStyle.sizes?.md.minH, \"& > input\"),\n    },\n    lg: {\n      control: {\n        boxSize: `calc({--height} - {spaces.2.5})`,\n        fontSize: inputStyle.sizes?.lg.fontSize,\n      },\n      field: inputStyle.sizes?.lg,\n      root: getInputHeightStyle(inputStyle.sizes?.lg.minH, \"& > input\"),\n    },\n    xl: {\n      control: {\n        boxSize: `calc({--height} - {spaces.3})`,\n        fontSize: inputStyle.sizes?.xl.fontSize,\n      },\n      field: inputStyle.sizes?.xl,\n      root: getInputHeightStyle(inputStyle.sizes?.xl.minH, \"& > input\"),\n    },\n    \"2xl\": {\n      control: {\n        boxSize: `calc({--height} - {spaces.3})`,\n        fontSize: inputStyle.sizes?.[\"2xl\"].fontSize,\n      },\n      field: inputStyle.sizes?.[\"2xl\"],\n      root: getInputHeightStyle(inputStyle.sizes?.[\"2xl\"]?.minH, \"& > input\"),\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"outline\",\n  },\n})\n\nexport type NumberInputStyle = typeof numberInputStyle\n"
    },
    {
      "name": "number-input.tsx",
      "content": "\"use client\"\n\nimport type {\n  HTMLStyledProps,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type { InputProps } from \"../input\"\nimport type { NumberInputStyle } from \"./number-input.style\"\nimport type { UseNumberInputProps } from \"./use-number-input\"\nimport { createSlotComponent } from \"@yamada-ui/react\"\nimport { useGroupItemProps } from \"../group\"\nimport { ChevronDownIcon, ChevronUpIcon } from \"../icon\"\nimport { Input, InputGroup, useInputPropsContext } from \"../input\"\nimport { numberInputStyle } from \"./number-input.style\"\nimport { useNumberInput } from \"./use-number-input\"\n\nexport interface NumberInputProps\n  extends Omit<\n      WithoutThemeProps<InputProps, NumberInputStyle>,\n      keyof UseNumberInputProps\n    >,\n    ThemeProps<NumberInputStyle>,\n    UseNumberInputProps {\n  /**\n   * The props for the control element.\n   */\n  controlProps?: NumberInputControlProps\n  /**\n   * The props for the decrement button element.\n   */\n  decrementProps?: NumberInputDecrementButtonProps\n  /**\n   * The props for the end element.\n   */\n  elementProps?: InputGroup.ElementProps\n  /**\n   * The props for the increment button element.\n   */\n  incrementProps?: NumberInputIncrementButtonProps\n  /**\n   * The props for the root element.\n   */\n  rootProps?: InputGroup.RootProps\n}\n\nconst {\n  PropsContext: NumberInputPropsContext,\n  usePropsContext: useNumberInputPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<NumberInputProps, NumberInputStyle>(\n  \"number-input\",\n  numberInputStyle,\n)\n\nexport { NumberInputPropsContext, useNumberInputPropsContext }\n\n/**\n * `NumberInput` is a component used to obtain numeric input from the user.\n *\n * @see https://yamada-ui.com/docs/components/number-input\n */\nexport const NumberInput = withProvider<\"input\", NumberInputProps>(\n  ({\n    className,\n    css,\n    colorScheme,\n    controlProps,\n    decrementProps,\n    elementProps,\n    incrementProps,\n    rootProps,\n    ...props\n  }) => {\n    const [groupItemProps, rest] = useGroupItemProps(props)\n    const { getDecrementProps, getIncrementProps, getInputProps } =\n      useNumberInput(rest)\n\n    return (\n      <InputGroup.Root\n        className={className}\n        css={css}\n        colorScheme={colorScheme}\n        {...groupItemProps}\n        {...rootProps}\n      >\n        <NumberInputField {...getInputProps()} />\n\n        <InputGroup.Element clickable {...elementProps}>\n          <NumberInputControl {...controlProps}>\n            <NumberInputIncrementButton\n              {...getIncrementProps(incrementProps)}\n            />\n            <NumberInputDecrementButton\n              {...getDecrementProps(decrementProps)}\n            />\n          </NumberInputControl>\n        </InputGroup.Element>\n      </InputGroup.Root>\n    )\n  },\n  \"root\",\n)((props) => {\n  const context = useInputPropsContext()\n\n  return { ...context, ...props }\n})\n\ninterface NumberInputFieldProps extends InputProps {}\n\nconst NumberInputField = withContext<\"input\", NumberInputFieldProps>(\n  Input,\n  \"field\",\n)({ \"data-group-propagate\": \"\" })\n\ninterface NumberInputControlProps extends InputGroup.AddonProps {}\n\nconst NumberInputControl = withContext<\"div\", NumberInputControlProps>(\n  \"div\",\n  \"control\",\n)()\n\ntype NumberInputIncrementButtonProps = HTMLStyledProps<\"button\">\n\nconst NumberInputIncrementButton = withContext<\n  \"button\",\n  NumberInputIncrementButtonProps\n>(\"button\", [\"button\", \"increment\"])({ children: <ChevronUpIcon /> })\n\ntype NumberInputDecrementButtonProps = HTMLStyledProps<\"button\">\n\nconst NumberInputDecrementButton = withContext<\n  \"button\",\n  NumberInputDecrementButtonProps\n>(\"button\", [\"button\", \"decrement\"])({ children: <ChevronDownIcon /> })\n"
    },
    {
      "name": "use-number-counter.ts",
      "content": "\"use client\"\n\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type { UseCounterProps, UseCounterReturn } from \"../../hooks/use-counter\"\nimport type { UseSpinnerProps } from \"./use-spinner\"\nimport { useCallback, useRef } from \"react\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport { handlerAll, mergeRefs, useAttributeObserver } from \"@yamada-ui/react\"\nimport { useSpinner } from \"./use-spinner\"\n\nexport interface UseNumberCounterProps\n  extends HTMLProps<\"button\">,\n    Pick<UseCounterProps, \"keepWithinRange\">,\n    Pick<UseCounterReturn, \"max\" | \"min\">,\n    UseSpinnerProps {}\n\nexport const useNumberCounter = ({\n  decrement,\n  disabled,\n  increment,\n  keepWithinRange,\n  max,\n  min,\n  ...rest\n}: UseNumberCounterProps) => {\n  const incrementRef = useRef<HTMLButtonElement>(null)\n  const decrementRef = useRef<HTMLButtonElement>(null)\n  const { down, spinning, stop, up } = useSpinner({ decrement, increment })\n  const { t } = useI18n(\"numberInput\")\n\n  useAttributeObserver(incrementRef, [\"disabled\"], spinning, stop)\n  useAttributeObserver(decrementRef, [\"disabled\"], spinning, stop)\n\n  const getButtonProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      type: \"button\",\n      disabled,\n      tabIndex: -1,\n      ...rest,\n      ...props,\n      onPointerLeave: handlerAll(props.onPointerLeave, stop),\n      onPointerUp: handlerAll(props.onPointerUp, stop),\n    }),\n    [rest, disabled, stop],\n  )\n\n  const getIncrementProps: PropGetter<\"button\"> = useCallback(\n    ({ ref, ...props } = {}) => {\n      const trulyDisabled = disabled || (keepWithinRange && max)\n\n      return {\n        ref: mergeRefs(ref, incrementRef),\n        \"aria-label\": t(\"Increase\"),\n        ...getButtonProps({ disabled: trulyDisabled, ...props }),\n        onPointerDown: handlerAll(props.onPointerDown, (ev) => {\n          if (ev.button !== 0 || trulyDisabled) return\n\n          ev.preventDefault()\n          up()\n        }),\n      }\n    },\n    [getButtonProps, disabled, keepWithinRange, max, up, t],\n  )\n\n  const getDecrementProps: PropGetter<\"button\"> = useCallback(\n    ({ ref, ...props } = {}) => {\n      const trulyDisabled = disabled || (keepWithinRange && min)\n\n      return {\n        ref: mergeRefs(ref, decrementRef),\n        \"aria-label\": t(\"Decrease\"),\n        ...getButtonProps({ disabled: trulyDisabled, ...props }),\n        onPointerDown: handlerAll(props.onPointerDown, (ev) => {\n          if (ev.button !== 0 || trulyDisabled) return\n\n          ev.preventDefault()\n          down()\n        }),\n      }\n    },\n    [getButtonProps, disabled, keepWithinRange, min, down, t],\n  )\n\n  return { getDecrementProps, getIncrementProps }\n}\n\nexport type UseNumberCounterReturn = ReturnType<typeof useNumberCounter>\n"
    },
    {
      "name": "use-number-input.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent, FocusEvent, KeyboardEvent } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type { UseCounterProps } from \"../../hooks/use-counter\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useMemo, useRef } from \"react\"\nimport { useCounter } from \"../../hooks/use-counter\"\nimport { useEventListener } from \"../../hooks/use-event-listener\"\nimport {\n  ariaAttr,\n  handlerAll,\n  isComposing,\n  mergeRefs,\n  runKeyAction,\n  useSafeLayoutEffect,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\nimport { useNumberCounter } from \"./use-number-counter\"\n\nconst defaultFormat = (value: number | string) => value.toString()\n\nconst defaultParse = (value: string) => value\n\nconst isDefaultValidCharacter = (char: string) => /^[Ee0-9+\\-.]$/.test(char)\n\nconst isValidNumericKeyboardEvent = (\n  { key, altKey, ctrlKey, metaKey }: KeyboardEvent,\n  isValid: (key: string) => boolean,\n) => {\n  const modifierKey = ctrlKey || altKey || metaKey\n  const singleCharacterKey = key.length === 1\n\n  if (!singleCharacterKey || modifierKey) return true\n\n  return isValid(key)\n}\n\nconst getStepRatio = <Y extends KeyboardEvent | WheelEvent>({\n  ctrlKey,\n  metaKey,\n  shiftKey,\n}: Y) => {\n  let ratio = 1\n\n  if (metaKey || ctrlKey) ratio = 0.1\n\n  if (shiftKey) ratio = 10\n\n  return ratio\n}\n\nexport interface UseNumberInputProps\n  extends Omit<HTMLProps<\"input\">, keyof UseCounterProps>,\n    UseCounterProps,\n    FieldProps {\n  /**\n   * If `true`, the input's value will change based on mouse wheel.\n   *\n   * @default false\n   */\n  allowMouseWheel?: boolean\n  /**\n   * This controls the value update when you blur out of the input.\n   * - If `true` and the value is greater than `max`, the value will be reset to `max`.\n   * - Else, the value remains the same.\n   *\n   * @default true\n   */\n  clampValueOnBlur?: boolean\n  /**\n   * If `true`, the input will be focused as you increment or decrement the value with the button.\n   *\n   * @default true\n   */\n  focusInputOnChange?: boolean\n  /**\n   * If using a custom display format, this converts the default format to the custom format.\n   */\n  format?: (value: number | string) => string\n  /**\n   * This is used to format the value so that screen readers\n   * can speak out a more human-friendly value.\n   *\n   * It is used to set the `aria-valuetext` property of the input.\n   */\n  getAriaValueText?: (value: number | string) => string | undefined\n  /**\n   * Whether the pressed key should be allowed in the input.\n   * The default behavior is to allow DOM floating point characters defined by /^[Ee0-9+\\-.]$/.\n   */\n  isValidCharacter?: (value: string) => boolean\n  /**\n   * If using a custom display format, this converts the custom format to a format `parseFloat` understands.\n   */\n  parse?: (value: string) => string\n}\n\nexport const useNumberInput = (props: UseNumberInputProps = {}) => {\n  const {\n    props: {\n      allowMouseWheel,\n      clampValueOnBlur = true,\n      defaultValue,\n      disabled,\n      focusInputOnChange = true,\n      format = defaultFormat,\n      getAriaValueText,\n      isValidCharacter = isDefaultValidCharacter,\n      keepWithinRange = true,\n      max: maxValue = Number.MAX_SAFE_INTEGER,\n      min: minValue = Number.MIN_SAFE_INTEGER,\n      parse = defaultParse,\n      precision,\n      readOnly,\n      step = 1,\n      value: valueProp,\n      onChange: onChangeProp,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const interactive = !(readOnly || disabled)\n  const inputRef = useRef<HTMLInputElement>(null)\n  const {\n    cast,\n    max,\n    min,\n    out,\n    setValue,\n    update,\n    value,\n    valueAsNumber,\n    ...counter\n  } = useCounter({\n    defaultValue,\n    keepWithinRange,\n    max: maxValue,\n    min: minValue,\n    precision,\n    step,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const selectionRef = useRef<null | {\n    end: null | number\n    start: null | number\n  }>(null)\n  const valueText = useMemo(() => {\n    let text = getAriaValueText?.(value)\n\n    if (text != null) return text\n\n    text = value.toString()\n\n    return !text ? undefined : text\n  }, [value, getAriaValueText])\n\n  const sanitize = useCallback(\n    (value: string) => value.split(\"\").filter(isValidCharacter).join(\"\"),\n    [isValidCharacter],\n  )\n\n  const increment = useCallback(\n    (value: number = step) => {\n      if (!interactive) return\n\n      counter.increment(value)\n\n      if (!focusInputOnChange) return\n\n      requestAnimationFrame(() => {\n        inputRef.current?.focus()\n      })\n    },\n    [interactive, counter, step, focusInputOnChange],\n  )\n\n  const decrement = useCallback(\n    (value: number = step) => {\n      if (!interactive) return\n\n      counter.decrement(value)\n\n      if (!focusInputOnChange) return\n\n      requestAnimationFrame(() => {\n        inputRef.current?.focus()\n      })\n    },\n    [interactive, counter, step, focusInputOnChange],\n  )\n\n  const onChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      if (isComposing(ev)) return\n\n      const { selectionEnd, selectionStart, value } = ev.currentTarget\n\n      update(sanitize(parse(value)))\n\n      selectionRef.current = { end: selectionEnd, start: selectionStart }\n    },\n    [parse, sanitize, update],\n  )\n\n  const onFocus = useCallback((ev: FocusEvent<HTMLInputElement>) => {\n    if (!selectionRef.current) return\n\n    const { end, start } = selectionRef.current\n    const { selectionStart, value } = ev.currentTarget\n\n    ev.currentTarget.selectionStart = start ?? value.length\n    ev.currentTarget.selectionEnd = end ?? selectionStart\n  }, [])\n\n  const onBlur = useCallback(() => {\n    if (!clampValueOnBlur) return\n\n    let nextValue = value as number | string\n\n    if (value === \"\") return\n\n    const valueStartsWithE = /^[eE]/.test(value.toString())\n\n    if (valueStartsWithE) {\n      setValue(\"\")\n    } else {\n      if (valueAsNumber < minValue) nextValue = minValue\n\n      if (valueAsNumber > maxValue) nextValue = maxValue\n\n      cast(nextValue)\n    }\n  }, [\n    cast,\n    clampValueOnBlur,\n    maxValue,\n    minValue,\n    setValue,\n    value,\n    valueAsNumber,\n  ])\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLInputElement>) => {\n      if (isComposing(ev)) return\n\n      if (!isValidNumericKeyboardEvent(ev, isValidCharacter))\n        ev.preventDefault()\n\n      const stepValue = getStepRatio(ev) * step\n\n      runKeyAction(ev, {\n        ArrowDown: () => decrement(stepValue),\n        ArrowUp: () => increment(stepValue),\n        End: () => update(maxValue),\n        Home: () => update(minValue),\n      })\n    },\n    [decrement, increment, isValidCharacter, maxValue, minValue, step, update],\n  )\n\n  const { getDecrementProps, getIncrementProps } = useNumberCounter({\n    \"aria-disabled\": ariaAttr(!interactive),\n    decrement,\n    disabled,\n    increment,\n    keepWithinRange,\n    max,\n    min,\n    ...dataProps,\n  })\n\n  useSafeLayoutEffect(() => {\n    if (!inputRef.current) return\n\n    const notInSync = inputRef.current.value != value\n\n    if (!notInSync) return\n\n    setValue(sanitize(parse(inputRef.current.value)))\n  }, [parse, sanitize])\n\n  useEventListener(\n    inputRef.current,\n    \"wheel\",\n    (ev) => {\n      const ownerDocument = inputRef.current?.ownerDocument ?? document\n      const focused = ownerDocument.activeElement === inputRef.current\n\n      if (!allowMouseWheel || !focused) return\n\n      ev.preventDefault()\n\n      const stepValue = getStepRatio(ev) * step\n      const direction = Math.sign(ev.deltaY)\n\n      if (direction === -1) {\n        increment(stepValue)\n      } else if (direction === 1) {\n        decrement(stepValue)\n      }\n    },\n    { passive: false },\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...ariaProps,\n      ...dataProps,\n      type: \"text\",\n      \"aria-invalid\": ariaAttr(ariaProps[\"aria-invalid\"] ?? out),\n      \"aria-valuemax\": maxValue,\n      \"aria-valuemin\": minValue,\n      \"aria-valuenow\": Number.isNaN(valueAsNumber) ? undefined : valueAsNumber,\n      \"aria-valuetext\": valueText,\n      autoComplete: \"off\",\n      autoCorrect: \"off\",\n      disabled,\n      inputMode: \"decimal\",\n      max: maxValue,\n      min: minValue,\n      pattern: \"[0-9]*(.[0-9]+)?\",\n      readOnly,\n      role: \"spinbutton\",\n      step,\n      value: format(value),\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref, inputRef),\n      onBlur: handlerAll(eventProps.onBlur, props.onBlur, onBlur),\n      onChange: handlerAll(props.onChange, onChange),\n      onFocus: handlerAll(eventProps.onFocus, props.onFocus, onFocus),\n      onKeyDown: handlerAll(rest.onKeyDown, props.onKeyDown, onKeyDown),\n    }),\n    [\n      format,\n      out,\n      value,\n      valueText,\n      ariaProps,\n      dataProps,\n      eventProps,\n      maxValue,\n      minValue,\n      valueAsNumber,\n      disabled,\n      readOnly,\n      step,\n      rest,\n      onKeyDown,\n      onBlur,\n      onFocus,\n      onChange,\n    ],\n  )\n\n  return { getDecrementProps, getIncrementProps, getInputProps }\n}\n\nexport type UseNumberInputReturn = ReturnType<typeof useNumberInput>\n"
    },
    {
      "name": "use-spinner.ts",
      "content": "\"use client\"\n\nimport { useCallback, useRef, useState } from \"react\"\nimport { useInterval } from \"../../hooks/use-interval\"\nimport { useUnmountEffect } from \"@yamada-ui/react\"\n\nconst INTERVAL = 50\nconst DELAY = 300\n\nexport interface UseSpinnerProps {\n  decrement: () => void\n  increment: () => void\n}\n\nexport const useSpinner = ({ decrement, increment }: UseSpinnerProps) => {\n  const [spinning, setSpinning] = useState(false)\n  const [action, setAction] = useState<\"decrement\" | \"increment\" | null>(null)\n  const [once, setOnce] = useState(true)\n  const timeoutRef = useRef<any>(null)\n\n  useInterval(\n    () => {\n      if (action === \"increment\") increment()\n\n      if (action === \"decrement\") decrement()\n    },\n    spinning ? INTERVAL : null,\n  )\n\n  const up = useCallback(() => {\n    if (once) increment()\n\n    timeoutRef.current = setTimeout(() => {\n      setOnce(false)\n      setSpinning(true)\n      setAction(\"increment\")\n    }, DELAY)\n  }, [increment, once])\n\n  const down = useCallback(() => {\n    if (once) decrement()\n\n    timeoutRef.current = setTimeout(() => {\n      setOnce(false)\n      setSpinning(true)\n      setAction(\"decrement\")\n    }, DELAY)\n  }, [decrement, once])\n\n  const removeTimeout = useCallback(() => clearTimeout(timeoutRef.current), [])\n\n  const stop = useCallback(() => {\n    setOnce(true)\n    setSpinning(false)\n    removeTimeout()\n  }, [removeTimeout])\n\n  useUnmountEffect(removeTimeout)\n\n  return { down, spinning, stop, up }\n}\n\nexport type UseSpinnerReturn = ReturnType<typeof useSpinner>\n"
    }
  ]
}
