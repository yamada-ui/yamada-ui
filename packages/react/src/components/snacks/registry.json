{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["close-button", "motion", "alert"],
    "externals": ["motion@12.18.1"],
    "hooks": ["use-timeout"],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export { Snacks } from \"./snacks\"\nexport type { SnacksProps } from \"./snacks\"\nexport { useSnacks } from \"./use-snacks\"\nexport type { UseSnacksOptions } from \"./use-snacks\"\n"
    },
    {
      "name": "snacks.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const snacksStyle = defineComponentSlotStyle({\n  base: {\n    closeButton: {\n      \"&:is([data-variant='plain'], [data-variant='island'])\": {\n        colorScheme: \"mono\",\n      },\n      \"&:is([data-variant='solid'])\": {\n        color: \"colorScheme.contrast!\",\n        _hover: { bg: \"colorScheme.solid!\" },\n      },\n      fontSize: \"md!\",\n      minBoxSize: \"6!\",\n      position: \"absolute\",\n      right: \"3\",\n      top: \"2.5\",\n    },\n    content: {\n      display: \"flex\",\n      flex: \"1\",\n      flexDirection: \"column\",\n      gap: \"1\",\n      pe: \"6\",\n    },\n    item: {\n      insetX: \"0\",\n      maxW: \"full\",\n      position: \"absolute\",\n      top: \"calc({gap} * {index})\",\n      w: \"100%\",\n      zIndex: \"{z-index}\",\n    },\n    list: { position: \"relative\", w: \"full\" },\n    root: {\n      \"&[data-negative]\": { m: \"calc({top} * -1) 0 calc({bottom} * -1)\" },\n      \"--gap\": \"spaces.md\",\n      w: \"full\",\n    },\n  },\n})\n\nexport type SnacksStyle = typeof snacksStyle\n"
    },
    {
      "name": "snacks.tsx",
      "content": "\"use client\"\n\nimport type { Dispatch, RefObject, SetStateAction } from \"react\"\nimport type {\n  CSSProps,\n  HTMLStyledProps,\n  SimpleDirection,\n  Merge,\n} from \"@yamada-ui/react\"\nimport type { CloseButtonProps } from \"../close-button\"\nimport type { HTMLMotionProps } from \"../motion\"\nimport type { SnacksStyle } from \"./snacks.style\"\nimport type { Snack, UseSnacksReturn } from \"./use-snacks\"\nimport { AnimatePresence, useIsPresent } from \"motion/react\"\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\nimport {\n  createSlotComponent,\n  varAttr,\n  dataAttr,\n  handlerAll,\n  noop,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\nimport { useTimeout } from \"../../hooks/use-timeout\"\nimport { Alert } from \"../alert\"\nimport { CloseButton } from \"../close-button\"\nimport { createTransition, motion } from \"../motion\"\nimport { snacksStyle } from \"./snacks.style\"\n\ninterface ComponentContext {\n  direction: SimpleDirection\n  elMapRef: RefObject<Map<number, HTMLDivElement | null>>\n  setExist: Dispatch<SetStateAction<boolean>>\n  startIndex: number\n}\n\nexport interface SnacksProps extends HTMLMotionProps {\n  /**\n   * The snacks created by `useSnacks`.\n   */\n  snacks: UseSnacksReturn[\"snacks\"]\n  /**\n   * The CSS `gap` property.\n   *\n   * @default 'md'\n   */\n  gap?: CSSProps[\"gap\"]\n  /**\n   * A property that provides spacing between the top and bottom.\n   *\n   * @default \"[0, 'lg']\"\n   */\n  gutter?: [CSSProps[\"paddingTop\"], CSSProps[\"paddingBottom\"]]\n  /**\n   * If `true`, apply gutter value to negative margins\n   *\n   * @default true\n   */\n  negativeMargins?: boolean\n  /**\n   * Props for the snacks list element.\n   */\n  listProps?: HTMLMotionProps\n}\n\nconst {\n  ComponentContext,\n  PropsContext: SnacksPropsContext,\n  useComponentContext,\n  usePropsContext: useSnacksPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<SnacksProps, SnacksStyle, ComponentContext>(\n  \"snacks\",\n  snacksStyle,\n)\n\nexport { SnacksPropsContext, useSnacksPropsContext }\n\nexport const Snacks = withProvider<\"div\", SnacksProps>(\n  ({\n    snacks: { direction = \"start\", items, startIndex = 0 },\n    listProps,\n    ...rest\n  }) => {\n    const count = items.length\n    const elMapRef = useRef<Map<number, HTMLDivElement | null>>(new Map())\n    const [height, setHeight] = useState(0)\n    const [exist, setExist] = useState(!!count)\n    const show = !!count || exist\n    const context = useMemo(\n      () => ({ direction, elMapRef, setExist, startIndex }),\n      [direction, startIndex],\n    )\n\n    const onExitComplete = useCallback(() => {\n      if (!count) setExist(false)\n    }, [count])\n\n    useEffect(() => {\n      let height = 0\n\n      if (!count) return\n\n      const els = [...elMapRef.current.values()].slice(0, count)\n\n      for (const el of els) {\n        if (!el) continue\n\n        let { offsetHeight, offsetTop } = el\n\n        offsetHeight += offsetTop\n\n        if (offsetHeight > height) height = offsetHeight\n      }\n\n      setHeight(height)\n    }, [count, direction])\n\n    useUpdateEffect(() => {\n      if (!!count) setExist(true)\n    }, [count])\n\n    return (\n      <ComponentContext value={context}>\n        <AnimatePresence initial={false}>\n          {show ? (\n            <motion.div {...rest}>\n              <SnackList custom={{ height }} {...listProps}>\n                <AnimatePresence onExitComplete={onExitComplete}>\n                  {items.map((props, index) => {\n                    return (\n                      <Snack\n                        key={props.id}\n                        index={index}\n                        lastIndex={count - index - 1}\n                        {...props}\n                      />\n                    )\n                  })}\n                </AnimatePresence>\n              </SnackList>\n            </motion.div>\n          ) : null}\n        </AnimatePresence>\n      </ComponentContext>\n    )\n  },\n  \"root\",\n)(\n  {\n    animate: \"animate\",\n    exit: \"exit\",\n    initial: \"initial\",\n    variants: {\n      animate: {\n        padding: \"var(--top) 0 var(--bottom)\",\n        transition: { duration: 0.4 },\n      },\n      exit: { padding: 0 },\n      initial: { padding: 0 },\n    },\n  },\n  ({ gap, gutter = [0, \"lg\"], negativeMargins = true, ...rest }) => ({\n    \"data-negative\": dataAttr(negativeMargins),\n    \"--bottom\": varAttr(gutter[1], \"spaces\", \"0px\"),\n    \"--gap\": varAttr(gap, \"spaces\"),\n    \"--top\": varAttr(gutter[0], \"spaces\", \"0px\"),\n    ...rest,\n  }),\n)\n\ninterface SnackListProps extends HTMLMotionProps {}\n\nconst SnackList = withContext<\"div\", SnackListProps>(\n  motion.div,\n  \"list\",\n)({\n  animate: \"animate\",\n  exit: \"exit\",\n  initial: \"initial\",\n  role: \"list\",\n  variants: {\n    animate: ({ height }) => ({\n      height,\n      opacity: 1,\n      transition: { duration: 0.4 },\n    }),\n    exit: { height: 0, opacity: 0 },\n    initial: { height: 0, opacity: 1 },\n  },\n})\n\ninterface SnackProps\n  extends Merge<HTMLMotionProps, Merge<Alert.RootProps, Snack>> {\n  index: number\n  lastIndex: number\n}\n\nconst Snack = withContext<\"div\", SnackProps>(\n  ({\n    variant = \"plain\",\n    closable = true,\n    description,\n    duration: durationProp = null,\n    loadingScheme,\n    status,\n    title,\n    withIcon = true,\n    closeButtonProps,\n    contentProps,\n    descriptionProps,\n    iconProps,\n    loadingProps,\n    titleProps,\n    onClose: onCloseProp,\n    onCloseComplete,\n    ...rest\n  }) => {\n    const [duration, setDuration] = useState(durationProp)\n    const present = useIsPresent()\n    const onClose = present ? onCloseProp : noop\n\n    const onMouseEnter = useCallback(() => {\n      setDuration(null)\n    }, [])\n\n    const onMouseLeave = useCallback(() => {\n      setDuration(durationProp)\n    }, [durationProp])\n\n    useUpdateEffect(() => {\n      if (!present) onCloseComplete?.()\n    }, [present])\n\n    useUpdateEffect(() => {\n      setDuration(durationProp)\n    }, [durationProp])\n\n    useTimeout(onClose, duration)\n\n    return (\n      <Alert.Root\n        as={motion.div}\n        variant={variant}\n        status={status}\n        {...rest}\n        onMouseEnter={handlerAll(rest.onMouseEnter, onMouseEnter)}\n        onMouseLeave={handlerAll(rest.onMouseLeave, onMouseLeave)}\n      >\n        {withIcon ? (\n          loadingScheme ? (\n            <Alert.Loading loadingScheme={loadingScheme} {...loadingProps} />\n          ) : (\n            <Alert.Icon {...iconProps} />\n          )\n        ) : null}\n\n        <SnackContent {...contentProps}>\n          {title ? (\n            <Alert.Title me=\"0\" {...titleProps}>\n              {title}\n            </Alert.Title>\n          ) : null}\n\n          {description ? (\n            <Alert.Description {...descriptionProps}>\n              {description}\n            </Alert.Description>\n          ) : null}\n        </SnackContent>\n\n        {closable ? (\n          <SnackCloseButton\n            data-variant={variant}\n            {...closeButtonProps}\n            onClick={handlerAll(closeButtonProps?.onClick, onClose)}\n          />\n        ) : null}\n      </Alert.Root>\n    )\n  },\n  \"item\",\n)(\n  {\n    animate: \"animate\",\n    exit: \"exit\",\n    initial: \"initial\",\n    layout: true,\n    role: \"listitem\",\n    variants: {\n      animate: ({ index }) => ({\n        opacity: 1,\n        transition: createTransition.enter()(!index ? 0.2 : 0, 0.4),\n        y: 0,\n      }),\n      exit: {\n        opacity: 0,\n        transition: createTransition.exit()(undefined, 0.2),\n      },\n      initial: ({ direction, index }) => ({\n        opacity: 0,\n        ...(index ? { y: (direction === \"start\" ? -1 : 1) * 16 } : {}),\n      }),\n    },\n  },\n  ({ index, lastIndex, ...rest }) => {\n    const ref = useRef<HTMLDivElement>(null)\n    const { direction, elMapRef, startIndex } = useComponentContext()\n\n    useEffect(() => {\n      const elMap = elMapRef.current\n\n      elMap.set(index, ref.current)\n\n      return () => {\n        elMap.delete(index)\n      }\n    }, [elMapRef, index])\n\n    return {\n      ref,\n      \"--index\": direction === \"start\" ? lastIndex : index,\n      \"--z-index\": startIndex + index,\n      custom: { direction, index },\n      ...rest,\n    }\n  },\n)\n\nexport interface SnackContentProps extends HTMLStyledProps {}\n\nconst SnackContent = withContext<\"div\", SnackContentProps>(\"div\", \"content\")()\n\nexport interface SnackCloseButtonProps extends CloseButtonProps {}\n\nconst SnackCloseButton = withContext<\"button\", SnackCloseButtonProps>(\n  CloseButton,\n  \"closeButton\",\n)()\n"
    },
    {
      "name": "use-snacks.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport type { SnacksConfig } from \"@yamada-ui/react\"\nimport type { Alert } from \"../alert\"\nimport type { SnackCloseButtonProps, SnackContentProps } from \"./snacks\"\nimport { useCallback, useMemo, useState } from \"react\"\nimport { useSystem, merge } from \"@yamada-ui/react\"\n\nexport interface Snack\n  extends Omit<UseSnacksOptions, \"direction\" | \"limit\" | \"startIndex\"> {\n  id: string\n  onClose: () => void\n  onCloseComplete?: () => void\n}\n\nlet counter = 0\n\ninterface SnackMethodsOptions extends Partial<Omit<Snack, \"onClose\">> {}\n\nexport interface UseSnacksOptions\n  extends Omit<Alert.RootProps, \"direction\" | \"title\">,\n    Pick<Alert.LoadingProps, \"loadingScheme\">,\n    SnacksConfig {\n  /**\n   * The description of the snack.\n   */\n  description?: ReactNode\n  /**\n   * The title of the snack.\n   */\n  title?: ReactNode\n  /**\n   * If `true`, the snack will have an icon.\n   *\n   * @default true\n   */\n  withIcon?: boolean\n  /**\n   * Props for the snack close button.\n   */\n  closeButtonProps?: SnackCloseButtonProps\n  /**\n   * Props for the snack content component.\n   */\n  contentProps?: SnackContentProps\n  /**\n   * Props for the alert description component.\n   */\n  descriptionProps?: Alert.DescriptionProps\n  /**\n   * Props for the alert icon component.\n   */\n  iconProps?: Alert.IconProps\n  /**\n   * Props for the alert loading component.\n   */\n  loadingProps?: Alert.LoadingProps\n  /**\n   * Props for the alert title component.\n   */\n  titleProps?: Alert.TitleProps\n}\n\n/**\n * `useSnacks` is a custom hook for controlling notifications used in forms and the like.\n *\n * @see https://yamada-ui.com/hooks/use-snacks\n */\nexport const useSnacks = (options: UseSnacksOptions = {}) => {\n  const [items, setItems] = useState<Snack[]>([])\n  const { config } = useSystem()\n\n  const systemOptions = useMemo(() => config.snacks ?? {}, [config])\n\n  const defaultOptions = useMemo(\n    () => merge<UseSnacksOptions>(systemOptions, options),\n    [options, systemOptions],\n  )\n  const { direction, limit = 3, startIndex } = defaultOptions\n\n  const getOptions = useCallback(\n    (options: SnackMethodsOptions) => merge(defaultOptions, options),\n    [defaultOptions],\n  )\n\n  const snack = useMemo(() => {\n    const methods = (options: SnackMethodsOptions = {}) => {\n      options = getOptions(options)\n      counter += 1\n\n      const { id = counter.toString(), ...rest } = options\n      const onClose = () =>\n        setItems((prev) => prev.filter((prevOptions) => prevOptions.id !== id))\n\n      const snack: Snack = { id, onClose, ...rest }\n\n      setItems((prev) => [\n        ...prev.splice(-1 * ((limit ?? Infinity) - 1)),\n        snack,\n      ])\n\n      return id\n    }\n\n    methods.update = (\n      id: number | string,\n      options: Omit<SnackMethodsOptions, \"id\">,\n    ) => {\n      options = getOptions(options)\n\n      setItems((prev) =>\n        prev.map((prevOptions) =>\n          prevOptions.id === id ? { ...prevOptions, ...options } : prevOptions,\n        ),\n      )\n    }\n\n    methods.closeAll = () => {\n      setItems([])\n    }\n\n    methods.close = (id: number | string) => {\n      setItems((prev) => prev.filter((prevOptions) => prevOptions.id !== id))\n    }\n\n    methods.isActive = (id: number | string) =>\n      !!items.find((prevOptions) => prevOptions.id === id)\n\n    return methods\n  }, [items, limit, getOptions])\n\n  const snacks = useMemo(\n    () => ({ direction, items, startIndex }),\n    [direction, startIndex, items],\n  )\n\n  return { snack, snacks }\n}\n\nexport type UseSnacksReturn = ReturnType<typeof useSnacks>\n"
    }
  ]
}
