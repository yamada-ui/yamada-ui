{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": ["intl-messageformat@^10.7.16"],
    "hooks": [],
    "providers": []
  },
  "dependents": {
    "components": [
      "autocomplete",
      "avatar",
      "breadcrumb",
      "calendar",
      "carousel",
      "close-button",
      "format-byte",
      "format-number",
      "hue-slider",
      "modal",
      "number-input",
      "pagination",
      "password-input",
      "progress",
      "select",
      "slider",
      "stat",
      "tag",
      "toggle"
    ],
    "hooks": [],
    "providers": ["ui-provider"]
  },
  "section": "providers",
  "sources": [
    {
      "name": "i18n-cache.ts",
      "content": "interface FormatOptions<Y> {\n  options: Y extends Intl.NumberFormat\n    ? Intl.NumberFormatOptions\n    : Y extends Intl.DateTimeFormat\n      ? Intl.DateTimeFormatOptions\n      : Y extends Intl.RelativeTimeFormat\n        ? Intl.RelativeTimeFormatOptions\n        : Y extends Intl.ListFormat\n          ? Intl.ListFormatOptions\n          : Y extends Intl.PluralRules\n            ? Intl.PluralRulesOptions\n            : Y extends Intl.Collator\n              ? Intl.CollatorOptions\n              : never\n}\n\nexport const i18nCache = <Y extends abstract new (...args: any) => any>(\n  Instance: Y,\n) => {\n  const formatterCache = new Map<string, Y>()\n\n  return function create(\n    locale: string,\n    options?: FormatOptions<InstanceType<Y>>[\"options\"],\n  ): InstanceType<Y> {\n    const key =\n      locale +\n      (options\n        ? Object.entries(options)\n            .sort((a, b) => (a[0] < b[0] ? -1 : 1))\n            .join()\n        : \"\")\n\n    if (formatterCache.has(key))\n      return formatterCache.get(key) as InstanceType<Y>\n\n    // @ts-ignore\n    const formatter = new Instance(locale, options)\n\n    formatterCache.set(key, formatter)\n\n    return formatter as any\n  }\n}\n"
    },
    {
      "name": "i18n-provider.tsx",
      "content": "\"use client\"\n\nimport type { Formats, Options } from \"intl-messageformat\"\nimport type { FC, ReactNode } from \"react\"\nimport type { TextDirection, Dict, Path, Value } from \"@yamada-ui/react\"\nimport type { IcuArgs } from \"./icu.types\"\nimport IntlMessageFormat from \"intl-messageformat\"\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\"\nimport {\n  DEFAULT_DIRECTION,\n  DEFAULT_LOCALE,\n  createdDom,\n  getMemoizedObject as get,\n  isEmptyObject,\n  isRtl,\n  isString,\n  isUndefined,\n  noop,\n  useSsr,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\nimport DEFAULT_INTL from \"./intl\"\n\nexport interface Language {\n  dir: TextDirection\n  locale: string\n}\n\nconst DEFAULT_LANGUAGE: Language = {\n  dir: DEFAULT_DIRECTION,\n  locale: DEFAULT_LOCALE,\n}\n\nexport function getLanguage(locale?: string, dir?: TextDirection): Language {\n  locale ??= createdDom() ? navigator.language : DEFAULT_LOCALE\n\n  try {\n    Intl.DateTimeFormat.supportedLocalesOf([locale])\n  } catch (_err) {\n    locale = DEFAULT_LOCALE\n  }\n\n  dir ??= isRtl(locale) ? \"rtl\" : \"ltr\"\n\n  return { dir, locale }\n}\n\ntype DefaultLocale = \"en-US\"\ntype IntlData = (typeof DEFAULT_INTL)[DefaultLocale]\ntype IntlKey = keyof IntlData\ntype IntlPath = Path<IntlData>\n\ntype Translation<Y extends object = IntlData, M extends string = IntlPath> = <\n  D extends M,\n>(\n  path: D,\n  ...args: IcuArgs<Value<Y, D>> extends never\n    ? [replaceValues?: IcuArgs<Value<Y, D>, IntlPath | M>]\n    : [replaceValues: IcuArgs<Value<Y, D>, IntlPath | M>]\n) => string\n\ninterface I18nContext<Y extends object = IntlData, M extends string = IntlPath>\n  extends Language {\n  changeLanguage: (locale?: string, dir?: TextDirection) => void\n  getTranslation: (key?: IntlKey) => Translation<Y, M>\n  t: Translation<Y, M>\n}\n\nexport const I18nContext = createContext<I18nContext>({\n  ...DEFAULT_LANGUAGE,\n  changeLanguage: noop,\n  getTranslation: () => () => \"\",\n  t: () => \"\",\n})\n\nexport interface I18nProviderProps {\n  children?: ReactNode\n  /**\n   * The text direction to apply to the application.\n   *\n   * If not provided, the direction will be determined by the locale.\n   */\n  dir?: TextDirection\n  /**\n   * The formats to pass to the `intlMessageFormat` instance.\n   */\n  formats?: Formats\n  /**\n   * The internationalization messages to apply to the application.\n   *\n   * This prop expects a dictionary object where the keys are locale strings (e.g., \"en-US\").\n   */\n  intl?: Dict\n  /**\n   * The options to pass to the `intlMessageFormat` instance.\n   */\n  intlMessageFormatOptions?: Options\n  /**\n   * The locale to apply to the application.\n   *\n   * If not provided, the locale will be determined by the browser.\n   */\n  locale?: string\n}\n\nexport const I18nProvider: FC<I18nProviderProps> = ({\n  children,\n  dir: forcedDir,\n  formats,\n  intl = DEFAULT_INTL as Dict,\n  intlMessageFormatOptions,\n  locale: forcedLocale,\n}) => {\n  const ssr = useSsr()\n  const [language, setLanguage] = useState(getLanguage(forcedLocale, forcedDir))\n  const controlled = !isUndefined(forcedLocale)\n  const { locale } = language\n\n  const messages = useMemo(() => intl[locale], [intl, locale])\n\n  const changeSystemLanguage = useCallback(() => {\n    setLanguage(getLanguage())\n  }, [])\n\n  const changeLanguage = useCallback((locale?: string, dir?: TextDirection) => {\n    setLanguage(getLanguage(locale, dir))\n  }, [])\n\n  const getValue = useCallback(\n    (path: number | string) => {\n      const value = get<string | undefined>(messages, path)\n\n      if (!isUndefined(value)) {\n        return value\n      } else {\n        path = path.toString().replace(/^[^.]+\\./g, \"\")\n\n        return get<string | undefined>(messages, path)\n      }\n    },\n    [messages],\n  )\n\n  const getTranslation = useCallback(\n    (key?: IntlKey) =>\n      <Y extends IntlPath>(\n        path: Y,\n        replaceValues?: IcuArgs<Value<IntlData, Y>, IntlPath>,\n      ) => {\n        const value = getValue(key ? `${key}.${path}` : path) ?? path\n\n        if (isUndefined(replaceValues)) return value\n\n        try {\n          const resolvedReplaceValues = Object.entries(replaceValues).reduce<{\n            [key: string]: any\n          }>((prev, [key, pathOrValue]) => {\n            if (isString(pathOrValue)) {\n              const resolvedPathOrValue = String(pathOrValue)\n              const value =\n                getValue(\n                  key ? `${key}.${resolvedPathOrValue}` : resolvedPathOrValue,\n                ) ?? resolvedPathOrValue\n\n              prev[key] = value\n            } else {\n              prev[key] = pathOrValue\n            }\n\n            return prev\n          }, {})\n\n          const message = new IntlMessageFormat(\n            value,\n            locale,\n            formats,\n            intlMessageFormatOptions,\n          )\n\n          return message.format(resolvedReplaceValues) as string\n        } catch (e) {\n          if (e instanceof Error) console.warn(e.message)\n\n          return value\n        }\n      },\n    [getValue, locale, formats, intlMessageFormatOptions],\n  )\n\n  const value = useMemo(() => {\n    const rest = { changeLanguage, getTranslation, t: getTranslation() }\n\n    if (ssr) return { ...DEFAULT_LANGUAGE, ...rest }\n\n    return { ...language, ...rest }\n  }, [changeLanguage, getTranslation, ssr, language])\n\n  useEffect(() => {\n    if (controlled) return\n\n    window.addEventListener(\"languagechange\", changeSystemLanguage)\n\n    return () => {\n      window.removeEventListener(\"languagechange\", changeSystemLanguage)\n    }\n  }, [controlled, changeSystemLanguage])\n\n  useUpdateEffect(() => {\n    setLanguage(getLanguage(forcedLocale, forcedDir))\n  }, [forcedLocale, forcedDir])\n\n  return <I18nContext value={value}>{children}</I18nContext>\n}\n\nexport function useI18n(): I18nContext\n\nexport function useI18n<Y extends IntlKey>(\n  key: Y,\n): I18nContext<IntlData[Y], Path<IntlData[Y]>>\n\nexport function useI18n<Y extends IntlKey>(key?: Y) {\n  const context = useContext(I18nContext)\n\n  const translation = useCallback(\n    <M extends Path<IntlData[Y]>>(\n      path: M,\n      replaceValues?: IcuArgs<\n        Value<IntlData[Y], M>,\n        IntlPath | Path<IntlData[Y]>\n      >,\n    ) => context.getTranslation(key)(path as any, replaceValues as any),\n    [key, context],\n  )\n\n  if (isEmptyObject(context))\n    return {\n      ...DEFAULT_LANGUAGE,\n      changeLanguage: noop,\n      t: () => \"\",\n    }\n\n  if (key) {\n    return { ...context, t: translation }\n  } else {\n    return context\n  }\n}\n"
    },
    {
      "name": "icu.types.ts",
      "content": "import type { ReactNode } from \"react\"\nimport type { AnyString } from \"@yamada-ui/react\"\n\ntype FindElements<Y> = Y extends `${string}<${infer M}>${infer D}`\n  ? M extends `/${string}`\n    ? []\n    : [M, ...FindElements<D>]\n  : []\n\ntype FindBlocks<Y> = Y extends `${string}{${infer M}`\n  ? ReadBlock<\"\", M, \"\"> extends [infer D, infer H]\n    ? [D, ...FindBlocks<H>]\n    : []\n  : []\n\ntype ReadBlock<\n  Y extends string,\n  M extends string,\n  D extends string,\n> = M extends `${infer H}}${infer R}`\n  ? H extends `${infer T}{${infer M}`\n    ? ReadBlock<`${Y}${T}{`, `${M}}${R}`, `${D}+`>\n    : D extends `+${infer M}`\n      ? ReadBlock<`${Y}${H}}`, R, M>\n      : [`${Y}${H}`, R]\n  : []\n\ntype Whitespace = \" \" | \"\\n\" | \"\\r\" | \"\\t\"\n\ntype Trim<Y> = Y extends `${Whitespace}${infer M}`\n  ? Trim<M>\n  : Y extends `${infer D}${Whitespace}`\n    ? Trim<D>\n    : Y extends string\n      ? Y\n      : never\n\ntype ExcludeEscape<Y> = Y extends `${infer M}'${string}'${infer D}`\n  ? `${ExcludeEscape<M>}${ExcludeEscape<D>}`\n  : Y\n\ntype ExcludeEmptyObject<Y> = Y extends { [key: string]: never } ? never : Y\n\ntype TransformOther<Y> = Y extends \"other\" ? AnyString : Y\n\ntype ArgumentValue<Y, M extends string = string> = Y extends \"select\"\n  ? never\n  : Y extends \"plural\"\n    ? number\n    : Y extends \"number\"\n      ? number\n      : Y extends \"date\"\n        ? Date\n        : Y extends \"time\"\n          ? Date\n          : AnyString | M | number\n\ntype ParseSelectBlock<\n  Y,\n  M,\n  D extends string = string,\n> = M extends `${infer H}{${infer R}`\n  ? ReadBlock<\"\", R, \"\"> extends [infer T, infer M]\n    ?\n        | (ParseBlocks<FindBlocks<T>, D> & {\n            [M in Trim<Y>]: TransformOther<Trim<H>>\n          })\n        | ParseSelectBlock<Y, M, D>\n    : never\n  : never\n\ntype ConcatBlocks<Y> = Y extends readonly [infer M, ...infer D]\n  ? [...FindBlocks<M>, ...ConcatBlocks<D>]\n  : []\n\ntype ParseBlock<\n  Y,\n  M extends string = string,\n> = Y extends `${infer D},${infer H},${infer R}`\n  ? Trim<H> extends \"select\"\n    ? ParseSelectBlock<D, Trim<R>, M>\n    : ParseBlocks<ConcatBlocks<FindBlocks<R>>, M> & {\n        [T in Trim<D>]: ArgumentValue<Trim<H>, M>\n      }\n  : Y extends `${infer D},${infer H}`\n    ? { [T in Trim<D>]: ArgumentValue<Trim<H>, M> }\n    : { [T in Trim<Y>]: AnyString | M | number }\n\ntype ParseBlocks<Y, M extends string = string> = Y extends [infer D, ...infer H]\n  ? {\n      [R in\n        | keyof ParseBlock<D, M>\n        | keyof ParseBlocks<H, M>]: R extends keyof ParseBlock<D, M>\n        ? ParseBlock<D, M>[R]\n        : R extends keyof ParseBlocks<H, M>\n          ? ParseBlocks<H, M>[R]\n          : never\n    }\n  : {}\n\ntype ParseElement<Y> = {\n  [M in Trim<Y>]: (chunks: string[]) => ReactNode\n}\n\ntype ParseElements<Y> = Y extends [infer M, ...infer D]\n  ? {\n      [H in\n        | keyof ParseElement<M>\n        | keyof ParseElements<D>]: H extends keyof ParseElement<M>\n        ? ParseElement<M>[H]\n        : H extends keyof ParseElements<D>\n          ? ParseElements<D>[H]\n          : never\n    }\n  : {}\n\nexport type IcuArgs<Y, M extends string = string> = ExcludeEmptyObject<{\n  [D in\n    | keyof ParseBlocks<FindBlocks<ExcludeEscape<Y>>, M>\n    | keyof ParseElements<\n        FindElements<ExcludeEscape<Y>>\n      >]: D extends keyof ParseBlocks<FindBlocks<ExcludeEscape<Y>>, M>\n    ? ParseBlocks<FindBlocks<ExcludeEscape<Y>>, M>[D]\n    : D extends keyof ParseElements<FindElements<ExcludeEscape<Y>>>\n      ? ParseElements<FindElements<ExcludeEscape<Y>>>[D]\n      : never\n}>\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./i18n-cache\"\nexport * from \"./i18n-provider\"\n"
    },
    {
      "name": "intl/en-US.ts",
      "content": "export default {\n  autocomplete: {\n    \"Clear value\": \"Clear value\",\n    \"No results found\": \"No results found\",\n  },\n  avatar: {\n    \"Avatar Icon\": \"Avatar Icon\",\n  },\n  breadcrumb: {\n    Breadcrumb: \"Breadcrumb\",\n    Ellipsis: \"Ellipsis\",\n  },\n  calendar: {\n    \"Choose the month\": \"Choose the month\",\n    \"Choose the year\": \"Choose the year\",\n    dd: \"dd\",\n    \"dddd, MMMM DD, YYYY\": \"dddd, MMMM DD, YYYY\",\n    \"Go to the next month\": \"Go to the next month\",\n    \"Go to the previous month\": \"Go to the previous month\",\n    MMM: \"MMM\",\n    \"MMMM YYYY\": \"MMMM YYYY\",\n    Today: \"Today\",\n    YYYY: \"YYYY\",\n  },\n  carousel: {\n    \"Go to next slide\": \"Go to next slide\",\n    \"Go to previous slide\": \"Go to previous slide\",\n    \"Go to {page} slide\": \"Go to {page} slide\",\n    Slides: \"Slides\",\n    \"{page} of {total}\": \"{page} of {total}\",\n  },\n  closeButton: {\n    Close: \"Close\",\n  },\n  hueSlider: {\n    Blue: \"Blue\",\n    Cyan: \"Cyan\",\n    Green: \"Green\",\n    Magenta: \"Magenta\",\n    Red: \"Red\",\n    Yellow: \"Yellow\",\n  },\n  modal: {\n    \"Close modal\": \"Close modal\",\n    \"Open modal\": \"Open modal\",\n  },\n  numberInput: {\n    Decrease: \"Decrease\",\n    Increase: \"Increase\",\n  },\n  pagination: {\n    \"Go to first page\": \"Go to first page\",\n    \"Go to last page\": \"Go to last page\",\n    \"Go to next page\": \"Go to next page\",\n    \"Go to page\": \"Go to page {value}\",\n    \"Go to previous page\": \"Go to previous page\",\n    Pagination: \"Pagination\",\n    \"{value} / {total}\": \"{value} / {total}\",\n    \"{value} of {total}\": \"{value} of {total}\",\n  },\n  passwordInput: {\n    \"Password strength meter\": \"Password strength meter\",\n    \"Toggle password visibility\": \"Toggle password visibility\",\n  },\n  progress: {\n    \"Loading...\": \"Loading...\",\n    \"{value} percent\": \"{value} percent\",\n  },\n  select: {\n    \"Clear value\": \"Clear value\",\n  },\n  slider: {\n    \"Slider thumb\": \"Slider thumb\",\n  },\n  stat: {\n    \"Decreased by\": \"Decreased by\",\n    \"Increased by\": \"Increased by\",\n  },\n  tag: {\n    \"Close tag\": \"Close tag\",\n  },\n  toggle: {\n    \"Toggle button\": \"Toggle button\",\n  },\n} as const\n"
    },
    {
      "name": "intl/index.ts",
      "content": "import enUS from \"./en-US\"\nimport jaJP from \"./ja-JP\"\n\nconst intl = { \"en-US\": enUS, \"ja-JP\": jaJP }\n\nexport default intl\n"
    },
    {
      "name": "intl/ja-JP.ts",
      "content": "export default {\n  autocomplete: {\n    \"Clear value\": \"値を消去する\",\n    \"No results found\": \"結果が見つかりません\",\n  },\n  avatar: {\n    \"Avatar Icon\": \"アバターアイコン\",\n  },\n  breadcrumb: {\n    Breadcrumb: \"パンくずリスト\",\n    Ellipsis: \"省略記号\",\n  },\n  calendar: {\n    \"Choose the month\": \"月を選択する\",\n    \"Choose the year\": \"年を選択する\",\n    dd: \"dd\",\n    \"dddd, MMMM DD, YYYY\": \"YYYY年MM月DD日dddd\",\n    \"Go to the next month\": \"次の月に移動する\",\n    \"Go to the previous month\": \"前の月に移動する\",\n    MMM: \"MM月\",\n    \"MMMM YYYY\": \"YYYY年MM月\",\n    Today: \"今日\",\n    YYYY: \"YYYY年\",\n  },\n  carousel: {\n    \"Go to next slide\": \"次のスライドに移動する\",\n    \"Go to previous slide\": \"前のスライドに移動する\",\n    \"Go to {page} slide\": \"{page}スライドに移動する\",\n    Slides: \"スライド\",\n    \"{page} of {total}\": \"{page} / {total}\",\n  },\n  closeButton: {\n    Close: \"閉じる\",\n  },\n  hueSlider: {\n    Blue: \"青\",\n    Cyan: \"シアン\",\n    Green: \"緑\",\n    Magenta: \"マゼンタ\",\n    Red: \"赤\",\n    Yellow: \"黄\",\n  },\n  modal: {\n    \"Close modal\": \"モーダルを閉じる\",\n    \"Open modal\": \"モーダルを開く\",\n  },\n  numberInput: {\n    Decrease: \"減少\",\n    Increase: \"増加\",\n  },\n  pagination: {\n    \"Go to first page\": \"最初のページに移動する\",\n    \"Go to last page\": \"最後のページに移動する\",\n    \"Go to next page\": \"次のページに移動する\",\n    \"Go to page\": \"{value}ページに移動する\",\n    \"Go to previous page\": \"前のページに移動する\",\n    Pagination: \"ページネーション\",\n    \"{value} / {total}\": \"{value} / {total}\",\n    \"{value} of {total}\": \"{value} / {total} ページ\",\n  },\n  passwordInput: {\n    \"Password strength meter\": \"パスワードの強度\",\n    \"Toggle password visibility\": \"パスワードの表示を切り替える\",\n  },\n  progress: {\n    \"Loading...\": \"読み込み中...\",\n    \"{value} percent\": \"{value}パーセント\",\n  },\n  select: {\n    \"Clear value\": \"値を消去する\",\n  },\n  slider: {\n    \"Slider thumb\": \"スライダーのつまみ\",\n  },\n  stat: {\n    \"Decreased by\": \"減少\",\n    \"Increased by\": \"増加\",\n  },\n  tag: {\n    \"Close tag\": \"タグを閉じる\",\n  },\n  toggle: {\n    \"Toggle button\": \"トグルボタン\",\n  },\n} as const\n"
    }
  ]
}
