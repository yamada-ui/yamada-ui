{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["collapse", "motion", "icon"],
    "externals": [],
    "hooks": ["use-controllable-state", "use-descendants"],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "accordion.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const accordionStyle = defineComponentSlotStyle({\n  base: {\n    button: {\n      \"&[aria-disabled=true]\": {\n        cursor: \"default\",\n      },\n      alignItems: \"center\",\n      display: \"inline-flex\",\n      focusVisibleRing: \"inside\",\n      px: \"4\",\n      py: \"3\",\n      transitionDuration: \"moderate\",\n      transitionProperty: \"common\",\n      w: \"100%\",\n      _nativeDisabled: {\n        layerStyle: \"disabled\",\n      },\n    },\n    icon: {\n      color: \"fg.subtle\",\n      fontSize: \"xl\",\n      ml: \"auto\",\n      transformOrigin: \"center\",\n      transitionDuration: \"moderate\",\n      transitionProperty: \"transform\",\n      _expanded: {\n        transform: \"rotate(180deg)\",\n      },\n      _disabled: {\n        layerStyle: \"disabled\",\n      },\n    },\n    item: {\n      overflowAnchor: \"none\",\n    },\n    panel: {\n      pb: \"3\",\n      px: \"4\",\n    },\n    root: {\n      w: \"full\",\n    },\n  },\n\n  variants: {\n    panel: {\n      button: {\n        rounded: \"l2\",\n      },\n      item: {\n        layerStyle: \"panel\",\n        rounded: \"l2\",\n        _notFirst: {\n          mt: \"md\",\n        },\n      },\n    },\n    plain: {\n      item: {\n        borderTopWidth: \"1px\",\n        _last: {\n          borderBottomWidth: \"1px\",\n        },\n      },\n    },\n  },\n\n  defaultProps: {\n    variant: \"plain\",\n  },\n})\n\nexport type AccordionStyle = typeof accordionStyle\n"
    },
    {
      "name": "accordion.tsx",
      "content": "\"use client\"\n\nimport type {\n  HTMLProps,\n  HTMLStyledProps,\n  ThemeProps,\n  ReactNodeOrFunction,\n} from \"@yamada-ui/react\"\nimport type { CollapseProps } from \"../collapse\"\nimport type { WithTransitionProps } from \"../motion\"\nimport type { AccordionStyle } from \"./accordion.style\"\nimport type { UseAccordionItemProps, UseAccordionProps } from \"./use-accordion\"\nimport { Children, cloneElement, isValidElement, useMemo } from \"react\"\nimport {\n  createSlotComponent,\n  styled,\n  createContext,\n  isString,\n  runIfFn,\n  useSplitChildren,\n} from \"@yamada-ui/react\"\nimport { Collapse } from \"../collapse\"\nimport { ChevronDownIcon } from \"../icon\"\nimport { accordionStyle } from \"./accordion.style\"\nimport {\n  AccordionContext,\n  AccordionDescendantsContext,\n  AccordionItemContext,\n  useAccordion,\n  useAccordionItem,\n  useAccordionItemContext,\n} from \"./use-accordion\"\n\ninterface AccordionCallBackProps {\n  disabled?: boolean\n  expanded?: boolean\n}\n\nexport interface AccordionItem extends Omit<AccordionItemProps, \"index\"> {}\n\ninterface AccordionComponentContext\n  extends Pick<AccordionRootProps, \"icon\" | \"iconHidden\"> {}\n\nexport interface AccordionRootProps\n  extends Omit<HTMLStyledProps, \"onChange\">,\n    ThemeProps<AccordionStyle>,\n    UseAccordionProps {\n  /**\n   * The accordion icon for all items to use.\n   */\n  icon?: ReactNodeOrFunction<AccordionCallBackProps>\n  /**\n   * If `true`, hide the accordion icon for all items.\n   *\n   * @default false\n   */\n  iconHidden?: boolean\n  /**\n   * If provided, generate elements based on items.\n   */\n  items?: AccordionItem[]\n}\n\ninterface AccordionItemComponentContext\n  extends Pick<AccordionItemProps, \"icon\"> {}\n\nconst [AccordionItemComponentContext, useAccordionItemComponentContext] =\n  createContext<AccordionItemComponentContext>({\n    name: \"AccordionItemComponentContext\",\n  })\n\nconst {\n  ComponentContext,\n  PropsContext: AccordionPropsContext,\n  useComponentContext,\n  usePropsContext: useAccordionPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<\n  AccordionRootProps,\n  AccordionStyle,\n  AccordionComponentContext\n>(\"accordion\", accordionStyle)\n\nexport { AccordionPropsContext, useAccordionPropsContext }\n\n/**\n * `Accordion` is a component for a list that displays information in an expandable or collapsible manner.\n *\n * @see https://yamada-ui.com/docs/components/accordion\n */\nexport const AccordionRoot = withProvider<\"div\", AccordionRootProps>(\n  ({ children, icon, iconHidden, items, ...props }) => {\n    const {\n      descendants,\n      focusedIndex,\n      index,\n      multiple,\n      setFocusedIndex,\n      setIndex,\n      toggle,\n      getRootProps,\n    } = useAccordion(props)\n    const computedChildren = useMemo(() => {\n      if (children) return children\n\n      return items?.map((props, index) => (\n        <AccordionItem key={index} index={index} {...props} />\n      ))\n    }, [children, items])\n    const context = useMemo(\n      () => ({\n        focusedIndex,\n        icon,\n        iconHidden,\n        index,\n        multiple,\n        setFocusedIndex,\n        setIndex,\n        toggle,\n      }),\n      [\n        focusedIndex,\n        icon,\n        iconHidden,\n        index,\n        multiple,\n        setFocusedIndex,\n        setIndex,\n        toggle,\n      ],\n    )\n    const componentContext = useMemo(\n      () => ({ icon, iconHidden }),\n      [icon, iconHidden],\n    )\n\n    return (\n      <AccordionDescendantsContext value={descendants}>\n        <AccordionContext value={context}>\n          <ComponentContext value={componentContext}>\n            <styled.div {...getRootProps()}>{computedChildren}</styled.div>\n          </ComponentContext>\n        </AccordionContext>\n      </AccordionDescendantsContext>\n    )\n  },\n  \"root\",\n)()\n\nexport interface AccordionItemProps\n  extends Omit<HTMLStyledProps, \"children\">,\n    Omit<UseAccordionItemProps, \"children\"> {\n  /**\n   * The accordion button to use.\n   */\n  button?: ReactNodeOrFunction<AccordionCallBackProps>\n  /**\n   * The accordion children to use.\n   */\n  children?: ReactNodeOrFunction<AccordionCallBackProps>\n  /**\n   * The accordion icon to use.\n   */\n  icon?: ReactNodeOrFunction<AccordionCallBackProps>\n}\n\nexport const AccordionItem = withContext<\"div\", AccordionItemProps>(\n  ({ button, children, icon, ...rest }) => {\n    const {\n      disabled,\n      open,\n      getButtonProps,\n      getIconProps,\n      getItemProps,\n      getPanelProps,\n    } = useAccordionItem(rest)\n\n    children = useMemo(\n      () => runIfFn(children, { disabled, expanded: open }),\n      [children, disabled, open],\n    )\n\n    const [omittedChildren, customAccordionButton, customAccordionPanel] =\n      useSplitChildren(children, AccordionButton, AccordionPanel)\n\n    const context = useMemo(\n      () => ({\n        disabled,\n        icon,\n        open,\n        getButtonProps,\n        getIconProps,\n        getPanelProps,\n      }),\n      [disabled, getButtonProps, getPanelProps, getIconProps, icon, open],\n    )\n    const componentContext = useMemo(() => ({ icon }), [icon])\n\n    return (\n      <AccordionItemContext value={context}>\n        <AccordionItemComponentContext value={componentContext}>\n          <styled.div {...getItemProps()}>\n            {customAccordionButton ?? (\n              <AccordionButton>\n                {runIfFn(button, { disabled, expanded: open })}\n              </AccordionButton>\n            )}\n            {customAccordionPanel ?? (\n              <AccordionPanel>{omittedChildren}</AccordionPanel>\n            )}\n          </styled.div>\n        </AccordionItemComponentContext>\n      </AccordionItemContext>\n    )\n  },\n  \"item\",\n)()\n\nexport interface AccordionButtonProps extends HTMLStyledProps<\"button\"> {\n  /**\n   * The accordion icon to use.\n   */\n  icon?: ReactNodeOrFunction<{ disabled?: boolean; expanded?: boolean }>\n  /**\n   * Props the container element.\n   */\n  containerProps?: HTMLStyledProps\n}\n\nexport const AccordionButton = withContext<\"button\", AccordionButtonProps>(\n  ({ children, icon: customIcon, containerProps, ...rest }) => {\n    const { icon: rootIcon } = useComponentContext()\n    const { icon: itemIcon } = useAccordionItemComponentContext()\n    const { disabled, open, getButtonProps } = useAccordionItemContext()\n    const props = { disabled, expanded: open }\n\n    return (\n      <styled.h3 {...containerProps}>\n        <styled.button {...getButtonProps(rest)}>\n          {children}\n\n          <AccordionIcon>\n            {runIfFn(itemIcon, props) ??\n              runIfFn(rootIcon, props) ??\n              runIfFn(customIcon, props)}\n          </AccordionIcon>\n        </styled.button>\n      </styled.h3>\n    )\n  },\n  \"button\",\n)()\n\ninterface AccordionIconProps extends HTMLStyledProps<\"svg\"> {}\n\nexport const AccordionIcon = withContext<\"svg\", AccordionIconProps>(\n  ({ children = <ChevronDownIcon />, ...rest }) => {\n    const { iconHidden } = useComponentContext()\n    const { getIconProps } = useAccordionItemContext()\n\n    if (iconHidden) return null\n\n    if (isValidElement<HTMLProps<\"svg\">>(children))\n      return cloneElement(\n        children,\n        getIconProps({\n          ...rest,\n          ...children.props,\n        }),\n      )\n\n    return Children.count(children) > 1 ? Children.only(null) : null\n  },\n  \"icon\",\n)()\n\nexport interface AccordionPanelProps\n  extends Omit<HTMLStyledProps, \"transition\">,\n    Pick<\n      CollapseProps,\n      | \"animationOpacity\"\n      | \"endingHeight\"\n      | \"startingHeight\"\n      | keyof WithTransitionProps\n    > {}\n\nexport const AccordionPanel = withContext<\"div\", AccordionPanelProps>(\n  ({\n    animationOpacity,\n    children,\n    delay,\n    duration,\n    endingHeight,\n    startingHeight,\n    transition,\n    transitionEnd,\n    unmountOnExit,\n    ...rest\n  }) => {\n    const { open, getPanelProps } = useAccordionItemContext()\n\n    return (\n      <Collapse\n        {...{\n          animationOpacity,\n          delay,\n          duration,\n          endingHeight,\n          open,\n          startingHeight,\n          transition,\n          transitionEnd,\n          unmountOnExit,\n        }}\n      >\n        <styled.div {...getPanelProps(rest)}>\n          {isString(children) ? <styled.p>{children}</styled.p> : children}\n        </styled.div>\n      </Collapse>\n    )\n  },\n  \"panel\",\n)()\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./accordion.style\"\nexport type {\n  AccordionButtonProps,\n  AccordionItemProps,\n  AccordionPanelProps,\n  AccordionRootProps,\n} from \"./accordion\"\nexport {\n  AccordionButton,\n  AccordionItem,\n  AccordionPanel,\n  AccordionPropsContext,\n  AccordionRoot,\n  useAccordionPropsContext,\n} from \"./accordion\"\nexport * as Accordion from \"./namespace\"\nexport * from \"./use-accordion\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  AccordionButton as Button,\n  AccordionItem as Item,\n  AccordionPanel as Panel,\n  AccordionPropsContext as PropsContext,\n  AccordionRoot as Root,\n  useAccordionPropsContext as usePropsContext,\n} from \"./accordion\"\nexport type {\n  AccordionButtonProps as ButtonProps,\n  AccordionItemProps as ItemProps,\n  AccordionPanelProps as PanelProps,\n  AccordionRootProps as RootProps,\n} from \"./accordion\"\nexport {\n  AccordionContext as Context,\n  AccordionDescendantsContext as DescendantsContext,\n  AccordionItemContext as ItemContext,\n  useAccordionContext as useContext,\n  useAccordionDescendant as useDescendant,\n  useAccordionDescendants as useDescendants,\n  useAccordionItemContext as useItemContext,\n} from \"./use-accordion\"\n"
    },
    {
      "name": "use-accordion.ts",
      "content": "\"use client\"\n\nimport type { KeyboardEvent } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport { useCallback, useEffect, useId, useState } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { createDescendants } from \"../../hooks/use-descendants\"\nimport {\n  ariaAttr,\n  createContext,\n  cx,\n  dataAttr,\n  handlerAll,\n  isArray,\n  mergeRefs,\n  runKeyAction,\n} from \"@yamada-ui/react\"\n\nconst {\n  DescendantsContext: AccordionDescendantsContext,\n  useDescendant: useAccordionDescendant,\n  useDescendants: useAccordionDescendants,\n} = createDescendants<HTMLButtonElement>()\n\nexport {\n  AccordionDescendantsContext,\n  useAccordionDescendant,\n  useAccordionDescendants,\n}\n\ninterface AccordionContext\n  extends Omit<UseAccordionReturn, \"descendants\" | \"getRootProps\"> {}\n\nconst [AccordionContext, useAccordionContext] = createContext<AccordionContext>(\n  {\n    name: \"AccordionContext\",\n  },\n)\n\nexport { AccordionContext, useAccordionContext }\n\ninterface AccordionItemContext\n  extends Omit<UseAccordionItemReturn, \"getItemProps\"> {}\n\nconst [AccordionItemContext, useAccordionItemContext] =\n  createContext<AccordionItemContext>({\n    name: \"AccordionItemContext\",\n  })\n\nexport { AccordionItemContext, useAccordionItemContext }\n\nexport interface UseAccordionProps extends Omit<HTMLProps, \"onChange\"> {\n  /**\n   * The initial index(es) of the accordion item to expand.\n   */\n  defaultIndex?: number | number[]\n  /**\n   * The index(es) of the accordion item to expand.\n   */\n  index?: number | number[]\n  /**\n   * If `true`, multiple accordion items can be expanded at once.\n   *\n   * @default false\n   */\n  multiple?: boolean\n  /**\n   * If `true`, any expanded accordion item can be collapsed again.\n   *\n   * @default false\n   */\n  toggle?: boolean\n  /**\n   * The callback invoked when accordion items are expanded or collapsed.\n   */\n  onChange?: (index: number | number[]) => void\n}\n\nexport const useAccordion = ({\n  defaultIndex: defaultIndexProp,\n  index: indexProp,\n  multiple,\n  toggle,\n  onChange,\n  ...rest\n}: UseAccordionProps = {}) => {\n  if (\n    (indexProp || defaultIndexProp) != null &&\n    !isArray(indexProp || defaultIndexProp) &&\n    multiple\n  ) {\n    console.warn(\n      `Accordion: If 'multiple' is passed, then 'index' or 'defaultIndex' must be an array.`,\n    )\n  }\n\n  if (multiple && toggle) {\n    console.warn(\n      `Accordion: If 'multiple' is passed, 'toggle' will be ignored. Either remove 'toggle' or 'multiple' depending on whether you want multiple accordions visible or not`,\n    )\n  }\n\n  const descendants = useAccordionDescendants()\n\n  const [focusedIndex, setFocusedIndex] = useState<number>(-1)\n\n  const [index, setIndex] = useControllableState({\n    defaultValue: () =>\n      multiple ? (defaultIndexProp ?? []) : (defaultIndexProp ?? -1),\n    value: indexProp,\n    onChange,\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...props,\n      ...rest,\n      ref: mergeRefs(ref, rest.ref),\n    }),\n    [rest],\n  )\n\n  useEffect(() => {\n    return () => setFocusedIndex(-1)\n  }, [])\n\n  return {\n    descendants,\n    focusedIndex,\n    index,\n    multiple,\n    setFocusedIndex,\n    setIndex,\n    toggle,\n    getRootProps,\n  }\n}\n\nexport type UseAccordionReturn = ReturnType<typeof useAccordion>\n\nexport interface UseAccordionItemProps extends HTMLProps {\n  /**\n   * The index of the accordion item.\n   */\n  index: number\n  /**\n   * If `true`, the accordion item will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n}\n\nexport const useAccordionItem = ({\n  disabled,\n  index,\n  ...rest\n}: UseAccordionItemProps) => {\n  const itemId = useId()\n  const panelId = useId()\n  const {\n    index: selectedIndex,\n    multiple,\n    setFocusedIndex,\n    setIndex,\n    toggle,\n  } = useAccordionContext()\n  const { descendants, register } = useAccordionDescendant({ disabled })\n  const open =\n    index !== -1\n      ? isArray(selectedIndex)\n        ? selectedIndex.includes(index)\n        : selectedIndex === index\n      : false\n\n  if (open && disabled)\n    console.warn(`Accordion: Cannot open a disabled accordion item`)\n\n  const onChange = useCallback(\n    (open: boolean) => {\n      if (index === -1) return\n\n      if (multiple && isArray(selectedIndex)) {\n        setIndex(\n          open\n            ? selectedIndex.concat(index)\n            : selectedIndex.filter((i) => i !== index),\n        )\n      } else if (open) {\n        setIndex(index)\n      } else if (toggle) {\n        setIndex(-1)\n      }\n    },\n    [multiple, toggle, index, selectedIndex, setIndex],\n  )\n\n  const onFocus = useCallback(() => {\n    setFocusedIndex(index)\n  }, [setFocusedIndex, index])\n\n  const onClick = useCallback(() => {\n    onChange(!open)\n    setFocusedIndex(index)\n  }, [index, setFocusedIndex, open, onChange])\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLButtonElement>) => {\n      runKeyAction(ev, {\n        ArrowDown: () => {\n          const next = descendants.enabledNextValue(index)\n\n          next?.node.focus()\n        },\n        ArrowUp: () => {\n          const prev = descendants.enabledPrevValue(index)\n\n          prev?.node.focus()\n        },\n        End: () => {\n          const last = descendants.enabledLastValue()\n\n          last?.node.focus()\n        },\n        Home: () => {\n          const first = descendants.enabledFirstValue()\n\n          first?.node.focus()\n        },\n      })\n    },\n    [descendants, index],\n  )\n\n  const getItemProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      \"data-expanded\": dataAttr(open),\n      ...props,\n      ...rest,\n      ref: mergeRefs(ref, rest.ref),\n    }),\n    [open, rest],\n  )\n\n  const getButtonProps: PropGetter<\"button\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      id: itemId,\n      type: \"button\",\n      \"aria-controls\": panelId,\n      \"aria-disabled\": ariaAttr((!multiple && !toggle && open) || disabled),\n      \"aria-expanded\": open,\n      ...props,\n      ref: mergeRefs(register, ref),\n      disabled,\n      onClick: handlerAll(props.onClick, onClick),\n      onFocus: handlerAll(props.onFocus, onFocus),\n      onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n    }),\n    [\n      itemId,\n      open,\n      panelId,\n      multiple,\n      toggle,\n      disabled,\n      register,\n      onClick,\n      onFocus,\n      onKeyDown,\n    ],\n  )\n\n  const getPanelProps: PropGetter = useCallback(\n    ({ \"aria-labelledby\": ariaLabelledby, ...props } = {}) => ({\n      id: panelId,\n      \"aria-labelledby\": cx(ariaLabelledby, itemId),\n      role: \"region\",\n      ...props,\n    }),\n    [itemId, panelId],\n  )\n\n  const getIconProps: PropGetter<\"svg\"> = useCallback(\n    (props) => ({\n      \"aria-disabled\": ariaAttr(disabled),\n      \"aria-expanded\": open,\n      \"aria-hidden\": true,\n      role: \"presentation\",\n      ...props,\n    }),\n    [open, disabled],\n  )\n\n  return {\n    disabled,\n    open,\n    getButtonProps,\n    getIconProps,\n    getItemProps,\n    getPanelProps,\n  }\n}\n\nexport type UseAccordionItemReturn = ReturnType<typeof useAccordionItem>\n"
    }
  ]
}
