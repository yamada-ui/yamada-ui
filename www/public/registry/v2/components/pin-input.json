{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["input", "group", "field"],
    "externals": [],
    "hooks": ["use-controllable-state", "use-descendants"],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./pin-input.style\"\nexport * as PinInput from \"./namespace\"\nexport {\n  PinInputField,\n  PinInputPropsContext,\n  PinInputRoot,\n  usePinInputPropsContext,\n} from \"./pin-input\"\nexport type { PinInputFieldProps, PinInputRootProps } from \"./pin-input\"\nexport * from \"./use-pin-input\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  PinInputField as Field,\n  PinInputPropsContext as PropsContext,\n  PinInputRoot as Root,\n  usePinInputPropsContext as usePropsContext,\n} from \"./pin-input\"\nexport type {\n  PinInputFieldProps as FieldProps,\n  PinInputRootProps as RootProps,\n} from \"./pin-input\"\nexport {\n  PinInputDescendantsContext as DescendantsContext,\n  usePinInputDescendant as useDescendant,\n  usePinInputDescendants as useDescendants,\n} from \"./use-pin-input\"\n"
    },
    {
      "name": "pin-input.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\nimport { inputStyle } from \"../input\"\n\nexport const pinInputStyle = defineComponentSlotStyle({\n  base: {\n    field: {\n      ...inputStyle.base,\n      textAlign: \"center\",\n    },\n    root: {},\n  },\n\n  variants: {\n    filled: {\n      field: inputStyle.variants?.filled,\n    },\n    flushed: {\n      field: inputStyle.variants?.flushed,\n    },\n    outline: {\n      field: inputStyle.variants?.outline,\n    },\n    plain: {\n      field: inputStyle.variants?.plain,\n    },\n  },\n\n  sizes: {\n    xs: {\n      field: {\n        boxSize: inputStyle.sizes?.xs.minH,\n        fontSize: inputStyle.sizes?.xs.fontSize,\n      },\n    },\n    sm: {\n      field: {\n        boxSize: inputStyle.sizes?.sm.minH,\n        fontSize: inputStyle.sizes?.sm.fontSize,\n      },\n    },\n    md: {\n      field: {\n        boxSize: inputStyle.sizes?.md.minH,\n        fontSize: inputStyle.sizes?.md.fontSize,\n      },\n    },\n    lg: {\n      field: {\n        boxSize: inputStyle.sizes?.lg.minH,\n        fontSize: inputStyle.sizes?.lg.fontSize,\n      },\n    },\n    xl: {\n      field: {\n        boxSize: inputStyle.sizes?.xl.minH,\n        fontSize: inputStyle.sizes?.xl.fontSize,\n      },\n    },\n    \"2xl\": {\n      field: {\n        boxSize: inputStyle.sizes?.[\"2xl\"].minH,\n        fontSize: inputStyle.sizes?.[\"2xl\"].fontSize,\n      },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"outline\",\n  },\n})\n\nexport type PinInputStyle = typeof pinInputStyle\n"
    },
    {
      "name": "pin-input.tsx",
      "content": "\"use client\"\n\nimport type {\n  RequiredPropGetter,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type { GroupProps } from \"../group\"\nimport type { InputProps, UseInputBorderProps } from \"../input\"\nimport type { PinInputStyle } from \"./pin-input.style\"\nimport type { UsePinInputProps } from \"./use-pin-input\"\nimport { useMemo } from \"react\"\nimport {\n  createSlotComponent,\n  getValidChildren,\n  mergeRefs,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\nimport { Group } from \"../group\"\nimport { Input } from \"../input\"\nimport { pinInputStyle } from \"./pin-input.style\"\nimport {\n  PinInputDescendantsContext,\n  usePinInput,\n  usePinInputDescendant,\n} from \"./use-pin-input\"\n\ninterface ComponentContext extends UseInputBorderProps {\n  getInputProps: RequiredPropGetter<\"input\", { index: number }>\n}\n\nexport interface PinInputRootProps\n  extends Omit<\n      WithoutThemeProps<GroupProps, PinInputStyle>,\n      \"defaultValue\" | \"mask\" | \"onChange\"\n    >,\n    ThemeProps<PinInputStyle>,\n    UseInputBorderProps,\n    UsePinInputProps {\n  /**\n   * The number of inputs to display.\n   *\n   * @default 4\n   */\n  items?: number\n}\n\nconst {\n  ComponentContext,\n  PropsContext: PinInputPropsContext,\n  useComponentContext,\n  usePropsContext: usePinInputPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<PinInputRootProps, PinInputStyle, ComponentContext>(\n  \"pin-input\",\n  pinInputStyle,\n)\n\nexport { PinInputPropsContext, usePinInputPropsContext }\n\n/**\n * `PinInput` is a component used to capture pin codes or OTP (One-Time Password) inputs.\n *\n * @see https://yamada-ui.com/components/pin-input\n */\nexport const PinInputRoot = withProvider<\"div\", PinInputRootProps>(\n  ({ children, errorBorderColor, focusBorderColor, items = 4, ...rest }) => {\n    const { descendants, getInputProps, getRootProps } = usePinInput(rest)\n    const cloneChildren = useMemo(() => {\n      const validChildren = getValidChildren(children)\n\n      if (validChildren.length) {\n        return validChildren\n      } else {\n        return Array.from({ length: items }, (_, index) => (\n          <PinInputField key={index} index={index} />\n        ))\n      }\n    }, [children, items])\n    const context = useMemo(\n      () => ({ errorBorderColor, focusBorderColor, getInputProps }),\n      [getInputProps, errorBorderColor, focusBorderColor],\n    )\n\n    return (\n      <PinInputDescendantsContext value={descendants}>\n        <ComponentContext value={context}>\n          <Group {...getRootProps()}>{cloneChildren}</Group>\n        </ComponentContext>\n      </PinInputDescendantsContext>\n    )\n  },\n  \"root\",\n)()\n\nexport interface PinInputFieldProps extends InputProps {\n  /**\n   * The index of the pin input field.\n   */\n  index: number\n}\n\nexport const PinInputField = withContext<\"input\", PinInputFieldProps>(\n  Input,\n  \"field\",\n)(undefined, ({ ref, index, ...rest }) => {\n  const { errorBorderColor, focusBorderColor, getInputProps } =\n    useComponentContext()\n  const { register } = usePinInputDescendant()\n  const { props, ariaProps, dataProps, eventProps } = useFieldProps(rest)\n\n  return {\n    ...getInputProps({\n      errorBorderColor,\n      focusBorderColor,\n      ...ariaProps,\n      ...dataProps,\n      ...eventProps,\n      ...props,\n      ref: mergeRefs(register, ref),\n      index,\n    }),\n  }\n})\n"
    },
    {
      "name": "use-pin-input.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent, KeyboardEvent } from \"react\"\nimport type {\n  HTMLProps,\n  PropGetter,\n  RequiredPropGetter,\n} from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useEffect, useId, useState } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { createDescendants } from \"../../hooks/use-descendants\"\nimport { filterUndefined, handlerAll, runKeyAction } from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\nconst {\n  DescendantsContext: PinInputDescendantsContext,\n  useDescendant: usePinInputDescendant,\n  useDescendants: usePinInputDescendants,\n} = createDescendants<HTMLInputElement>()\n\nexport {\n  PinInputDescendantsContext,\n  usePinInputDescendant,\n  usePinInputDescendants,\n}\n\nconst toArray = (value?: string) => value?.split(\"\")\n\nconst validate = (value: string, type: UsePinInputProps[\"type\"]) => {\n  const NUMERIC_REGEX = /^[0-9]+$/\n  const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i\n\n  const regex = type === \"alphanumeric\" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX\n\n  return regex.test(value)\n}\n\nexport interface UsePinInputProps\n  extends Omit<HTMLProps, \"defaultValue\" | \"mask\" | \"onChange\" | \"value\">,\n    FieldProps {\n  /**\n   * The top-level id string that will be applied to the input fields.\n   * The index of the input will be appended to this top-level id.\n   */\n  id?: string\n  /**\n   * The type of values the pin-input should allow.\n   *\n   * @default 'number'\n   */\n  type?: \"alphanumeric\" | \"number\"\n  /**\n   * If `true`, the pin input receives focus on mount.\n   *\n   * @default false\n   */\n  autoFocus?: boolean\n  /**\n   * The initial value of the pin input.\n   */\n  defaultValue?: string\n  /**\n   * The number of inputs to display.\n   *\n   * @default 4\n   */\n  items?: number\n  /**\n   * If `true`, focus will move automatically to the next input once filled.\n   *\n   * @default true\n   */\n  manageFocus?: boolean\n  /**\n   * If `true`, the input's value will be masked just like `type=password`.\n   */\n  mask?: boolean\n  /**\n   * If `true`, the pin input component signals to its fields that they should.\n   */\n  otp?: boolean\n  /**\n   * The placeholder for the pin input.\n   *\n   * @default '○'\n   */\n  placeholder?: string\n  /**\n   * The value of the pin input.\n   */\n  value?: string\n  /**\n   * Function called on input change.\n   */\n  onChange?: (value: string) => void\n  /**\n   * Function called when all inputs have valid values.\n   */\n  onComplete?: (value: string) => void\n}\n\nexport const usePinInput = (props: UsePinInputProps = {}) => {\n  const uuid = useId()\n  const {\n    props: {\n      id = uuid,\n      type = \"number\",\n      autoFocus,\n      defaultValue,\n      disabled,\n      manageFocus = true,\n      mask,\n      otp = false,\n      placeholder = \"○\",\n      readOnly,\n      value,\n      onChange: onChangeProp,\n      onComplete,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const descendants = usePinInputDescendants()\n  const [moveFocus, setMoveFocus] = useState<boolean>(true)\n  const [focusedIndex, setFocusedIndex] = useState<number>(-1)\n  const [values, setValues] = useControllableState<string[]>({\n    defaultValue: toArray(defaultValue) || [],\n    value: toArray(value),\n    onChange: (values) => onChangeProp?.(values.join(\"\")),\n  })\n\n  const focusNext = useCallback(\n    (index: number) => {\n      if (!moveFocus || !manageFocus) return\n\n      const next = descendants.nextValue(index, false)\n\n      if (!next) return\n\n      requestAnimationFrame(() => next.node.focus())\n    },\n    [descendants, moveFocus, manageFocus],\n  )\n\n  const focusInputField = useCallback(\n    (direction: \"next\" | \"prev\", index: number) => {\n      const input =\n        direction === \"next\"\n          ? descendants.nextValue(index, false)\n          : descendants.prevValue(index, false)\n\n      if (!input) return\n\n      const valueLength = input.node.value.length\n\n      requestAnimationFrame(() => {\n        input.node.focus()\n        input.node.setSelectionRange(0, valueLength)\n      })\n    },\n    [descendants],\n  )\n\n  const setValue = useCallback(\n    (value: string, index: number, focus = true) => {\n      let nextValues = [...values]\n\n      nextValues[index] = value\n\n      setValues(nextValues)\n\n      nextValues = nextValues.filter(Boolean)\n\n      const complete = value !== \"\" && nextValues.length === descendants.count()\n\n      if (complete) {\n        onComplete?.(nextValues.join(\"\"))\n        descendants.value(index)?.node.blur()\n      } else if (focus) {\n        focusNext(index)\n      }\n    },\n    [values, setValues, descendants, onComplete, focusNext],\n  )\n\n  const getNextValue = useCallback(\n    (value: string | undefined, eventValue: string) => {\n      let nextValue = eventValue\n\n      if (!value?.length) return nextValue\n\n      if (value.startsWith(eventValue.charAt(0))) {\n        nextValue = eventValue.charAt(1)\n      } else if (value.startsWith(eventValue.charAt(1))) {\n        nextValue = eventValue.charAt(0)\n      }\n\n      return nextValue\n    },\n    [],\n  )\n\n  const onChange = useCallback(\n    (index: number) =>\n      ({ target }: ChangeEvent<HTMLInputElement>) => {\n        const eventValue = target.value\n        const currentValue = values[index]\n        const nextValue = getNextValue(currentValue, eventValue)\n\n        if (nextValue === \"\") {\n          setValue(\"\", index)\n\n          return\n        }\n\n        if (eventValue.length > 2) {\n          if (!validate(eventValue, type)) return\n\n          const nextValue = eventValue\n            .split(\"\")\n            .filter((_, index) => index < descendants.count())\n\n          setValues(nextValue)\n\n          if (nextValue.length === descendants.count()) {\n            onComplete?.(nextValue.join(\"\"))\n            descendants.value(index)?.node.blur()\n          }\n        } else {\n          if (validate(nextValue, type)) setValue(nextValue, index)\n\n          setMoveFocus(true)\n        }\n      },\n    [descendants, getNextValue, onComplete, setValue, setValues, type, values],\n  )\n\n  const onKeyDown = useCallback(\n    (index: number) => (ev: KeyboardEvent<HTMLInputElement>) => {\n      if (!manageFocus) return\n\n      runKeyAction(\n        ev,\n        {\n          ArrowLeft: (ev) => {\n            ev.preventDefault()\n            focusInputField(\"prev\", index)\n          },\n          ArrowRight: (ev) => {\n            ev.preventDefault()\n            focusInputField(\"next\", index)\n          },\n          Backspace: (ev) => {\n            if ((ev.target as HTMLInputElement).value === \"\") {\n              const prevInput = descendants.prevValue(index, false)\n\n              if (!prevInput) return\n\n              setValue(\"\", index - 1, false)\n              prevInput.node.focus()\n              setMoveFocus(true)\n            } else {\n              setMoveFocus(false)\n            }\n          },\n        },\n        { preventDefault: false },\n      )\n    },\n    [descendants, focusInputField, manageFocus, setValue],\n  )\n\n  const onFocus = useCallback(\n    (index: number) => () => setFocusedIndex(index),\n    [],\n  )\n\n  const onBlur = useCallback(() => setFocusedIndex(-1), [])\n\n  useEffect(() => {\n    if (!autoFocus) return\n\n    const firstValue = descendants.firstValue()\n\n    if (!firstValue) return\n\n    requestAnimationFrame(() => firstValue.node.focus())\n  }, [autoFocus, descendants])\n\n  const getRootProps: PropGetter = useCallback(\n    (props) => ({\n      role: \"group\",\n      ...rest,\n      ...props,\n    }),\n    [rest],\n  )\n\n  const getInputProps: RequiredPropGetter<\"input\", { index: number }> =\n    useCallback(\n      ({ index, ...props }) => ({\n        ...ariaProps,\n        ...dataProps,\n        type: mask ? \"password\" : type === \"number\" ? \"tel\" : \"text\",\n        autoComplete: otp ? \"one-time-code\" : \"off\",\n        disabled,\n        inputMode: type === \"number\" ? \"numeric\" : \"text\",\n        placeholder:\n          focusedIndex === index && !readOnly && !props.readOnly\n            ? \"\"\n            : placeholder,\n        readOnly,\n        value: values[index] || \"\",\n        ...filterUndefined(props),\n        id: `${id}${index ? `-${index}` : \"\"}`,\n        onBlur: handlerAll(eventProps.onBlur, props.onBlur, onBlur),\n        onChange: handlerAll(props.onChange, onChange(index)),\n        onFocus: handlerAll(eventProps.onFocus, props.onFocus, onFocus(index)),\n        onKeyDown: handlerAll(props.onKeyDown, onKeyDown(index)),\n      }),\n      [\n        ariaProps,\n        dataProps,\n        eventProps,\n        mask,\n        type,\n        disabled,\n        readOnly,\n        id,\n        otp,\n        focusedIndex,\n        placeholder,\n        values,\n        onBlur,\n        onChange,\n        onFocus,\n        onKeyDown,\n      ],\n    )\n\n  return {\n    descendants,\n    getInputProps,\n    getRootProps,\n  }\n}\n\nexport type UsePinInputReturn = ReturnType<typeof usePinInput>\n"
    }
  ]
}
