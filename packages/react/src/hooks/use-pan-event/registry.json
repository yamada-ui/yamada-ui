{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "dependents": { "components": ["slider"], "hooks": [], "providers": [] },
  "section": "hooks",
  "sources": [
    {
      "name": "index.ts",
      "content": "\"use client\"\n\nimport type {\n  DataAttributes,\n  HTMLAttributes,\n  RefAttributes,\n  RefObject,\n} from \"react\"\nimport type { Point } from \"@yamada-ui/react\"\nimport { useCallback, useRef } from \"react\"\nimport {\n  useEnvironment,\n  addDomEvent,\n  getEventPoint,\n  handlerAll,\n  isMultiTouchEvent,\n  mergeRefs,\n  useCallbackRef,\n  useUnmountEffect,\n} from \"@yamada-ui/react\"\n\nexport interface PanEventProps {\n  threshold?: number\n  onEnd?: (ev: PointerEvent, point: Point, rect: DOMRect) => void\n  onMove?: (ev: PointerEvent, point: Point, rect: DOMRect) => void\n  onStart?: (ev: PointerEvent, point: Point, rect: DOMRect) => void\n}\n\ninterface Props<Y extends HTMLElement>\n  extends DataAttributes,\n    HTMLAttributes<Y>,\n    RefAttributes<Y> {}\n\nexport const usePanEvent = <Y extends HTMLElement>({\n  threshold = 3,\n  ...rest\n}: PanEventProps = {}): [\n  RefObject<null | Y>,\n  (props?: Props<Y>) => Props<Y>,\n] => {\n  const { getWindow } = useEnvironment()\n  const onStart = useCallbackRef(rest.onStart)\n  const onMove = useCallbackRef(rest.onMove)\n  const onEnd = useCallbackRef(rest.onEnd)\n  const latestPoint = useRef<null | Point>(null)\n  const unsubscribe = useRef<(() => void)[]>([])\n  const ref = useRef<Y>(null)\n\n  const cleanup = useCallback(() => {\n    unsubscribe.current.forEach((unsubscribe) => unsubscribe())\n\n    latestPoint.current = null\n    unsubscribe.current = []\n  }, [])\n\n  const shouldMove = useCallback(\n    (point: Point) => {\n      if (threshold === 0) return true\n      if (!latestPoint.current) return true\n\n      const distance = Math.sqrt(\n        Math.pow(point.x - latestPoint.current.x, 2) +\n          Math.pow(point.y - latestPoint.current.y, 2),\n      )\n\n      return distance >= threshold\n    },\n    [threshold],\n  )\n\n  useUnmountEffect(() => {\n    cleanup()\n  })\n\n  const getProps = useCallback(\n    (props: Props<Y> = {}) => {\n      return {\n        ...props,\n        ref: mergeRefs(ref, props.ref),\n        onPointerDown: handlerAll(props.onPointerDown, (ev) => {\n          const win = ev.nativeEvent.view ?? getWindow()\n\n          if (!win) return\n          if (isMultiTouchEvent(ev.nativeEvent)) return\n          if (!ref.current) return\n\n          ev.preventDefault()\n\n          const point = getEventPoint(ev.nativeEvent)\n          const rect = ref.current.getBoundingClientRect()\n\n          onStart(ev.nativeEvent, point, rect)\n\n          latestPoint.current = point\n\n          unsubscribe.current.push(\n            addDomEvent(win, \"pointermove\", (ev) => {\n              if (!ref.current) return\n\n              const point = getEventPoint(ev)\n              const rect = ref.current.getBoundingClientRect()\n\n              if (!shouldMove(point)) return\n\n              latestPoint.current = point\n\n              onMove(ev, point, rect)\n            }),\n          )\n\n          unsubscribe.current.push(\n            addDomEvent(win, \"pointerup\", (ev) => {\n              if (!ref.current) return\n\n              cleanup()\n\n              const point = getEventPoint(ev)\n              const rect = ref.current.getBoundingClientRect()\n\n              onEnd(ev, point, rect)\n            }),\n          )\n\n          unsubscribe.current.push(\n            addDomEvent(win, \"pointercancel\", (ev) => {\n              if (!ref.current) return\n\n              cleanup()\n\n              const point = getEventPoint(ev)\n              const rect = ref.current.getBoundingClientRect()\n\n              onEnd(ev, point, rect)\n            }),\n          )\n        }),\n      }\n    },\n    [cleanup, getWindow, onEnd, onMove, onStart, shouldMove],\n  )\n\n  return [ref, getProps] as const\n}\n\nexport type UsePanEventReturn = ReturnType<typeof usePanEvent>\n"
    }
  ]
}
