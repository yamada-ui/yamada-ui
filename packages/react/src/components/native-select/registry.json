{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["input", "field", "group", "icon"],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "dependents": {
    "components": ["date-picker", "select"],
    "hooks": [],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./native-select.style\"\nexport * as NativeSelect from \"./namespace\"\nexport {\n  NativeSelectGroup,\n  NativeSelectOption,\n  NativeSelectPropsContext,\n  NativeSelectRoot,\n  NativeSelectSeparator,\n  useNativeSelectPropsContext,\n} from \"./native-select\"\nexport type {\n  NativeSelectGroupProps,\n  NativeSelectOptionProps,\n  NativeSelectRootProps,\n  NativeSelectSeparatorProps,\n} from \"./native-select\"\nexport * from \"./use-native-select\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  NativeSelectGroup as Group,\n  NativeSelectOption as Option,\n  NativeSelectPropsContext as PropsContext,\n  NativeSelectRoot as Root,\n  NativeSelectSeparator as Separator,\n  useNativeSelectPropsContext as usePropsContext,\n} from \"./native-select\"\nexport type {\n  NativeSelectGroupProps as GroupProps,\n  NativeSelectOptionProps as OptionProps,\n  NativeSelectRootProps as RootProps,\n  NativeSelectSeparatorProps as SeparatorProps,\n} from \"./native-select\"\nexport type { NativeSelectItem as Item } from \"./use-native-select\"\n"
    },
    {
      "name": "native-select.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\nimport {\n  getInputHeightStyle,\n  getInputPaddingResetStyle,\n  inputStyle,\n} from \"../input\"\n\nexport const nativeSelectStyle = defineComponentSlotStyle({\n  base: {\n    field: { ...inputStyle.base, _readOnly: { pointerEvents: \"none\" } },\n    icon: {\n      alignItems: \"center\",\n      color: \"colorScheme.outline\",\n      display: \"inline-flex\",\n      fontSize: \"1em\",\n      justifyContent: \"center\",\n      rounded: \"l1\",\n      _disabled: {\n        layerStyle: \"disabled\",\n      },\n    },\n    root: {},\n  },\n\n  variants: {\n    filled: {\n      field: inputStyle.variants?.filled,\n    },\n    flushed: {\n      field: inputStyle.variants?.flushed,\n      root: getInputPaddingResetStyle(\"& > :is(select, [role='combobox'])\"),\n    },\n    outline: {\n      field: inputStyle.variants?.outline,\n    },\n    plain: {\n      field: inputStyle.variants?.plain,\n    },\n  },\n\n  sizes: {\n    xs: {\n      field: { ...inputStyle.sizes?.xs, fontSize: \"1em\" },\n      root: {\n        ...getInputHeightStyle(\n          inputStyle.sizes?.xs.minH,\n          \"& > :is(select, [role='combobox'])\",\n        ),\n        fontSize: inputStyle.sizes?.xs.fontSize,\n      },\n    },\n    sm: {\n      field: { ...inputStyle.sizes?.sm, fontSize: \"1em\" },\n      root: {\n        ...getInputHeightStyle(\n          inputStyle.sizes?.sm.minH,\n          \"& > :is(select, [role='combobox'])\",\n        ),\n        fontSize: inputStyle.sizes?.sm.fontSize,\n      },\n    },\n    md: {\n      field: { ...inputStyle.sizes?.md, fontSize: \"1em\" },\n      root: {\n        ...getInputHeightStyle(\n          inputStyle.sizes?.md.minH,\n          \"& > :is(select, [role='combobox'])\",\n        ),\n        fontSize: inputStyle.sizes?.md.fontSize,\n      },\n    },\n    lg: {\n      field: { ...inputStyle.sizes?.lg, fontSize: \"1em\" },\n      root: {\n        ...getInputHeightStyle(\n          inputStyle.sizes?.lg.minH,\n          \"& > :is(select, [role='combobox'])\",\n        ),\n        fontSize: inputStyle.sizes?.lg.fontSize,\n      },\n    },\n    xl: {\n      field: { ...inputStyle.sizes?.xl, fontSize: \"1em\" },\n      root: {\n        ...getInputHeightStyle(\n          inputStyle.sizes?.xl.minH,\n          \"& > :is(select, [role='combobox'])\",\n        ),\n        fontSize: inputStyle.sizes?.xl.fontSize,\n      },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"outline\",\n  },\n})\n\nexport type NativeSelectStyle = typeof nativeSelectStyle\n"
    },
    {
      "name": "native-select.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport type { HTMLProps, HTMLStyledProps, ThemeProps } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { NativeSelectStyle } from \"./native-select.style\"\nimport type { UseNativeSelectProps } from \"./use-native-select\"\nimport { createSlotComponent } from \"@yamada-ui/react\"\nimport { useGroupItemProps } from \"../group\"\nimport { ChevronDownIcon } from \"../icon\"\nimport { InputGroup, useInputBorder, useInputPropsContext } from \"../input\"\nimport { nativeSelectStyle } from \"./native-select.style\"\nimport { useNativeSelect } from \"./use-native-select\"\n\nexport interface NativeSelectRootProps\n  extends Omit<HTMLStyledProps<\"select\">, \"size\">,\n    UseNativeSelectProps,\n    ThemeProps<NativeSelectStyle>,\n    FieldProps,\n    UseInputBorderProps {\n  /**\n   * The icon to be used in the select.\n   */\n  icon?: ReactNode\n  /**\n   * The props for the end element.\n   */\n  elementProps?: InputGroup.ElementProps\n  /**\n   * Props for icon element.\n   */\n  iconProps?: NativeSelectIconProps\n  /**\n   * Props for root element.\n   */\n  rootProps?: InputGroup.RootProps\n}\n\nconst {\n  component,\n  PropsContext: NativeSelectPropsContext,\n  usePropsContext: useNativeSelectPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<NativeSelectRootProps, NativeSelectStyle>(\n  \"native-select\",\n  nativeSelectStyle,\n)\n\nexport { NativeSelectPropsContext, useNativeSelectPropsContext }\n\n/**\n * `NativeSelect` is a component used for allowing users to select one option from a list. It displays a native dropdown list provided by the browser (user agent).\n *\n * @see https://yamada-ui.com/docs/components/native-select\n */\nexport const NativeSelectRoot = withProvider<\"select\", NativeSelectRootProps>(\n  (props) => {\n    const [\n      groupItemProps,\n      {\n        className,\n        css,\n        colorScheme,\n        errorBorderColor,\n        focusBorderColor,\n        icon,\n        elementProps,\n        iconProps,\n        rootProps,\n        ...rest\n      },\n    ] = useGroupItemProps(props)\n    const { getFieldProps, getIconProps, getRootProps } = useNativeSelect(rest)\n    const varProps = useInputBorder({\n      errorBorderColor,\n      focusBorderColor,\n    })\n\n    return (\n      <InputGroup.Root\n        className={className}\n        css={css}\n        colorScheme={colorScheme}\n        {...getRootProps({ ...groupItemProps, ...rootProps })}\n      >\n        <NativeSelectField {...getFieldProps(varProps)} />\n\n        <InputGroup.Element {...elementProps}>\n          <NativeSelectIcon icon={icon} {...getIconProps(iconProps)} />\n        </InputGroup.Element>\n      </InputGroup.Root>\n    )\n  },\n  \"root\",\n)((props) => {\n  const context = useInputPropsContext()\n\n  return { ...context, ...props }\n})\n\ninterface NativeSelectFieldProps extends HTMLStyledProps<\"select\"> {}\n\nconst NativeSelectField = withContext<\"select\", NativeSelectFieldProps>(\n  \"select\",\n  \"field\",\n)({ \"data-group-propagate\": \"\" })\n\ninterface NativeSelectIconProps extends HTMLStyledProps {\n  icon?: ReactNode\n}\n\nconst NativeSelectIcon = withContext<\"div\", NativeSelectIconProps>(\n  \"div\",\n  \"icon\",\n)(undefined, ({ children, icon, ...rest }) => ({\n  children: icon || children || <ChevronDownIcon />,\n  ...rest,\n}))\n\nexport interface NativeSelectGroupProps extends HTMLProps<\"optgroup\"> {}\n\nexport const NativeSelectGroup = component<\"optgroup\", NativeSelectGroupProps>(\n  \"optgroup\",\n  \"group\",\n)()\n\nexport interface NativeSelectOptionProps extends HTMLProps<\"option\"> {}\n\nexport const NativeSelectOption = component<\"option\", NativeSelectOptionProps>(\n  \"option\",\n  \"option\",\n)()\n\nexport interface NativeSelectSeparatorProps extends HTMLProps<\"hr\"> {}\n\nexport const NativeSelectSeparator = component<\n  \"hr\",\n  NativeSelectSeparatorProps\n>(\"hr\", \"separator\")()\n"
    },
    {
      "name": "use-native-select.tsx",
      "content": "\"use client\"\n\nimport type { ReactNode } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { cloneElement, useCallback, useMemo } from \"react\"\nimport { ariaAttr, handlerAll, mergeRefs } from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\ninterface NativeSelectSharedItem\n  extends Omit<HTMLProps<\"option\">, \"children\" | \"label\" | \"value\"> {\n  label: string\n}\n\ninterface NativeSelectItemWithValue extends NativeSelectSharedItem {\n  value?: HTMLProps<\"option\">[\"value\"]\n}\n\ninterface NativeSelectItemWithItems extends NativeSelectSharedItem {\n  items: NativeSelectItemWithValue[]\n}\n\nexport type NativeSelectItem =\n  | NativeSelectItemWithItems\n  | NativeSelectItemWithValue\n\nexport interface UseNativeSelectProps extends HTMLProps<\"select\">, FieldProps {\n  /**\n   * If `true`, include placeholder in options.\n   *\n   * @default true\n   */\n  includePlaceholder?: boolean\n  /**\n   * If provided, generate options based on items.\n   *\n   * @default []\n   */\n  items?: NativeSelectItem[]\n  /**\n   * The placeholder for select.\n   */\n  placeholder?: string\n}\n\nexport const useNativeSelect = (props: UseNativeSelectProps = {}) => {\n  const {\n    props: {\n      children,\n      disabled,\n      includePlaceholder = true,\n      items = [],\n      placeholder,\n      readOnly,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const interactive = !(readOnly || disabled)\n\n  const computedChildren = useMemo(() => {\n    let computedChildren: ReactNode = null\n\n    if (children) {\n      computedChildren = children\n    } else if (items.length) {\n      computedChildren = items.map((item, index) => {\n        if (\"items\" in item) {\n          const { items = [], label, ...rest } = item\n\n          return cloneElement(<optgroup />, {\n            key: index,\n            children: items.map(({ label, ...rest }, index) =>\n              cloneElement(<option />, {\n                key: index,\n                children: label,\n                ...rest,\n              }),\n            ),\n            label,\n            ...rest,\n          })\n        } else {\n          const { label, ...rest } = item\n\n          return cloneElement(<option />, {\n            key: index,\n            children: label,\n            ...rest,\n          })\n        }\n      })\n    }\n\n    return (\n      <>\n        {placeholder ? (\n          <option hidden={!includePlaceholder} value=\"\">\n            {placeholder}\n          </option>\n        ) : null}\n\n        {computedChildren}\n      </>\n    )\n  }, [children, items, placeholder, includePlaceholder])\n\n  const getRootProps: PropGetter = useCallback(\n    (props) => ({ ...dataProps, ...props }),\n    [dataProps],\n  )\n\n  const getFieldProps: PropGetter<\"select\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      disabled,\n      readOnly,\n      tabIndex: interactive ? undefined : -1,\n      ...ariaProps,\n      ...dataProps,\n      \"aria-disabled\": ariaAttr(!interactive),\n      \"aria-label\": placeholder,\n      ...rest,\n      ...props,\n      ref: mergeRefs(ref, rest.ref),\n      children: props.children ?? computedChildren,\n      onBlur: handlerAll(eventProps.onBlur, props.onBlur),\n      onFocus: handlerAll(eventProps.onFocus, props.onFocus),\n    }),\n    [\n      interactive,\n      ariaProps,\n      computedChildren,\n      dataProps,\n      eventProps,\n      rest,\n      placeholder,\n      disabled,\n      readOnly,\n    ],\n  )\n\n  const getIconProps: PropGetter = useCallback(\n    (props) => ({ ...dataProps, ...props }),\n    [dataProps],\n  )\n\n  return { getFieldProps, getIconProps, getRootProps }\n}\n\nexport type UseNativeSelectReturn = ReturnType<typeof useNativeSelect>\n"
    }
  ]
}
