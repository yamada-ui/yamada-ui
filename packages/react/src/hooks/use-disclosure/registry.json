{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "dependents": {
    "components": ["menu", "modal", "popover", "tooltip"],
    "hooks": ["use-combobox"],
    "providers": []
  },
  "section": "hooks",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./use-disclosure\"\nexport * from \"./use-promise-disclosure\"\n"
    },
    {
      "name": "use-disclosure.ts",
      "content": "\"use client\"\n\nimport { useCallback, useRef, useState } from \"react\"\nimport { useCallbackRef } from \"@yamada-ui/react\"\n\nexport type DisclosureCallback<Y, M> = [Y] extends [never]\n  ? () => M\n  : undefined extends Y\n    ? (value?: Y) => M\n    : (value: Y) => M\n\nexport interface UseDisclosureProps<\n  Y = never,\n  M = never,\n  D = Promise<void> | void,\n  H = Promise<void> | void,\n> {\n  /**\n   * If `true`, the element will be initially opened.\n   */\n  defaultOpen?: boolean\n  /**\n   * If `true`, the element will be opened.\n   */\n  open?: boolean\n  /**\n   * The timing of the open and close.\n   *\n   * @default 'after'\n   */\n  timing?: \"after\" | \"before\"\n  /**\n   * Callback invoked to close the element.\n   */\n  onClose?: DisclosureCallback<M, H>\n  /**\n   * Callback invoked to open the element.\n   */\n  onOpen?: DisclosureCallback<Y, D>\n}\n\n/**\n * `useDisclosure` is a custom hook that helps handle common open/close or toggle scenarios.\n * It can be used to control components such as `Modal`, `Dialog`, `Drawer`, etc.\n *\n * @see https://yamada-ui.com/docs/hooks/use-disclosure\n */\nexport const useDisclosure = <\n  Y = never,\n  M = never,\n  D = Promise<void> | void,\n  H = Promise<void> | void,\n>({\n  defaultOpen = false,\n  open: controlledOpen,\n  timing,\n  onClose: onCloseProp,\n  onOpen: onOpenProp,\n}: UseDisclosureProps<Y, M, D, H> = {}) => {\n  const [uncontrolledOpen, setUncontrolledOpen] = useState<boolean>(defaultOpen)\n\n  const timingRef = useRef(timing ?? \"after\")\n  const handleOpen = useCallbackRef(onOpenProp)\n  const handleClose = useCallbackRef(onCloseProp)\n\n  const controlled = controlledOpen !== undefined\n  const open = controlledOpen !== undefined ? controlledOpen : uncontrolledOpen\n\n  const onOpen = useCallback(\n    async (value: Y) => {\n      if (timingRef.current === \"before\") await handleOpen(value)\n\n      if (!controlled) setUncontrolledOpen(true)\n\n      if (timingRef.current === \"after\") await handleOpen(value)\n    },\n    [controlled, handleOpen, timingRef],\n  ) as DisclosureCallback<Y, D>\n\n  const onClose = useCallback(\n    async (value: M) => {\n      if (timingRef.current === \"before\") await handleClose(value)\n\n      if (!controlled) setUncontrolledOpen(false)\n\n      if (timingRef.current === \"after\") await handleClose(value)\n    },\n    [controlled, handleClose, timingRef],\n  ) as DisclosureCallback<M, H>\n\n  const onToggle = useCallback(\n    async (value: M | Y) =>\n      !open ? await onOpen(value as Y) : await onClose(value as M),\n    [open, onOpen, onClose],\n  ) as DisclosureCallback<M, H> | DisclosureCallback<Y, D>\n\n  return {\n    open,\n    onClose,\n    onOpen,\n    onToggle,\n  }\n}\n\nexport type UseDisclosureReturn<\n  Y = never,\n  M = never,\n  D = Promise<void> | void,\n  H = Promise<void> | void,\n> = ReturnType<typeof useDisclosure<Y, M, D, H>>\n"
    },
    {
      "name": "use-promise-disclosure.ts",
      "content": "\"use client\"\n\nimport type { DisclosureCallback, UseDisclosureProps } from \"./use-disclosure\"\nimport { useCallback, useRef } from \"react\"\nimport { noop } from \"@yamada-ui/react\"\nimport { useDisclosure } from \"./use-disclosure\"\n\nexport interface UsePromiseDisclosureProps<\n  Y = never,\n  M = never,\n  D = never,\n  H = Promise<void> | void,\n  R = Promise<void> | void,\n> extends UseDisclosureProps<M, D | Y, H, R> {\n  disableCloseOnSuccess?: boolean\n  error?: unknown\n}\n\n/**\n * `usePromiseDisclosure` is a custom hook that helps handle common open/close or toggle scenarios with promises.\n * It can be used to control components such as `Modal`, `Dialog`, `Drawer`, etc.\n *\n * @see https://yamada-ui.com/docs/hooks/use-promise-disclosure\n */\nexport const usePromiseDisclosure = <\n  Y = never,\n  M = never,\n  D = never,\n  H = Promise<void> | void,\n  R = Promise<void> | void,\n>({\n  disableCloseOnSuccess = false,\n  error,\n  ...rest\n}: UsePromiseDisclosureProps<Y, M, D, H, R> = {}) => {\n  const {\n    open,\n    onClose: onInternalClose,\n    onOpen: onInternalOpen,\n    onToggle,\n  } = useDisclosure<M, D | Y, H, R>(rest)\n\n  const rejectRef = useRef<((reason?: any) => void) | undefined>(undefined)\n  const resolveRef = useRef(noop as DisclosureCallback<Y, R>)\n\n  const onOpen = useCallback(\n    async (value: M) => {\n      const promise = new Promise<Y>((resolve, reject) => {\n        resolveRef.current = (async (value: Y) => {\n          rejectRef.current = undefined\n\n          resolve(value)\n\n          if (!disableCloseOnSuccess) await onInternalClose(value)\n        }) as DisclosureCallback<Y, R>\n\n        rejectRef.current = reject\n      })\n\n      await onInternalOpen(value)\n\n      return await promise\n    },\n    [onInternalOpen, onInternalClose, disableCloseOnSuccess],\n  ) as DisclosureCallback<M, [Y] extends [never] ? Promise<void> : Promise<Y>>\n\n  const onClose = useCallback(\n    async (value: D) => {\n      rejectRef.current?.(error)\n\n      await onInternalClose(value)\n    },\n    [onInternalClose, error],\n  ) as DisclosureCallback<D, R>\n\n  return {\n    open,\n    onClose,\n    onOpen,\n    onSuccess: resolveRef.current,\n    onToggle,\n  }\n}\n\nexport type UsePromiseDisclosureReturn<\n  Y = never,\n  M = never,\n  D = never,\n  H = Promise<void> | void,\n  R = Promise<void> | void,\n> = ReturnType<typeof usePromiseDisclosure<Y, M, D, H, R>>\n"
    }
  ]
}
