{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [
      "button",
      "close-button",
      "focus-lock",
      "motion",
      "popover",
      "portal",
      "fade"
    ],
    "externals": ["motion@12.18.1", "react-remove-scroll@^2.7.1"],
    "hooks": ["use-disclosure"],
    "providers": ["i18n-provider"]
  },
  "dependents": { "components": ["drawer"], "hooks": [], "providers": [] },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./modal.style\"\nexport {\n  ModalBody,\n  ModalCloseButton,\n  ModalCloseTrigger,\n  ModalContent,\n  ModalFooter,\n  ModalHeader,\n  ModalOpenTrigger,\n  ModalOverlay,\n  ModalPropsContext,\n  ModalRoot,\n  ModalTitle,\n  useModalPropsContext,\n} from \"./modal\"\nexport type {\n  ModalBodyProps,\n  ModalCloseButtonProps,\n  ModalCloseTriggerProps,\n  ModalContentProps,\n  ModalFooterProps,\n  ModalHeaderProps,\n  ModalOpenTriggerProps,\n  ModalOverlayProps,\n  ModalRootProps,\n  ModalTitleProps,\n} from \"./modal\"\nexport * as Modal from \"./namespace\"\nexport * from \"./use-modal\"\n"
    },
    {
      "name": "modal.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const modalStyle = defineComponentSlotStyle({\n  base: {\n    body: {\n      alignItems: \"flex-start\",\n      display: \"flex\",\n      flex: \"1\",\n      flexDirection: \"column\",\n      gap: \"md\",\n      my: \"lg\",\n      px: \"lg\",\n    },\n    closeButton: {\n      position: \"absolute\",\n      right: \"md\",\n      top: \"md\",\n    },\n    content: {\n      bg: [\"bg\", \"bg.panel\"],\n      borderColor: \"border.subtle\",\n      borderWidth: \"1px\",\n      boxShadow: \"lg\",\n      display: \"flex\",\n      flexDirection: \"column\",\n      maxH: \"full\",\n      position: \"relative\",\n      rounded: \"l4\",\n      w: \"full\",\n      zIndex: \"burter\",\n    },\n    footer: {\n      alignItems: \"center\",\n      display: \"flex\",\n      gap: \"md\",\n      justifyContent: \"flex-end\",\n      pb: \"lg\",\n      px: \"lg\",\n    },\n    header: {\n      alignItems: \"center\",\n      display: \"flex\",\n      gap: \"md\",\n      justifyContent: \"flex-start\",\n      pt: \"lg\",\n      px: \"lg\",\n    },\n    overlay: {\n      bg: \"bg.overlay\",\n      h: \"dvh\",\n      inset: \"0\",\n      position: \"fixed\",\n      w: \"vw\",\n      zIndex: \"jeice\",\n    },\n    root: {\n      alignItems: \"center\",\n      display: \"flex\",\n      h: \"dvh\",\n      inset: \"0\",\n      justifyContent: \"center\",\n      p: \"md\",\n      position: \"fixed\",\n      w: \"vw\",\n      zIndex: \"guldo\",\n    },\n    title: {\n      fontSize: \"xl\",\n      fontWeight: \"semibold\",\n    },\n  },\n\n  props: {\n    /**\n     * The placement of the modal.\n     *\n     * @default 'center'\n     */\n    placement: {\n      center: {\n        root: {\n          alignItems: \"center\",\n          justifyContent: \"center\",\n        },\n      },\n      \"center-center\": {\n        root: {\n          alignItems: \"center\",\n          justifyContent: \"center\",\n        },\n      },\n      \"center-end\": {\n        root: {\n          alignItems: \"center\",\n          justifyContent: \"flex-end\",\n        },\n      },\n      \"center-start\": {\n        root: {\n          alignItems: \"center\",\n          justifyContent: \"flex-start\",\n        },\n      },\n      \"end-center\": {\n        root: {\n          alignItems: \"flex-end\",\n          justifyContent: \"center\",\n        },\n      },\n      \"end-end\": {\n        root: {\n          alignItems: \"flex-end\",\n          justifyContent: \"flex-end\",\n        },\n      },\n      \"end-start\": {\n        root: {\n          alignItems: \"flex-end\",\n          justifyContent: \"flex-start\",\n        },\n      },\n      \"start-center\": {\n        root: {\n          alignItems: \"flex-start\",\n          justifyContent: \"center\",\n        },\n      },\n      \"start-end\": {\n        root: {\n          alignItems: \"flex-start\",\n          justifyContent: \"flex-end\",\n        },\n      },\n      \"start-start\": {\n        root: {\n          alignItems: \"flex-start\",\n          justifyContent: \"flex-start\",\n        },\n      },\n    },\n    /**\n     * Where scroll behavior should originate.\n     *\n     * - `inside`: scroll only occurs within the `ModalBody`.\n     * - `outside`: the entire `ModalContent` will scroll within the viewport.\n     *\n     * @default 'inside'\n     */\n    scrollBehavior: {\n      inside: {\n        body: {\n          overflow: \"auto\",\n        },\n      },\n      outside: {\n        content: {\n          overflow: \"auto\",\n        },\n      },\n    },\n  },\n\n  sizes: {\n    xs: { content: { maxW: \"xs\" } },\n    sm: { content: { maxW: \"sm\" } },\n    md: { content: { maxW: \"md\" } },\n    lg: { content: { maxW: \"lg\" } },\n    xl: { content: { maxW: \"xl\" } },\n    \"2xl\": { content: { maxW: \"2xl\" } },\n    \"3xl\": { content: { maxW: \"3xl\" } },\n    \"4xl\": { content: { maxW: \"4xl\" } },\n    \"5xl\": { content: { maxW: \"5xl\" } },\n    \"6xl\": { content: { maxW: \"6xl\" } },\n    cover: { content: { boxSize: \"full\" } },\n    full: {\n      content: { minH: \"dvh\", minW: \"vw\", rounded: \"0\" },\n      root: { p: \"0\" },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    placement: \"center\",\n    scrollBehavior: \"inside\",\n  },\n})\n\nexport type ModalStyle = typeof modalStyle\n"
    },
    {
      "name": "modal.tsx",
      "content": "\"use client\"\n\nimport type { FC, PropsWithChildren, ReactNode } from \"react\"\nimport type { HTMLProps, HTMLStyledProps, ThemeProps } from \"@yamada-ui/react\"\nimport type { ButtonProps } from \"../button\"\nimport type { CloseButtonProps } from \"../close-button\"\nimport type { FocusLockProps } from \"../focus-lock\"\nimport type { HTMLMotionProps, HTMLMotionPropsWithoutAs } from \"../motion\"\nimport type { PopupAnimationProps } from \"../popover\"\nimport type { PortalProps } from \"../portal\"\nimport type { ModalStyle } from \"./modal.style\"\nimport type { UseModalProps, UseModalReturn } from \"./use-modal\"\nimport { AnimatePresence } from \"motion/react\"\nimport { useMemo } from \"react\"\nimport { RemoveScroll } from \"react-remove-scroll\"\nimport {\n  createSlotComponent,\n  styled,\n  cast,\n  isArray,\n  useSplitChildren,\n  wrapOrPassProps,\n} from \"@yamada-ui/react\"\nimport { Button } from \"../button\"\nimport { CloseButton } from \"../close-button\"\nimport { fadeVariants } from \"../fade\"\nimport { FocusLock } from \"../focus-lock\"\nimport { motion } from \"../motion\"\nimport { getPopupAnimationProps } from \"../popover\"\nimport { Portal } from \"../portal\"\nimport { modalStyle } from \"./modal.style\"\nimport { useModal } from \"./use-modal\"\n\ninterface ComponentContext\n  extends Omit<UseModalReturn, \"getRootProps\">,\n    PopupAnimationProps,\n    Pick<ModalRootProps, \"withCloseButton\"> {}\n\nexport interface ModalRootProps\n  extends ThemeProps<ModalStyle>,\n    Omit<UseModalProps, \"title\">,\n    Pick<\n      FocusLockProps,\n      | \"autoFocus\"\n      | \"finalFocusRef\"\n      | \"initialFocusRef\"\n      | \"lockFocusAcrossFrames\"\n      | \"restoreFocus\"\n    >,\n    PopupAnimationProps,\n    ShorthandModalContentProps {\n  /**\n   * Handle zoom or pinch gestures on iOS devices when scroll locking is enabled.\n   *\n   * @default false.\n   */\n  allowPinchZoom?: boolean\n  /**\n   * If `true`, scrolling will be disabled on the `body` when the modal opens.\n   *\n   * @default true\n   */\n  blockScrollOnMount?: boolean\n  /**\n   * The modal trigger to use.\n   */\n  trigger?: ReactNode\n  /**\n   * If `true`, display the modal close button.\n   *\n   * @default true\n   */\n  withCloseButton?: boolean\n  /**\n   * If `true`, display the modal overlay.\n   *\n   * @default true\n   */\n  withOverlay?: boolean\n  /**\n   * Props to be forwarded to the portal component.\n   */\n  portalProps?: Omit<PortalProps, \"children\">\n  /**\n   * Callback function to run side effects after the modal has closed.\n   */\n  onCloseComplete?: () => void\n}\n\nconst {\n  ComponentContext,\n  PropsContext: ModalPropsContext,\n  useComponentContext,\n  usePropsContext: useModalPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<ModalRootProps, ModalStyle, ComponentContext>(\n  \"modal\",\n  modalStyle,\n)\n\nexport { ModalPropsContext, useModalPropsContext }\n\n/**\n * `Modal` is a component that is displayed over the main content to focus the user's attention solely on the information.\n *\n * @see https://yamada-ui.com/docs/components/overlay/modal\n */\nexport const ModalRoot = withProvider<\"div\", ModalRootProps>(\n  ({\n    allowPinchZoom = false,\n    animationScheme = \"scale\",\n    autoFocus,\n    blockScrollOnMount = true,\n    body,\n    cancel,\n    children,\n    duration,\n    finalFocusRef,\n    footer,\n    header,\n    initialFocusRef,\n    lockFocusAcrossFrames = true,\n    middle,\n    restoreFocus,\n    success,\n    title,\n    trigger,\n    withCloseButton = true,\n    withOverlay = true,\n    portalProps,\n    onCancel,\n    onCloseComplete,\n    onMiddle,\n    onSuccess,\n    ...props\n  }) => {\n    const [omittedChildren, openTrigger, customOverlay] = useSplitChildren(\n      children,\n      ModalOpenTrigger,\n      ModalOverlay,\n    )\n    const hasChildren = isArray(omittedChildren) && !!omittedChildren.length\n    const { open, getRootProps, ...rest } = useModal(props)\n    const customOpenTrigger = trigger ? (\n      <ModalOpenTrigger>{trigger}</ModalOpenTrigger>\n    ) : null\n\n    const context = useMemo(\n      () => ({\n        animationScheme,\n        duration,\n        open,\n        withCloseButton,\n        ...rest,\n      }),\n      [animationScheme, duration, open, withCloseButton, rest],\n    )\n\n    return (\n      <ComponentContext value={context}>\n        {openTrigger ?? customOpenTrigger}\n\n        <AnimatePresence onExitComplete={onCloseComplete}>\n          {open ? (\n            <Portal {...portalProps}>\n              <FocusLock\n                autoFocus={autoFocus}\n                finalFocusRef={finalFocusRef}\n                initialFocusRef={initialFocusRef}\n                lockFocusAcrossFrames={lockFocusAcrossFrames}\n                restoreFocus={restoreFocus}\n              >\n                <RemoveScroll\n                  allowPinchZoom={allowPinchZoom}\n                  enabled={blockScrollOnMount}\n                  forwardProps\n                >\n                  <styled.div {...getRootProps()}>\n                    {customOverlay ?? (withOverlay ? <ModalOverlay /> : null)}\n\n                    {hasChildren ? (\n                      omittedChildren\n                    ) : (\n                      <ShorthandModalContent\n                        body={body}\n                        cancel={cancel}\n                        footer={footer}\n                        header={header}\n                        middle={middle}\n                        success={success}\n                        title={title}\n                        onCancel={onCancel}\n                        onMiddle={onMiddle}\n                        onSuccess={onSuccess}\n                      />\n                    )}\n                  </styled.div>\n                </RemoveScroll>\n              </FocusLock>\n            </Portal>\n          ) : null}\n        </AnimatePresence>\n      </ComponentContext>\n    )\n  },\n  \"root\",\n)()\n\nexport interface ModalOpenTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const ModalOpenTrigger = withContext<\"button\", ModalOpenTriggerProps>(\n  \"button\",\n  { name: \"OpenTrigger\", slot: [\"trigger\", \"open\"] },\n)(undefined, (props) => {\n  const { getOpenTriggerProps } = useComponentContext()\n\n  return { asChild: true, ...getOpenTriggerProps(props) }\n})\n\nexport interface ModalCloseTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const ModalCloseTrigger = withContext<\"button\", ModalCloseTriggerProps>(\n  \"button\",\n  { name: \"CloseTrigger\", slot: [\"trigger\", \"close\"] },\n)(undefined, (props) => {\n  const { getCloseTriggerProps } = useComponentContext()\n\n  return { asChild: true, ...getCloseTriggerProps(props) }\n})\n\nexport interface ModalCloseButtonProps extends CloseButtonProps {}\n\nexport const ModalCloseButton = withContext<\"button\", ModalCloseButtonProps>(\n  CloseButton,\n  \"closeButton\",\n)(undefined, (props) => {\n  const { getCloseButtonProps } = useComponentContext()\n\n  return { ...getCloseButtonProps(props) }\n})\n\nexport interface ModalOverlayProps extends HTMLMotionProps {}\n\nexport const ModalOverlay = withContext<\"div\", ModalOverlayProps>((props) => {\n  const { animationScheme, duration, getOverlayProps } = useComponentContext()\n\n  return (\n    <motion.div\n      custom={{ duration }}\n      {...(animationScheme !== \"none\"\n        ? {\n            animate: \"enter\",\n            exit: \"exit\",\n            initial: \"exit\",\n            variants: fadeVariants,\n          }\n        : {})}\n      {...cast<HTMLMotionProps>(getOverlayProps(cast<HTMLProps>(props)))}\n    />\n  )\n}, \"overlay\")()\n\nexport interface ModalContentProps\n  extends Omit<HTMLMotionProps<\"section\">, \"children\">,\n    PropsWithChildren {}\n\nexport const ModalContent = withContext<\"section\", ModalContentProps>(\n  ({ children, ...rest }) => {\n    const { animationScheme, duration, withCloseButton, getContentProps } =\n      useComponentContext()\n    const [omittedChildren, customCloseButton] = useSplitChildren(\n      children,\n      ModalCloseButton,\n    )\n\n    return (\n      <motion.section\n        {...getPopupAnimationProps(animationScheme, duration)}\n        {...cast<HTMLMotionPropsWithoutAs<\"section\">>(\n          getContentProps(cast<HTMLProps<\"section\">>(rest)),\n        )}\n      >\n        {customCloseButton ?? (withCloseButton ? <ModalCloseButton /> : null)}\n\n        {omittedChildren}\n      </motion.section>\n    )\n  },\n  \"content\",\n)()\n\ninterface ShorthandModalContentProps {\n  /**\n   * The modal body to use.\n   */\n  body?: ModalBodyProps | ReactNode\n  /**\n   * The modal cancel button to use.\n   */\n  cancel?: ButtonProps | ReactNode\n  /**\n   * The modal footer to use.\n   */\n  footer?: ModalFooterProps | ReactNode\n  /**\n   * The modal header to use.\n   */\n  header?: ModalHeaderProps | ReactNode\n  /**\n   * The modal middle button to use.\n   */\n  middle?: ButtonProps | ReactNode\n  /**\n   * The modal success button to use.\n   */\n  success?: ButtonProps | ReactNode\n  /**\n   * The modal title to use.\n   */\n  title?: ModalTitleProps | ReactNode\n  /**\n   * The callback invoked when cancel button clicked.\n   */\n  onCancel?: (onClose: () => void) => void\n  /**\n   * The callback invoked when middle button clicked.\n   */\n  onMiddle?: (onClose: () => void) => void\n  /**\n   * The callback invoked when success button clicked.\n   */\n  onSuccess?: (onClose: () => void) => void\n}\n\nexport const ShorthandModalContent: FC<ShorthandModalContentProps> = ({\n  body,\n  cancel,\n  footer,\n  header,\n  middle,\n  success,\n  title,\n  onCancel,\n  onMiddle,\n  onSuccess,\n}) => {\n  const { onClose } = useComponentContext()\n  const customHeader = wrapOrPassProps(ModalHeader, header)\n  const customTitle = wrapOrPassProps(ModalTitle, title)\n  const customBody = wrapOrPassProps(ModalBody, body)\n  const customFooter = wrapOrPassProps(ModalFooter, footer)\n  const customCancel = wrapOrPassProps(Button, cancel, {\n    variant: \"ghost\",\n    onClick: () => (onCancel ? onCancel(onClose) : onClose()),\n  })\n  const customMiddle = wrapOrPassProps(Button, middle, {\n    colorScheme: \"secondary\",\n    onClick: () => (onMiddle ? onMiddle(onClose) : onClose()),\n  })\n  const customSuccess = wrapOrPassProps(Button, success, {\n    colorScheme: \"primary\",\n    onClick: () => (onSuccess ? onSuccess(onClose) : onClose()),\n  })\n\n  return (\n    <ModalContent>\n      {customHeader ??\n        (customTitle ? <ModalHeader>{customTitle}</ModalHeader> : null)}\n      {customBody}\n      {customFooter ??\n        (customCancel || customMiddle || customSuccess ? (\n          <ModalFooter>\n            {customCancel}\n            {customMiddle}\n            {customSuccess}\n          </ModalFooter>\n        ) : null)}\n    </ModalContent>\n  )\n}\n\nexport interface ModalHeaderProps extends HTMLStyledProps<\"header\"> {}\n\nexport const ModalHeader = withContext<\"header\", ModalHeaderProps>(\n  \"header\",\n  \"header\",\n)(undefined, (props) => {\n  const { getHeaderProps } = useComponentContext()\n\n  return { ...getHeaderProps(props) }\n})\n\nexport interface ModalTitleProps extends HTMLStyledProps<\"h2\"> {}\n\nexport const ModalTitle = withContext<\"h2\", ModalTitleProps>(\"h2\", \"title\")(\n  undefined,\n  (props) => {\n    const { getTitleProps } = useComponentContext()\n\n    return { ...getTitleProps(props) }\n  },\n)\n\nexport interface ModalBodyProps extends HTMLStyledProps {}\n\nexport const ModalBody = withContext<\"div\", ModalBodyProps>(\"div\", \"body\")(\n  undefined,\n  (props) => {\n    const { getBodyProps } = useComponentContext()\n\n    return { ...getBodyProps(props) }\n  },\n)\n\nexport interface ModalFooterProps extends HTMLStyledProps<\"footer\"> {}\n\nexport const ModalFooter = withContext<\"footer\", ModalFooterProps>(\n  \"footer\",\n  \"footer\",\n)(undefined, (props) => {\n  const { getFooterProps } = useComponentContext()\n\n  return { ...getFooterProps(props) }\n})\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  ModalBody as Body,\n  ModalCloseButton as CloseButton,\n  ModalCloseTrigger as CloseTrigger,\n  ModalContent as Content,\n  ModalFooter as Footer,\n  ModalHeader as Header,\n  ModalOpenTrigger as OpenTrigger,\n  ModalOverlay as Overlay,\n  ModalPropsContext as PropsContext,\n  ModalRoot as Root,\n  ModalTitle as Title,\n  useModalPropsContext as usePropsContext,\n} from \"./modal\"\nexport type {\n  ModalBodyProps as BodyProps,\n  ModalCloseButtonProps as CloseButtonProps,\n  ModalCloseTriggerProps as CloseTriggerProps,\n  ModalContentProps as ContentProps,\n  ModalFooterProps as FooterProps,\n  ModalHeaderProps as HeaderProps,\n  ModalOpenTriggerProps as OpenTriggerProps,\n  ModalOverlayProps as OverlayProps,\n  ModalRootProps as RootProps,\n  ModalTitleProps as TitleProps,\n} from \"./modal\"\n"
    },
    {
      "name": "use-modal.ts",
      "content": "import type { KeyboardEvent } from \"react\"\nimport type { HTMLProps, PropGetter } from \"@yamada-ui/react\"\nimport type { UseDisclosureProps } from \"../../hooks/use-disclosure\"\nimport { useCallback, useId } from \"react\"\nimport { useDisclosure } from \"../../hooks/use-disclosure\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport { cx, handlerAll } from \"@yamada-ui/react\"\n\nexport interface UseModalProps\n  extends HTMLProps,\n    Omit<UseDisclosureProps, \"timing\"> {\n  /**\n   * If `true`, the modal will close when the `Esc` key is pressed.\n   *\n   * @default true\n   */\n  closeOnEsc?: boolean\n  /**\n   * If `true`, the modal will close when the overlay is clicked.\n   *\n   * @default true\n   */\n  closeOnOverlay?: boolean\n  /**\n   * Callback invoked when the escape key is pressed and focus is within modal.\n   */\n  onEsc?: () => void\n}\n\nexport const useModal = ({\n  closeOnEsc = true,\n  closeOnOverlay = true,\n  defaultOpen,\n  open: openProp,\n  onClose: onCloseProp,\n  onEsc,\n  onOpen: onOpenProp,\n  ...rest\n}: UseModalProps = {}) => {\n  const { open, onClose, onOpen } = useDisclosure({\n    defaultOpen,\n    open: openProp,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n    ...rest,\n  })\n  const contentId = useId()\n  const titleId = useId()\n  const bodyId = useId()\n  const { t } = useI18n(\"modal\")\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent) => {\n      if (ev.key !== \"Escape\") return\n\n      ev.stopPropagation()\n\n      if (closeOnEsc) onClose()\n\n      onEsc?.()\n    },\n    [closeOnEsc, onClose, onEsc],\n  )\n\n  const getRootProps: PropGetter = useCallback(\n    (props) => ({\n      ...rest,\n      ...props,\n    }),\n    [rest],\n  )\n\n  const getOverlayProps: PropGetter = useCallback(\n    (props = {}) => ({\n      \"aria-hidden\": \"true\",\n      ...props,\n      onClick: handlerAll(props.onClick, (ev) => {\n        ev.stopPropagation()\n\n        if (closeOnOverlay) onClose()\n      }),\n    }),\n    [closeOnOverlay, onClose],\n  )\n\n  const getOpenTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      \"aria-controls\": open ? contentId : undefined,\n      \"aria-expanded\": open,\n      \"aria-haspopup\": \"dialog\",\n      \"aria-label\": t(\"Open modal\"),\n      ...props,\n      onClick: handlerAll(props.onClick, onOpen),\n    }),\n    [contentId, onOpen, open, t],\n  )\n\n  const getCloseTriggerProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      \"aria-label\": t(\"Close modal\"),\n      ...props,\n      onClick: handlerAll(props.onClick, onClose),\n    }),\n    [onClose, t],\n  )\n\n  const getCloseButtonProps: PropGetter<\"button\"> = useCallback(\n    (props = {}) => ({\n      \"aria-label\": t(\"Close modal\"),\n      ...props,\n      onClick: handlerAll(props.onClick, onClose),\n    }),\n    [onClose, t],\n  )\n\n  const getContentProps: PropGetter<\"section\"> = useCallback(\n    ({\n      \"aria-describedby\": ariaDescribedby,\n      \"aria-labelledby\": ariaLabelledby,\n      ...props\n    } = {}) => ({\n      id: contentId,\n      \"aria-describedby\": cx(ariaDescribedby, bodyId),\n      \"aria-labelledby\": cx(ariaLabelledby, titleId),\n      \"aria-modal\": \"true\",\n      role: \"dialog\",\n      ...props,\n      onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n    }),\n    [bodyId, contentId, onKeyDown, titleId],\n  )\n\n  const getHeaderProps: PropGetter<\"header\"> = useCallback(\n    (props) => ({\n      ...props,\n    }),\n    [],\n  )\n\n  const getTitleProps: PropGetter<\"h2\"> = useCallback(\n    (props) => ({\n      id: titleId,\n      ...props,\n    }),\n    [titleId],\n  )\n\n  const getBodyProps: PropGetter = useCallback(\n    (props) => ({\n      id: bodyId,\n      ...props,\n    }),\n    [bodyId],\n  )\n\n  const getFooterProps: PropGetter<\"footer\"> = useCallback(\n    (props) => ({\n      ...props,\n    }),\n    [],\n  )\n\n  return {\n    open,\n    getBodyProps,\n    getCloseButtonProps,\n    getCloseTriggerProps,\n    getContentProps,\n    getFooterProps,\n    getHeaderProps,\n    getOpenTriggerProps,\n    getOverlayProps,\n    getRootProps,\n    getTitleProps,\n    onClose,\n    onOpen,\n  }\n}\n\nexport type UseModalReturn = ReturnType<typeof useModal>\n"
    }
  ]
}
