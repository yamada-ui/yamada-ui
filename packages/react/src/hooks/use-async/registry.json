{
  "type": "hooks",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": ["use-mounted"],
    "providers": []
  },
  "sources": [
    {
      "name": "index.ts",
      "content": "\"use client\"\n\nimport type { DependencyList } from \"react\"\nimport { useCallback, useEffect, useRef, useState } from \"react\"\nimport { useMounted } from \"../use-mounted\"\n\nexport type FunctionReturningPromise = (...args: any[]) => Promise<any>\n\n/**\n * `useAsync` is a custom hook that executes an asynchronous function and tracks its state.\n *\n * @see https://yamada-ui.com/hooks/use-async\n */\nexport function useAsync<Y extends FunctionReturningPromise>(\n  func: Y,\n  deps: DependencyList = [],\n) {\n  const [state, callback] = useAsyncFunc(func, deps, { loading: true })\n\n  useEffect(() => {\n    callback()\n  }, [callback])\n\n  return state\n}\n\nexport type AsyncState<Y> =\n  | {\n      error: Error\n      loading: false\n      value?: undefined\n    }\n  | {\n      loading: boolean\n      error?: undefined\n      value?: undefined\n    }\n  | {\n      loading: false\n      value: Y\n      error?: undefined\n    }\n  | {\n      loading: true\n      error?: Error | undefined\n      value?: Y\n    }\n\nexport type PromiseType<P extends Promise<any>> =\n  P extends Promise<infer Y> ? Y : never\n\ntype StateFromFunctionReturningPromise<Y extends FunctionReturningPromise> =\n  AsyncState<PromiseType<ReturnType<Y>>>\n\nexport type AsyncFnReturn<\n  Y extends FunctionReturningPromise = FunctionReturningPromise,\n> = [StateFromFunctionReturningPromise<Y>, Y]\n\nexport function useAsyncFunc<Y extends FunctionReturningPromise>(\n  func: Y,\n  deps: DependencyList = [],\n  initialState: StateFromFunctionReturningPromise<Y> = { loading: false },\n): AsyncFnReturn<Y> {\n  const lastCallId = useRef(0)\n  const isMounted = useMounted()\n  const [state, setState] =\n    useState<StateFromFunctionReturningPromise<Y>>(initialState)\n\n  const callback = useCallback(\n    (...args: Parameters<Y>): ReturnType<Y> => {\n      const callId = ++lastCallId.current\n\n      if (!state.loading)\n        setState((prevState) => ({ ...prevState, loading: true }))\n\n      return func(...args).then(\n        (value) => {\n          if (isMounted() && callId === lastCallId.current)\n            setState({ loading: false, value })\n\n          return value\n        },\n        (error) => {\n          if (isMounted() && callId === lastCallId.current)\n            setState({ error, loading: false })\n\n          return error\n        },\n      ) as ReturnType<Y>\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    deps,\n  )\n\n  return [state, callback as unknown as Y]\n}\n\nexport type AsyncStateRetry<Y> = AsyncState<Y> & {\n  retry(): void\n}\n\nexport function useAsyncRetry<Y>(\n  func: () => Promise<Y>,\n  deps: DependencyList = [],\n) {\n  const [attempt, setAttempt] = useState<number>(0)\n  const state = useAsync(func, [...deps, attempt])\n\n  const stateLoading = state.loading\n\n  const retry = useCallback(() => {\n    if (stateLoading) return\n\n    setAttempt((currentAttempt) => currentAttempt + 1)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [...deps, stateLoading])\n\n  return { ...state, retry }\n}\n"
    }
  ]
}
