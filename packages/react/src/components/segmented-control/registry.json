{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["field"],
    "externals": [],
    "hooks": ["use-value", "use-controllable-state", "use-descendants"],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./segmented-control.style\"\nexport * as SegmentedControl from \"./namespace\"\nexport {\n  SegmentedControlItem,\n  SegmentedControlPropsContext,\n  SegmentedControlRoot,\n  useSegmentedControlPropsContext,\n} from \"./segmented-control\"\nexport type {\n  SegmentedControlItemProps,\n  SegmentedControlRootProps,\n} from \"./segmented-control\"\nexport * from \"./use-segmented-control\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  SegmentedControlItem as Item,\n  SegmentedControlPropsContext as PropsContext,\n  SegmentedControlRoot as Root,\n  useSegmentedControlPropsContext as usePropsContext,\n} from \"./segmented-control\"\nexport type {\n  SegmentedControlItemProps as ItemProps,\n  SegmentedControlRootProps as RootProps,\n} from \"./segmented-control\"\nexport {\n  SegmentedControlContext as Context,\n  SegmentedControlDescendantsContext as DescendantsContext,\n  useSegmentedControlContext as useContext,\n  useSegmentedControlDescendant as useDescendant,\n  useSegmentedControlDescendants as useDescendants,\n} from \"./use-segmented-control\"\n"
    },
    {
      "name": "segmented-control.style.ts",
      "content": "import { defineComponentSlotStyle, focusRingStyle } from \"@yamada-ui/react\"\n\nexport const segmentedControlStyle = defineComponentSlotStyle({\n  base: {\n    item: {\n      \"&:has(input:focus-visible)\": {\n        ...focusRingStyle.outline,\n      },\n      alignItems: \"center\",\n      color: \"fg\",\n      cursor: \"pointer\",\n      display: \"inline-flex\",\n      flex: \"1 1 0%\",\n      fontWeight: \"medium\",\n      justifyContent: \"center\",\n      position: \"relative\",\n      rounded: \"md\",\n      transitionDuration: \"moderate\",\n      transitionProperty: \"color, opacity\",\n      whiteSpace: \"nowrap\",\n      _checked: {\n        anchorName: \"--checked\",\n      },\n      _readOnly: { layerStyle: \"readOnly\", pointerEvents: \"none\" },\n      _disabled: {\n        layerStyle: \"disabled\",\n        \"&[data-root-disabled]\": { opacity: 1 },\n      },\n    },\n    root: {\n      alignItems: \"center\",\n      anchorScope: \"--checked\",\n      bg: [\"bg.ghost\", \"bg.subtle\"],\n      display: \"inline-flex\",\n      p: \"1\",\n      rounded: \"lg\",\n      _before: {\n        bg: \"bg.panel\",\n        boxShadow: \"xs\",\n        h: \"anchor-size(--checked height)\",\n        left: \"anchor(--checked left)\",\n        pointerEvents: \"none\",\n        position: \"absolute\",\n        rounded: \"md\",\n        top: \"anchor(--checked top)\",\n        transitionDuration: \"moderate\",\n        transitionProperty: \"top, left, width\",\n        w: \"anchor-size(--checked width)\",\n      },\n      _dark: {\n        _before: {\n          bg: \"bg.muted\",\n        },\n      },\n      _readOnly: { layerStyle: \"readOnly\" },\n      _disabled: { layerStyle: \"disabled\" },\n    },\n  },\n\n  props: {\n    /**\n     * If `true`, the segmented control will be full rounded.\n     *\n     * @default false\n     */\n    fullRounded: {\n      true: {\n        item: {\n          rounded: \"full\",\n        },\n        root: {\n          rounded: \"full\",\n          _before: {\n            rounded: \"full\",\n          },\n        },\n      },\n    },\n    /**\n     * The orientation of the segmented control.\n     *\n     * @default 'horizontal'\n     */\n    orientation: {\n      horizontal: {\n        item: {\n          h: \"full\",\n        },\n        root: {\n          flexDirection: \"row\",\n        },\n      },\n      vertical: {\n        item: {\n          w: \"full\",\n        },\n        root: {\n          flexDirection: \"column\",\n        },\n      },\n    },\n  },\n\n  sizes: {\n    sm: {\n      item: { fontSize: \"sm\", px: \"3\", _vertical: { minH: \"7\" } },\n      root: {\n        _horizontal: { h: \"9\", minW: \"64\" },\n      },\n    },\n    md: {\n      item: { fontSize: \"md\", px: \"3\", _vertical: { minH: \"8\" } },\n      root: {\n        _horizontal: { h: \"10\", minW: \"80\" },\n        _vertical: {},\n      },\n    },\n    lg: {\n      item: { fontSize: \"lg\", px: \"4\", _vertical: { minH: \"9\" } },\n      root: {\n        _horizontal: { h: \"11\", minW: \"96\" },\n        _vertical: {},\n      },\n    },\n    xl: {\n      item: { fontSize: \"xl\", px: \"5\", _vertical: { minH: \"10\" } },\n      root: {\n        _horizontal: { h: \"12\", minW: \"96\" },\n        _vertical: {},\n      },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    orientation: \"horizontal\",\n  },\n})\n\nexport type SegmentedControlStyle = typeof segmentedControlStyle\n"
    },
    {
      "name": "segmented-control.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement, ReactNode } from \"react\"\nimport type {\n  GenericsComponent,\n  HTMLStyledProps,\n  ThemeProps,\n} from \"@yamada-ui/react\"\nimport type { SegmentedControlStyle } from \"./segmented-control.style\"\nimport type {\n  UseSegmentedControlItemProps,\n  UseSegmentedControlProps,\n} from \"./use-segmented-control\"\nimport { useMemo } from \"react\"\nimport { createSlotComponent, styled } from \"@yamada-ui/react\"\nimport { useValue } from \"../../hooks/use-value\"\nimport { segmentedControlStyle } from \"./segmented-control.style\"\nimport {\n  SegmentedControlContext,\n  SegmentedControlDescendantsContext,\n  useSegmentedControl,\n  useSegmentedControlItem,\n} from \"./use-segmented-control\"\n\ninterface SegmentedControlItem extends SegmentedControlItemProps {\n  label?: ReactNode\n}\n\nexport interface SegmentedControlRootProps<Y extends string = string>\n  extends Omit<HTMLStyledProps, \"defaultValue\" | \"onChange\">,\n    ThemeProps<SegmentedControlStyle>,\n    Omit<UseSegmentedControlProps<Y>, \"orientation\"> {\n  /**\n   * If provided, generate segmented control buttons but based on items.\n   *\n   * @default '[]'\n   */\n  items?: SegmentedControlItem[]\n}\n\nconst {\n  PropsContext: SegmentedControlPropsContext,\n  usePropsContext: useSegmentedControlPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<SegmentedControlRootProps, SegmentedControlStyle>(\n  \"segmented-control\",\n  segmentedControlStyle,\n)\n\nexport { SegmentedControlPropsContext, useSegmentedControlPropsContext }\n\n/**\n * `SegmentedControl` is a component used for allowing users to select one option from multiple choices.\n *\n * @see https://yamada-ui.com/components/segmented-control\n */\nexport const SegmentedControlRoot = withProvider(\n  ({ children, items = [], orientation: orientationProp, ...rest }) => {\n    const computedOrientation = useValue(orientationProp)\n    const {\n      id,\n      name,\n      descendants,\n      disabled,\n      orientation,\n      readOnly,\n      setValue,\n      value,\n      getRootProps,\n    } = useSegmentedControl({ orientation: computedOrientation, ...rest })\n    const cloneChildren = useMemo(() => {\n      if (children) {\n        return children\n      } else {\n        return items.map(({ label, ...rest }, index) => (\n          <SegmentedControlItem key={index} {...rest}>\n            {label}\n          </SegmentedControlItem>\n        ))\n      }\n    }, [children, items])\n    const context = useMemo(\n      () => ({ id, name, disabled, orientation, readOnly, setValue, value }),\n      [id, name, disabled, readOnly, orientation, setValue, value],\n    )\n\n    return (\n      <SegmentedControlContext value={context}>\n        <SegmentedControlDescendantsContext value={descendants}>\n          <styled.div {...getRootProps()}>{cloneChildren}</styled.div>\n        </SegmentedControlDescendantsContext>\n      </SegmentedControlContext>\n    )\n  },\n  \"root\",\n  { transferProps: [\"orientation\"] },\n)() as GenericsComponent<{\n  <Y extends string = string>(props: SegmentedControlRootProps<Y>): ReactElement\n}>\n\nexport interface SegmentedControlItemProps<Y extends string = string>\n  extends HTMLStyledProps<\"label\">,\n    UseSegmentedControlItemProps<Y> {}\n\nexport const SegmentedControlItem = withContext<\n  \"label\",\n  SegmentedControlItemProps\n>(({ children, ...rest }) => {\n  const { getInputProps, getLabelProps } = useSegmentedControlItem(rest)\n\n  return (\n    <styled.label {...getLabelProps()}>\n      <styled.input {...getInputProps()} />\n\n      <styled.span>{children}</styled.span>\n    </styled.label>\n  )\n}, \"item\")() as GenericsComponent<{\n  <Y extends string = string>(props: SegmentedControlItemProps<Y>): ReactElement\n}>\n"
    },
    {
      "name": "use-segmented-control.ts",
      "content": "\"use client\"\n\nimport type { ChangeEvent } from \"react\"\nimport type { HTMLProps, Orientation, PropGetter } from \"@yamada-ui/react\"\nimport type { FieldProps } from \"../field\"\nimport { useCallback, useId } from \"react\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { createDescendants } from \"../../hooks/use-descendants\"\nimport {\n  ariaAttr,\n  createContext,\n  dataAttr,\n  handlerAll,\n  mergeRefs,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\n\ninterface SegmentedControlContext\n  extends Omit<UseSegmentedControlReturn, \"descendants\" | \"getRootProps\"> {}\n\nconst [SegmentedControlContext, useSegmentedControlContext] =\n  createContext<SegmentedControlContext>({\n    name: \"SegmentedControlContext\",\n  })\n\nexport { SegmentedControlContext, useSegmentedControlContext }\n\nconst {\n  DescendantsContext: SegmentedControlDescendantsContext,\n  useDescendant: useSegmentedControlDescendant,\n  useDescendants: useSegmentedControlDescendants,\n} = createDescendants<HTMLInputElement>()\n\nexport {\n  SegmentedControlDescendantsContext,\n  useSegmentedControlDescendant,\n  useSegmentedControlDescendants,\n}\n\nexport interface UseSegmentedControlProps<Y extends string = string>\n  extends Omit<HTMLProps, \"onChange\"> {\n  /**\n   * The HTML `name` attribute used for forms.\n   */\n  name?: string\n  /**\n   * The initial value of the segmented control.\n   */\n  defaultValue?: Y\n  /**\n   * If `true`, the segmented control will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * The orientation of the segmented control.\n   *\n   * @default 'horizontal'\n   */\n  orientation?: Orientation\n  /**\n   * If `true`, the segmented control will be readonly.\n   *\n   * @default false\n   */\n  readOnly?: boolean\n  /**\n   * The value of the segmented control.\n   */\n  value?: Y\n  /**\n   * The callback fired when any children radio is checked or unchecked.\n   */\n  onChange?: (value: Y) => void\n}\n\nexport const useSegmentedControl = <Y extends string = string>({\n  id,\n  name,\n  defaultValue,\n  disabled,\n  orientation = \"horizontal\",\n  readOnly,\n  value: valueProp,\n  onChange: onChangeProp,\n  ...rest\n}: UseSegmentedControlProps<Y> = {}) => {\n  const uuid = useId()\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const descendants = useSegmentedControlDescendants()\n\n  id ??= uuid\n  name ??= uuid\n\n  const getRootProps: PropGetter = useCallback(\n    (props) => ({\n      id,\n      \"aria-disabled\": ariaAttr(disabled),\n      \"aria-orientation\": orientation,\n      \"data-disabled\": dataAttr(disabled),\n      \"data-orientation\": orientation,\n      \"data-readonly\": dataAttr(readOnly),\n      role: \"radiogroup\",\n      ...rest,\n      ...props,\n    }),\n    [disabled, id, orientation, readOnly, rest],\n  )\n\n  return {\n    id,\n    name,\n    descendants,\n    disabled,\n    orientation,\n    readOnly,\n    setValue,\n    value,\n    getRootProps,\n  }\n}\n\nexport type UseSegmentedControlReturn = ReturnType<typeof useSegmentedControl>\n\nexport interface UseSegmentedControlItemProps<Y extends string = string>\n  extends HTMLProps<\"label\">,\n    Pick<FieldProps, \"disabled\" | \"readOnly\"> {\n  /**\n   * The value of the segmented control item.\n   */\n  value: Y\n  /**\n   * Props for the input element.\n   */\n  inputProps?: HTMLProps<\"input\">\n}\n\nexport const useSegmentedControlItem = <Y extends string = string>({\n  disabled,\n  readOnly,\n  value,\n  inputProps,\n  ...rest\n}: UseSegmentedControlItemProps<Y>) => {\n  const {\n    name,\n    disabled: rootDisabled,\n    orientation,\n    readOnly: rootReadOnly,\n    setValue,\n    value: selectedValue,\n  } = useSegmentedControlContext()\n  const { register } = useSegmentedControlDescendant({\n    disabled: disabled || readOnly,\n  })\n  const checked = value === selectedValue\n  const trulyDisabled = disabled ?? rootDisabled\n  const trulyReadOnly = readOnly ?? rootReadOnly\n  const interactive = !(trulyReadOnly || trulyDisabled)\n\n  const onChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      setValue(ev.target.value)\n    },\n    [setValue],\n  )\n\n  const getLabelProps: PropGetter<\"label\"> = useCallback(\n    (props) => ({\n      \"aria-disabled\": ariaAttr(trulyDisabled),\n      \"aria-readonly\": ariaAttr(trulyReadOnly),\n      \"data-checked\": dataAttr(checked),\n      \"data-disabled\": dataAttr(trulyDisabled),\n      \"data-orientation\": orientation,\n      \"data-readonly\": dataAttr(trulyReadOnly),\n      \"data-root-disabled\": dataAttr(rootDisabled),\n      \"data-root-readonly\": dataAttr(rootReadOnly),\n      ...props,\n      ...rest,\n    }),\n    [\n      orientation,\n      trulyDisabled,\n      trulyReadOnly,\n      checked,\n      rootDisabled,\n      rootReadOnly,\n      rest,\n    ],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      type: \"radio\",\n      name,\n      style: visuallyHiddenAttributes.style,\n      \"aria-disabled\": ariaAttr(trulyDisabled),\n      \"aria-readonly\": ariaAttr(trulyReadOnly),\n      \"data-checked\": dataAttr(checked),\n      \"data-disabled\": dataAttr(trulyDisabled),\n      \"data-orientation\": orientation,\n      \"data-readonly\": dataAttr(trulyReadOnly),\n      checked,\n      disabled: trulyDisabled || trulyReadOnly,\n      readOnly: trulyReadOnly,\n      tabIndex: interactive ? undefined : -1,\n      value,\n      ...inputProps,\n      ...props,\n      ref: mergeRefs(register, ref),\n      onChange: handlerAll(props.onChange, inputProps?.onChange, onChange),\n    }),\n    [\n      orientation,\n      name,\n      trulyDisabled,\n      trulyReadOnly,\n      checked,\n      interactive,\n      value,\n      inputProps,\n      register,\n      onChange,\n    ],\n  )\n\n  return {\n    getInputProps,\n    getLabelProps,\n  }\n}\n\nexport type UseSegmentedControlItemReturn = ReturnType<\n  typeof useSegmentedControlItem\n>\n"
    }
  ]
}
