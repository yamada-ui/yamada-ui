{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["format-number"],
    "externals": [],
    "hooks": [],
    "providers": ["i18n-provider"]
  },
  "section": "components",
  "sources": [
    {
      "name": "format-byte.style.ts",
      "content": "import { defineComponentStyle } from \"@yamada-ui/react\"\n\nexport const formatByteStyle = defineComponentStyle({})\n\nexport type FormatByteStyle = typeof formatByteStyle\n"
    },
    {
      "name": "format-byte.tsx",
      "content": "\"use client\"\n\nimport type { HTMLStyledProps, ThemeProps } from \"@yamada-ui/react\"\nimport type { FormatByteStyle } from \"./format-byte.style\"\nimport { createComponent, styled } from \"@yamada-ui/react\"\nimport { formatByteStyle } from \"./format-byte.style\"\nimport { useFormatByte } from \"./use-format-byte\"\n\nexport interface FormatByteProps\n  extends HTMLStyledProps,\n    ThemeProps<FormatByteStyle> {\n  /**\n   * The byte size to format\n   */\n  value: number\n  /**\n   * The locale string to use for formatting.\n   *\n   * @default 'en-US'\n   */\n  locale?: string\n  /**\n   * The unit granularity to display\n   */\n  unit?: \"bit\" | \"byte\"\n  /**\n   * The unit display\n   */\n  unitDisplay?: \"long\" | \"narrow\" | \"short\"\n}\n\nconst {\n  PropsContext: FormatBytePropsContext,\n  usePropsContext: useFormatBytePropsContext,\n  withContext,\n} = createComponent<FormatByteProps, FormatByteStyle>(\n  \"format-byte\",\n  formatByteStyle,\n)\n\nexport { FormatBytePropsContext, useFormatBytePropsContext }\n\n/**\n * `FormatByte` is used to format bytes to a human-readable format.\n *\n * @see https://yamada-ui.com/components/format-byte\n */\nexport const FormatByte = withContext(\n  ({ locale, unit, unitDisplay, value, ...rest }) => {\n    const text = useFormatByte(value, { locale, unit, unitDisplay })\n\n    return <styled.span {...rest}>{text}</styled.span>\n  },\n)()\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./format-byte.style\"\nexport {\n  FormatByte,\n  FormatBytePropsContext,\n  useFormatBytePropsContext,\n} from \"./format-byte\"\nexport type { FormatByteProps } from \"./format-byte\"\n"
    },
    {
      "name": "use-format-byte.tsx",
      "content": "\"use client\"\n\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport { useFormatNumber } from \"../format-number\"\n\nconst bitPrefixes = [\"\", \"kilo\", \"mega\", \"giga\", \"tera\"]\nconst bytePrefixes = [\"\", \"kilo\", \"mega\", \"giga\", \"tera\", \"peta\"]\n\nexport interface FormatBytesOptions {\n  locale?: string\n  unit?: \"bit\" | \"byte\"\n  unitDisplay?: \"long\" | \"narrow\" | \"short\"\n}\n\n/**\n * `useFormatByte` is a custom hook that returns the formatted byte.\n *\n * @see https://yamada-ui.com/hooks/use-format-byte\n */\nexport const useFormatByte = (\n  bytes: number,\n  { locale, unit = \"byte\", unitDisplay = \"short\" }: FormatBytesOptions = {},\n) => {\n  const { locale: defaultLocale } = useI18n()\n\n  locale ??= defaultLocale\n\n  const sanitizedBytes = Number.isNaN(bytes) ? 0 : bytes\n  const prefix = unit === \"bit\" ? bitPrefixes : bytePrefixes\n  const index = Math.max(\n    0,\n    Math.min(Math.floor(Math.log10(sanitizedBytes) / 3), prefix.length - 1),\n  )\n  const value =\n    sanitizedBytes === 0\n      ? 0\n      : Number.parseFloat((sanitizedBytes / 10 ** (3 * index)).toPrecision(3))\n\n  return useFormatNumber(value, {\n    style: \"unit\",\n    locale,\n    unit: prefix[index] + unit,\n    unitDisplay,\n  })\n}\n\nexport type UseFormatByteReturn = ReturnType<typeof useFormatByte>\n"
    }
  ]
}
