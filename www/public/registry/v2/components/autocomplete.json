{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["select", "input", "group", "icon", "popover", "field"],
    "externals": [],
    "hooks": ["use-combobox", "use-controllable-state"],
    "providers": ["i18n-provider"]
  },
  "dependents": { "components": ["date-picker"], "hooks": [], "providers": [] },
  "section": "components",
  "sources": [
    {
      "name": "autocomplete.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\nimport { selectStyle } from \"../select\"\n\nexport const autocompleteStyle = defineComponentSlotStyle({\n  base: {\n    ...selectStyle.base,\n    empty: selectStyle.base?.option,\n    field: {\n      ...selectStyle.base?.field,\n      cursor: \"text\",\n      flexWrap: \"wrap\",\n      gapY: \"{gap}\",\n      py: \"{gap}\",\n    },\n    input: {\n      \"&[data-max]\": { caretColor: \"transparent\" },\n      flex: \"1\",\n      focusVisibleRing: \"none\",\n      _disabled: { cursor: \"not-allowed\" },\n    },\n  },\n\n  variants: {\n    filled: {\n      ...selectStyle.variants?.filled,\n      field: {\n        ...selectStyle.variants?.filled.field,\n        \"&:focus:not([data-disabled])\":\n          selectStyle.variants?.filled.field._expanded,\n        \":has(input:focus)\": selectStyle.variants?.filled.field._expanded,\n      },\n    },\n    flushed: {\n      ...selectStyle.variants?.flushed,\n      field: {\n        ...selectStyle.variants?.flushed.field,\n        \"&:focus:not([data-disabled])\":\n          selectStyle.variants?.flushed.field._expanded,\n        \":has(input:focus)\": selectStyle.variants?.flushed.field._expanded,\n      },\n    },\n    outline: {\n      ...selectStyle.variants?.outline,\n      field: {\n        ...selectStyle.variants?.outline.field,\n        \"&:focus:not([data-disabled])\":\n          selectStyle.variants?.outline.field._expanded,\n        \":has(input:focus)\": selectStyle.variants?.outline.field._expanded,\n      },\n    },\n    plain: {\n      ...selectStyle.variants?.plain,\n      field: {\n        ...selectStyle.variants?.plain.field,\n        \"&:focus:not([data-disabled])\":\n          selectStyle.variants?.plain.field._expanded,\n        \":has(input:focus)\": selectStyle.variants?.plain.field._expanded,\n      },\n    },\n  },\n\n  sizes: {\n    xs: { ...selectStyle.sizes?.xs, empty: selectStyle.sizes?.xs.option },\n    sm: { ...selectStyle.sizes?.sm, empty: selectStyle.sizes?.sm.option },\n    md: { ...selectStyle.sizes?.md, empty: selectStyle.sizes?.md.option },\n    lg: { ...selectStyle.sizes?.lg, empty: selectStyle.sizes?.lg.option },\n    xl: { ...selectStyle.sizes?.xl, empty: selectStyle.sizes?.xl.option },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"outline\",\n  },\n})\n\nexport type AutocompleteStyle = typeof autocompleteStyle\n"
    },
    {
      "name": "autocomplete.tsx",
      "content": "\"use client\"\n\nimport type { ReactElement, ReactNode } from \"react\"\nimport type {\n  GenericsComponent,\n  HTMLProps,\n  HTMLStyledProps,\n  ThemeProps,\n  WithoutThemeProps,\n} from \"@yamada-ui/react\"\nimport type {\n  ComboboxItem,\n  UseComboboxGroupProps,\n} from \"../../hooks/use-combobox\"\nimport type { UseInputBorderProps } from \"../input\"\nimport type { AutocompleteStyle } from \"./autocomplete.style\"\nimport type {\n  UseAutocompleteOptionProps,\n  UseAutocompleteProps,\n  UseAutocompleteReturn,\n} from \"./use-autocomplete\"\nimport { useMemo } from \"react\"\nimport { createSlotComponent, styled, cast, isArray } from \"@yamada-ui/react\"\nimport {\n  ComboboxContext,\n  ComboboxDescendantsContext,\n  ComboboxGroupContext,\n  createComboboxChildren,\n  createComboboxItem,\n  useComboboxGroup,\n  useComboboxGroupContext,\n} from \"../../hooks/use-combobox\"\nimport { useGroupItemProps } from \"../group\"\nimport { CheckIcon, ChevronDownIcon, MinusIcon, XIcon } from \"../icon\"\nimport { InputGroup, useInputBorder, useInputPropsContext } from \"../input\"\nimport { Popover, usePopoverProps } from \"../popover\"\nimport { autocompleteStyle } from \"./autocomplete.style\"\nimport {\n  AutocompleteContext,\n  useAutocomplete,\n  useAutocompleteOption,\n} from \"./use-autocomplete\"\n\ninterface ComponentContext\n  extends Pick<UseAutocompleteReturn, \"getInputProps\" | \"getSeparatorProps\">,\n    Pick<\n      AutocompleteRootProps,\n      \"emptyIcon\" | \"emptyProps\" | \"groupProps\" | \"inputProps\" | \"optionProps\"\n    > {}\n\nexport interface AutocompleteRootProps<Multiple extends boolean = false>\n  extends Omit<\n      HTMLStyledProps,\n      \"defaultValue\" | \"filter\" | \"offset\" | \"onChange\" | \"ref\" | \"value\"\n    >,\n    UseAutocompleteProps<Multiple>,\n    Omit<\n      WithoutThemeProps<Popover.RootProps, AutocompleteStyle>,\n      | \"autoFocus\"\n      | \"children\"\n      | \"initialFocusRef\"\n      | \"modal\"\n      | \"transform\"\n      | \"updateRef\"\n      | \"withCloseButton\"\n    >,\n    ThemeProps<AutocompleteStyle>,\n    UseInputBorderProps {\n  /**\n   * If `true`, display the clear icon.\n   *\n   * @default true\n   */\n  clearable?: boolean\n  /**\n   * The icon to be used in the clear button.\n   */\n  clearIcon?: ReactNode\n  /**\n   * The icon to be used in the empty element.\n   */\n  emptyIcon?: ReactNode\n  /**\n   * The icon to be used in the autocomplete.\n   */\n  icon?: ReactNode\n  /**\n   * Props for content element.\n   */\n  contentProps?: AutocompleteContentProps\n  /**\n   * The props for the end element.\n   */\n  elementProps?: InputGroup.ElementProps\n  /**\n   * Props for empty element.\n   */\n  emptyProps?: AutocompleteEmptyProps\n  /**\n   * Props for group element.\n   */\n  groupProps?: Omit<AutocompleteGroupProps, \"children\" | \"label\">\n  /**\n   * Props for icon element.\n   */\n  iconProps?: AutocompleteIconProps\n  /**\n   * The props for the input element.\n   */\n  inputProps?: HTMLStyledProps<\"input\">\n  /**\n   * Props for option element.\n   */\n  optionProps?: Omit<AutocompleteOptionProps, \"children\" | \"value\">\n  /**\n   * Props for root element.\n   */\n  rootProps?: InputGroup.RootProps\n}\n\nconst {\n  ComponentContext,\n  PropsContext: AutocompletePropsContext,\n  useComponentContext,\n  usePropsContext: useAutocompletePropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<\n  AutocompleteRootProps,\n  AutocompleteStyle,\n  ComponentContext\n>(\"autocomplete\", autocompleteStyle)\n\nexport { AutocompletePropsContext, useAutocompletePropsContext }\n\n/**\n * `Autocomplete` is a component used to display suggestions in response to user text input.\n *\n * @see https://yamada-ui.com/docs/components/autocomplete\n */\nexport const AutocompleteRoot = withProvider(\n  <Multiple extends boolean = false>(\n    props: AutocompleteRootProps<Multiple>,\n  ) => {\n    const [groupItemProps, mergedProps] = useGroupItemProps(props)\n    const [\n      popoverProps,\n      {\n        className,\n        css,\n        colorScheme,\n        children,\n        clearable = true,\n        clearIcon = <XIcon />,\n        emptyIcon,\n        errorBorderColor,\n        focusBorderColor,\n        icon,\n        items: itemsProp,\n        contentProps,\n        elementProps,\n        emptyProps,\n        groupProps,\n        iconProps,\n        inputProps,\n        optionProps,\n        rootProps,\n        ...rest\n      },\n    ] = usePopoverProps(mergedProps, [\n      \"disabled\",\n      \"open\",\n      \"defaultOpen\",\n      \"onOpen\",\n      \"onClose\",\n      \"openOnClick\",\n    ])\n    const items = useMemo<ComboboxItem[]>(() => {\n      if (itemsProp) return itemsProp\n\n      return createComboboxItem(children, {\n        Group: AutocompleteGroup,\n        Label: AutocompleteLabel,\n        Option: AutocompleteOption,\n      })\n    }, [itemsProp, children])\n    const {\n      children: fieldChildren,\n      descendants,\n      interactive,\n      items: computedItems,\n      max,\n      open,\n      value,\n      getClearIconProps,\n      getContentProps,\n      getFieldProps,\n      getIconProps,\n      getInputProps,\n      getRootProps,\n      getSeparatorProps,\n      onActiveDescendant,\n      onClose,\n      onOpen,\n      onSelect,\n    } = useAutocomplete({ items, ...rest })\n    const mergedPopoverProps = useMemo<Popover.RootProps>(\n      () => ({\n        animationScheme: \"block-start\",\n        autoFocus: false,\n        matchWidth: true,\n        ...popoverProps,\n        disabled: !interactive,\n        open,\n        onClose,\n        onOpen,\n      }),\n      [interactive, onClose, onOpen, open, popoverProps],\n    )\n    const computedChildren = useMemo(\n      () =>\n        createComboboxChildren(computedItems, {\n          Empty: AutocompleteEmpty,\n          Group: AutocompleteGroup,\n          Option: AutocompleteOption,\n        }),\n      [computedItems],\n    )\n    const varProps = useInputBorder({ errorBorderColor, focusBorderColor })\n    const comboboxContext = useMemo(\n      () => ({ onActiveDescendant, onClose, onSelect }),\n      [onActiveDescendant, onClose, onSelect],\n    )\n    const autocompleteContext = useMemo(() => ({ max, value }), [value, max])\n    const componentContext = useMemo(\n      () => ({\n        emptyIcon,\n        emptyProps,\n        getInputProps,\n        getSeparatorProps,\n        groupProps,\n        inputProps,\n        optionProps,\n      }),\n      [\n        emptyIcon,\n        emptyProps,\n        getInputProps,\n        getSeparatorProps,\n        groupProps,\n        inputProps,\n        optionProps,\n      ],\n    )\n    const hasValue = isArray(value) ? !!value.length : !!value\n\n    return (\n      <ComboboxDescendantsContext value={descendants}>\n        <ComboboxContext value={comboboxContext}>\n          <AutocompleteContext value={autocompleteContext}>\n            <ComponentContext value={componentContext}>\n              <Popover.Root {...mergedPopoverProps}>\n                <InputGroup.Root\n                  className={className}\n                  css={css}\n                  colorScheme={colorScheme}\n                  {...getRootProps({ ...groupItemProps, ...rootProps })}\n                >\n                  <Popover.Trigger>\n                    <AutocompleteField {...getFieldProps(varProps)}>\n                      {fieldChildren}\n                    </AutocompleteField>\n                  </Popover.Trigger>\n\n                  <InputGroup.Element\n                    {...{ clickable: clearable && hasValue, ...elementProps }}\n                  >\n                    {clearable && hasValue ? (\n                      <AutocompleteIcon\n                        icon={clearIcon}\n                        {...getClearIconProps(iconProps)}\n                      />\n                    ) : (\n                      <AutocompleteIcon\n                        icon={icon}\n                        {...getIconProps(iconProps)}\n                      />\n                    )}\n                  </InputGroup.Element>\n                </InputGroup.Root>\n\n                <AutocompleteContent\n                  {...cast<AutocompleteContentProps>(\n                    getContentProps(cast<HTMLProps>(contentProps)),\n                  )}\n                >\n                  {computedChildren}\n                </AutocompleteContent>\n              </Popover.Root>\n            </ComponentContext>\n          </AutocompleteContext>\n        </ComboboxContext>\n      </ComboboxDescendantsContext>\n    )\n  },\n  \"root\",\n)((props) => {\n  const context = useInputPropsContext()\n\n  return { ...context, ...props }\n}) as GenericsComponent<{\n  <Multiple extends boolean = false>(\n    props: AutocompleteRootProps<Multiple>,\n  ): ReactElement\n}>\n\ninterface AutocompleteFieldProps extends HTMLStyledProps {}\n\nconst AutocompleteField = withContext<\"div\", AutocompleteFieldProps>(\n  \"div\",\n  \"field\",\n)({ \"data-group-propagate\": \"\" }, ({ children, ...rest }) => {\n  const { getInputProps, inputProps } = useComponentContext()\n\n  return {\n    ...rest,\n    children: (\n      <>\n        {children}\n        <AutocompleteInput {...getInputProps(inputProps)} />\n      </>\n    ),\n  }\n})\n\ninterface AutocompleteInputProps extends HTMLStyledProps<\"input\"> {}\n\nconst AutocompleteInput = withContext<\"input\", AutocompleteInputProps>(\n  \"input\",\n  \"input\",\n)()\n\ninterface AutocompleteIconProps extends HTMLStyledProps {\n  icon?: ReactNode\n}\n\nconst AutocompleteIcon = withContext<\"div\", AutocompleteIconProps>(\n  \"div\",\n  \"icon\",\n)(undefined, ({ children, icon, ...rest }) => ({\n  children: icon || children || <ChevronDownIcon />,\n  ...rest,\n}))\n\ninterface AutocompleteContentProps extends Popover.ContentProps {}\n\nconst AutocompleteContent = withContext<\"div\", AutocompleteContentProps>(\n  Popover.Content,\n  \"content\",\n)()\n\nexport interface AutocompleteLabelProps extends HTMLStyledProps<\"span\"> {}\n\nexport const AutocompleteLabel = withContext<\"span\", AutocompleteLabelProps>(\n  \"span\",\n  \"label\",\n)(undefined, (props) => {\n  const { getLabelProps } = useComboboxGroupContext()\n\n  return getLabelProps(props)\n})\n\nexport interface AutocompleteGroupProps\n  extends UseComboboxGroupProps,\n    HTMLStyledProps {\n  /**\n   * The label of the group.\n   */\n  label?: ReactNode\n  /**\n   * Props for the label component.\n   */\n  labelProps?: AutocompleteLabelProps\n}\n\nexport const AutocompleteGroup = withContext<\"div\", AutocompleteGroupProps>(\n  ({ children, label, labelProps, ...rest }) => {\n    const { groupProps } = useComponentContext()\n    const { getGroupProps, getLabelProps } = useComboboxGroup({\n      ...groupProps,\n      ...rest,\n    })\n    const context = useMemo(() => ({ getLabelProps }), [getLabelProps])\n\n    return (\n      <ComboboxGroupContext value={context}>\n        <styled.div {...getGroupProps()}>\n          {label ? (\n            <AutocompleteLabel {...labelProps}>{label}</AutocompleteLabel>\n          ) : null}\n          {children}\n        </styled.div>\n      </ComboboxGroupContext>\n    )\n  },\n  \"group\",\n)()\n\nexport interface AutocompleteOptionProps\n  extends UseAutocompleteOptionProps,\n    HTMLStyledProps {\n  /**\n   * The icon to be used in the autocomplete option.\n   */\n  icon?: ReactNode\n}\n\nexport const AutocompleteOption = withContext<\"div\", AutocompleteOptionProps>(\n  ({ children, icon: iconProp, ...rest }) => {\n    const { optionProps: { icon, ...optionProps } = {} } = useComponentContext()\n    const { getIndicatorProps, getOptionProps } = useAutocompleteOption({\n      ...optionProps,\n      ...rest,\n    })\n\n    return (\n      <styled.div {...getOptionProps()}>\n        <AutocompleteIndicator {...getIndicatorProps()}>\n          {iconProp ?? icon ?? <CheckIcon />}\n        </AutocompleteIndicator>\n        {children}\n      </styled.div>\n    )\n  },\n  \"option\",\n)()\n\ninterface AutocompleteEmptyProps extends HTMLStyledProps {\n  /**\n   * The icon to be used in the autocomplete option.\n   */\n  icon?: ReactNode\n}\n\nconst AutocompleteEmpty = withContext<\"div\", AutocompleteEmptyProps>(\n  ({ children, icon, ...rest }) => {\n    const { emptyIcon, emptyProps } = useComponentContext()\n\n    return (\n      <styled.div {...emptyProps} {...rest}>\n        <AutocompleteIndicator>\n          {icon ?? emptyIcon ?? <MinusIcon />}\n        </AutocompleteIndicator>\n        {children}\n      </styled.div>\n    )\n  },\n  \"empty\",\n)()\n\ninterface AutocompleteIndicatorProps extends HTMLStyledProps {}\n\nconst AutocompleteIndicator = withContext<\"div\", AutocompleteIndicatorProps>(\n  \"div\",\n  \"indicator\",\n)()\n"
    },
    {
      "name": "index.ts",
      "content": "export * from \"./autocomplete.style\"\nexport {\n  AutocompleteGroup,\n  AutocompleteLabel,\n  AutocompleteOption,\n  AutocompletePropsContext,\n  AutocompleteRoot,\n  useAutocompletePropsContext,\n} from \"./autocomplete\"\nexport type {\n  AutocompleteGroupProps,\n  AutocompleteLabelProps,\n  AutocompleteOptionProps,\n  AutocompleteRootProps,\n} from \"./autocomplete\"\nexport * as Autocomplete from \"./namespace\"\nexport * from \"./use-autocomplete\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export type {\n  ComboboxItem as Item,\n  ComboboxItemWithItems as ItemWithItems,\n  ComboboxItemWithValue as ItemWithValue,\n} from \"../../hooks/use-combobox\"\nexport {\n  AutocompleteGroup as Group,\n  AutocompleteLabel as Label,\n  AutocompleteOption as Option,\n  AutocompletePropsContext as PropsContext,\n  AutocompleteRoot as Root,\n  useAutocompletePropsContext as usePropsContext,\n} from \"./autocomplete\"\nexport type {\n  AutocompleteGroupProps as GroupProps,\n  AutocompleteLabelProps as LabelProps,\n  AutocompleteOptionProps as OptionProps,\n  AutocompleteRootProps as RootProps,\n} from \"./autocomplete\"\n"
    },
    {
      "name": "use-autocomplete.tsx",
      "content": "\"use client\"\n\nimport type {\n  ChangeEvent,\n  FocusEvent,\n  KeyboardEvent,\n  MouseEvent,\n  ReactNode,\n} from \"react\"\nimport type {\n  HTMLProps,\n  HTMLRefAttributes,\n  PropGetter,\n  Dict,\n} from \"@yamada-ui/react\"\nimport type {\n  ComboboxItem,\n  ComboboxItemWithValue,\n  UseComboboxItemProps,\n  UseComboboxProps,\n} from \"../../hooks/use-combobox\"\nimport type { FieldProps } from \"../field\"\nimport {\n  cloneElement,\n  isValidElement,\n  useCallback,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport { useCombobox, useComboboxItem } from \"../../hooks/use-combobox\"\nimport { useControllableState } from \"../../hooks/use-controllable-state\"\nimport { useI18n } from \"../../providers/i18n-provider\"\nimport {\n  cast,\n  contains,\n  createContext,\n  dataAttr,\n  handlerAll,\n  isArray,\n  isComposing,\n  isNumber,\n  isString,\n  isUndefined,\n  mergeRefs,\n  runIfFn,\n  runKeyAction,\n  useUpdateEffect,\n  visuallyHiddenAttributes,\n} from \"@yamada-ui/react\"\nimport { useFieldProps } from \"../field\"\n\ninterface AutocompleteRenderProps extends ComboboxItemWithValue {\n  count: number\n  focused: boolean\n  index: number\n  separator: string\n  onClear: () => void\n  max?: number\n}\n\nexport interface AutocompleteItemRender {\n  (props: AutocompleteRenderProps): ReactNode\n}\n\nconst defaultRender: AutocompleteItemRender = ({\n  count,\n  focused,\n  index,\n  label,\n  max,\n  separator,\n}) => {\n  const last = count - 1 === index\n\n  return (\n    <span style={{ marginInlineEnd: \"var(--gap)\" }}>\n      {label}\n      {((!isNumber(max) || count < max) && focused) || !last ? separator : null}\n    </span>\n  )\n}\n\nconst getInputValue = (item?: ComboboxItemWithValue) =>\n  isString(item?.label) ? item.label : (item?.query ?? \"\")\n\nexport interface AutocompleteFilter {\n  (\n    inputValue: string,\n    items: ComboboxItem[],\n    matcher: AutocompleteMatcher,\n  ): ComboboxItem[]\n}\n\nconst defaultFilter: AutocompleteFilter = (inputValue, items, matcher) => {\n  if (!inputValue.length) return items\n\n  return items\n    .map((item) => {\n      if (\"items\" in item) {\n        const items = item.items.filter((item) => {\n          if (\"query\" in item) {\n            return matcher(inputValue, item.query)\n          } else if (isString(item.label)) {\n            return matcher(inputValue, item.label)\n          }\n        })\n\n        if (items.length) return { ...item, items }\n      } else if (\"query\" in item) {\n        if (matcher(inputValue, item.query)) return item\n      } else if (isString(item.label)) {\n        if (matcher(inputValue, item.label)) return item\n      }\n    })\n    .filter(Boolean) as ComboboxItem[]\n}\n\nexport interface AutocompleteMatcher {\n  (input: string, target?: string): boolean\n}\n\nconst defaultMatcher: AutocompleteMatcher = (input, target) =>\n  target?.toLowerCase().includes(input.toLowerCase()) ?? false\n\ninterface AutocompleteContext\n  extends Pick<UseAutocompleteReturn, \"max\" | \"value\"> {}\n\nconst [AutocompleteContext, useAutocompleteContext] =\n  createContext<AutocompleteContext>({\n    name: \"AutocompleteContext\",\n  })\n\nexport { AutocompleteContext, useAutocompleteContext }\n\nexport interface UseAutocompleteProps<Multiple extends boolean = false>\n  extends Omit<HTMLProps, \"defaultValue\" | \"onChange\" | \"ref\" | \"value\">,\n    Omit<\n      UseComboboxProps,\n      \"defaultValue\" | \"initialFocusValue\" | \"onChange\" | \"ref\" | \"value\"\n    >,\n    HTMLRefAttributes<\"input\">,\n    FieldProps {\n  /**\n   * If `true`, the autocomplete will allow custom value.\n   *\n   * @default false\n   */\n  allowCustomValue?: boolean\n  /**\n   * If `true`, the autocomplete will be closed when the input value changes.\n   *\n   * @default false\n   */\n  closeOnChange?: ((ev: ChangeEvent<HTMLInputElement>) => boolean) | boolean\n  /**\n   * The initial value of the input.\n   */\n  defaultInputValue?: string\n  /**\n   * The initial value of the autocomplete.\n   */\n  defaultValue?: Multiple extends true ? string[] : string\n  /**\n   * The message displayed when the search yields no hits.\n   *\n   * @default 'No results found'\n   */\n  emptyMessage?: ReactNode\n  /**\n   * The function to filter the items.\n   */\n  filter?: AutocompleteFilter\n  /**\n   * If `true`, the input will be focused when the clear icon is clicked.\n   *\n   * @default true\n   */\n  focusOnClear?: boolean\n  /**\n   * The value of the input.\n   */\n  inputValue?: string\n  /**\n   * If provided, generate options based on items.\n   *\n   * @default []\n   */\n  items?: ComboboxItem[]\n  /**\n   * The function to match the items.\n   */\n  matcher?: AutocompleteMatcher\n  /**\n   * The maximum selectable value.\n   */\n  max?: number\n  /**\n   * If `true`, the autocomplete will be multiple.\n   *\n   * @default false\n   */\n  multiple?: Multiple\n  /**\n   * If `true`, the autocomplete will be opened when the input value changes.\n   *\n   * @default true\n   */\n  openOnChange?: ((ev: ChangeEvent<HTMLInputElement>) => boolean) | boolean\n  /**\n   * If `true`, the autocomplete will be opened when the input is focused.\n   *\n   * @default false\n   */\n  openOnFocus?: boolean\n  /**\n   * The placeholder for autocomplete.\n   */\n  placeholder?: string\n  /**\n   * The function to render the selected items.\n   */\n  render?: (props: AutocompleteRenderProps) => ReactNode\n  /**\n   * The visual separator between each value.\n   *\n   * @default ','\n   */\n  separator?: string\n  /**\n   * The value of the autocomplete.\n   */\n  value?: Multiple extends true ? string[] : string\n  /**\n   * The callback invoked when value state changes.\n   */\n  onChange?: (value: Multiple extends true ? string[] : string) => void\n  /**\n   * The callback invoked when input value state changes.\n   */\n  onInputChange?: (value: string) => void\n}\n\nexport const useAutocomplete = <Multiple extends boolean = false>(\n  props: UseAutocompleteProps<Multiple> = {},\n) => {\n  type MaybeValue = Multiple extends true ? string[] : string\n\n  const { t } = useI18n(\"autocomplete\")\n  const {\n    props: {\n      ref,\n      allowCustomValue = false,\n      closeOnChange = false,\n      multiple = false,\n      closeOnSelect = !multiple,\n      defaultInputValue,\n      defaultValue = (multiple ? [] : \"\") as MaybeValue,\n      disabled,\n      emptyMessage = t(\"No results found\"),\n      filter = defaultFilter,\n      focusOnClear = true,\n      inputValue: inputValueProp,\n      items = [],\n      matcher = defaultMatcher,\n      max,\n      openOnChange = true,\n      openOnFocus = false,\n      placeholder,\n      readOnly,\n      render = defaultRender,\n      separator = \",\",\n      value: valueProp,\n      onChange: onChangeProp,\n      onInputChange: onInputChangeProp,\n      ...rest\n    },\n    ariaProps,\n    dataProps,\n    eventProps,\n  } = useFieldProps(props)\n  const rootRef = useRef<HTMLDivElement>(null)\n  const contentRef = useRef<HTMLDivElement>(null)\n  const inputRef = useRef<HTMLInputElement>(null)\n  const valueMap = useMemo<{ [key: string]: ComboboxItemWithValue }>(() => {\n    const valueMap: { [key: string]: ComboboxItemWithValue } = {}\n\n    items.forEach((item) => {\n      if (\"items\" in item) {\n        item.items.forEach((item) => {\n          item.value ??= isString(item.label) ? item.label : undefined\n\n          if (!isUndefined(item.value)) valueMap[item.value] = item\n        })\n      } else {\n        item.value ??= isString(item.label) ? item.label : undefined\n\n        if (!isUndefined(item.value)) valueMap[item.value] = item\n      }\n    })\n\n    return valueMap\n  }, [items])\n  const [focused, setFocused] = useState(false)\n  const [value, setValue] = useControllableState({\n    defaultValue,\n    value: valueProp,\n    onChange: onChangeProp,\n  })\n  const [inputValue, setInputValue] = useControllableState({\n    defaultValue:\n      defaultInputValue ??\n      getInputValue(isArray(value) ? undefined : valueMap[value as string]),\n    value: inputValueProp,\n    onChange: onInputChangeProp,\n  })\n  const onChange = useCallback(\n    (selectedValue: string) => {\n      setValue((prev) => {\n        if (isArray(prev)) {\n          if (prev.includes(selectedValue)) {\n            return prev.filter(\n              (prevValue) => prevValue !== selectedValue,\n            ) as MaybeValue\n          } else if (!isNumber(max) || prev.length < max) {\n            return [...prev, selectedValue] as MaybeValue\n          } else {\n            return prev\n          }\n        } else {\n          return selectedValue as MaybeValue\n        }\n      })\n\n      if (isArray(value)) {\n        setInputValue(\"\")\n      } else {\n        const item = valueMap[selectedValue]\n\n        setInputValue(getInputValue(item))\n      }\n    },\n    [max, setInputValue, setValue, value, valueMap],\n  )\n  const {\n    activeDescendant,\n    descendants,\n    interactive,\n    open,\n    getContentProps: getComboboxContentProps,\n    getSeparatorProps,\n    getTriggerProps,\n    onActiveDescendant,\n    onClose,\n    onOpen,\n    onOpenWithActiveDescendant,\n    onSelect,\n  } = useCombobox({\n    closeOnSelect,\n    disabled,\n    initialFocusValue: isArray(value) ? value[0] : value,\n    openOnEnter: false,\n    openOnSpace: false,\n    readOnly,\n    selectFocusRef: inputRef,\n    selectOnSpace: false,\n    onChange,\n    ...ariaProps,\n    ...dataProps,\n    ...eventProps,\n    ...rest,\n  })\n  const filteredItems = useMemo<ComboboxItem[]>(() => {\n    if (!items.length) return []\n\n    return filter(inputValue, items, matcher)\n  }, [filter, inputValue, items, matcher])\n  const resolvedItems = useMemo<ComboboxItem[]>(() => {\n    return filteredItems.length\n      ? filteredItems\n      : [{ \"data-empty\": \"\", label: emptyMessage }]\n  }, [filteredItems, emptyMessage])\n  const empty = useMemo(\n    () => !resolvedItems.filter(({ hidden }) => !hidden).length,\n    [resolvedItems],\n  )\n  const children = useMemo<ReactNode>(() => {\n    if (!isArray(value)) return null\n\n    const count = value.length\n\n    return value.map((value, index) => {\n      const item = valueMap[value] ?? { label: value, value }\n\n      const onClear = (ev?: MouseEvent<HTMLElement>) => {\n        ev?.preventDefault()\n        ev?.stopPropagation()\n\n        if (item.value) onChange(item.value)\n      }\n\n      const component = render({\n        count,\n        focused,\n        index,\n        max,\n        separator,\n        onClear,\n        ...item,\n      })\n\n      if (isValidElement<Dict>(component)) {\n        return cloneElement(component, { ...component.props, key: index })\n      } else {\n        return component\n      }\n    })\n  }, [focused, max, onChange, render, separator, value, valueMap])\n  const hasValues = isArray(value) && !!value.length\n\n  const onInputChange = useCallback(\n    (ev: ChangeEvent<HTMLInputElement>) => {\n      if (isArray(value) && value.length === max) return\n\n      if (runIfFn(closeOnChange, ev)) {\n        onClose()\n      } else if (runIfFn(openOnChange, ev)) {\n        onOpen()\n      }\n\n      activeDescendant.current = null\n\n      const inputValue = ev.target.value\n\n      setInputValue(inputValue)\n\n      if (inputValue.length || isArray(value)) return\n\n      setValue(\"\" as MaybeValue)\n    },\n    [\n      activeDescendant,\n      closeOnChange,\n      max,\n      onClose,\n      onOpen,\n      openOnChange,\n      setInputValue,\n      setValue,\n      value,\n    ],\n  )\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLInputElement>) => {\n      if (disabled || isComposing(ev)) return\n\n      const inputValue = cast<HTMLInputElement>(ev.target).value\n\n      runKeyAction(\n        ev,\n        {\n          Backspace: (ev) => {\n            if (!isArray(value)) return\n            if (!!inputValue.length) return\n\n            ev.preventDefault()\n\n            setValue((prev) => prev.slice(0, -1) as MaybeValue)\n          },\n          Enter: (ev) => {\n            if (!open || !inputValue.length || activeDescendant.current) return\n\n            const item = filteredItems[0]\n\n            if (!item) {\n              if (!allowCustomValue || !isArray(value)) return\n\n              ev.preventDefault()\n\n              onSelect(inputValue)\n            } else {\n              ev.preventDefault()\n\n              if (\"items\" in item) {\n                onSelect(item.items[0]?.value)\n              } else {\n                onSelect(item.value)\n              }\n            }\n          },\n        },\n        { preventDefault: false },\n      )\n    },\n    [\n      activeDescendant,\n      allowCustomValue,\n      disabled,\n      filteredItems,\n      onSelect,\n      open,\n      setValue,\n      value,\n    ],\n  )\n\n  const onClick = useCallback(() => {\n    if (!interactive) return\n\n    inputRef.current?.focus()\n  }, [interactive])\n\n  const onMouseDown = useCallback(\n    (ev: MouseEvent<HTMLInputElement>) => {\n      if (!openOnFocus) return\n\n      ev.preventDefault()\n      ev.stopPropagation()\n    },\n    [openOnFocus],\n  )\n\n  const onFocus = useCallback(\n    (ev: FocusEvent<HTMLInputElement>) => {\n      ev.preventDefault()\n      ev.stopPropagation()\n\n      setFocused(true)\n\n      if (openOnFocus) onOpenWithActiveDescendant(descendants.enabledFirstValue)\n    },\n    [openOnFocus, onOpenWithActiveDescendant, descendants],\n  )\n\n  const onBlur = useCallback(\n    (ev: FocusEvent<HTMLInputElement>) => {\n      setFocused(false)\n\n      if (\n        contains(rootRef.current, ev.relatedTarget) ||\n        contains(contentRef.current, ev.relatedTarget)\n      ) {\n        ev.preventDefault()\n      } else {\n        if (isArray(value)) {\n          setInputValue(\"\")\n        } else {\n          if (allowCustomValue) {\n            if (inputValue) setValue(inputValue as MaybeValue)\n          } else {\n            const item = valueMap[value as string]\n\n            setInputValue(getInputValue(item))\n          }\n        }\n      }\n    },\n    [allowCustomValue, inputValue, setInputValue, setValue, value, valueMap],\n  )\n\n  const onClear = useCallback(() => {\n    setValue((prev) => (isArray(prev) ? [] : \"\") as MaybeValue)\n    setInputValue(\"\")\n\n    if (focusOnClear) inputRef.current?.focus()\n  }, [focusOnClear, setInputValue, setValue])\n\n  useUpdateEffect(() => {\n    if (isArray(valueProp)) return\n\n    setInputValue(\n      getInputValue(valueProp ? valueMap[valueProp as string] : undefined),\n    )\n  }, [valueProp])\n\n  const getRootProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ref: mergeRefs(ref, rootRef),\n      ...dataProps,\n      ...props,\n    }),\n    [dataProps],\n  )\n\n  const getFieldProps: PropGetter = useCallback(\n    (props = {}) =>\n      getTriggerProps({\n        tabIndex: -1,\n        ...props,\n        onClick: handlerAll(props.onClick, onClick),\n      }),\n\n    [getTriggerProps, onClick],\n  )\n\n  const getInputProps: PropGetter<\"input\"> = useCallback(\n    (props = {}) => ({\n      ref: mergeRefs(props.ref, ref, inputRef),\n      style: {\n        ...(!focused && isArray(value) && !!value.length\n          ? visuallyHiddenAttributes.style\n          : {}),\n        ...props.style,\n      },\n      \"data-max\": dataAttr(\n        isArray(value) && isNumber(max) && value.length >= max,\n      ),\n      autoCapitalize: \"off\",\n      autoComplete: \"off\",\n      autoCorrect: \"off\",\n      disabled: !interactive,\n      placeholder: hasValues ? undefined : placeholder,\n      spellCheck: false,\n      value: inputValue,\n      ...dataProps,\n      ...props,\n      onBlur: handlerAll(props.onBlur, onBlur),\n      onChange: handlerAll(props.onChange, onInputChange),\n      onFocus: handlerAll(props.onFocus, onFocus),\n      onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n      onMouseDown: handlerAll(props.onMouseDown, onMouseDown),\n    }),\n    [\n      dataProps,\n      focused,\n      hasValues,\n      inputValue,\n      interactive,\n      max,\n      onBlur,\n      onFocus,\n      onInputChange,\n      onKeyDown,\n      onMouseDown,\n      placeholder,\n      ref,\n      value,\n    ],\n  )\n\n  const getContentProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) =>\n      getComboboxContentProps({\n        ref: mergeRefs(ref, contentRef),\n        hidden: empty,\n        ...props,\n      }),\n    [empty, getComboboxContentProps],\n  )\n\n  const getIconProps: PropGetter = useCallback(\n    (props) => ({ ...dataProps, ...props }),\n    [dataProps],\n  )\n\n  const getClearIconProps: PropGetter = useCallback(\n    (props = {}) =>\n      getIconProps({\n        \"aria-label\": t(\"Clear value\"),\n        role: \"button\",\n        tabIndex: 0,\n        ...props,\n        onClick: handlerAll(props.onClick, onClear),\n        onKeyDown: handlerAll(props.onKeyDown, (ev) =>\n          runKeyAction(ev, {\n            Enter: onClear,\n            Space: onClear,\n          }),\n        ),\n      }),\n    [getIconProps, onClear, t],\n  )\n\n  return {\n    children,\n    descendants,\n    inputValue,\n    interactive,\n    items: resolvedItems,\n    max,\n    open,\n    setInputValue,\n    setValue,\n    value,\n    valueMap,\n    getClearIconProps,\n    getContentProps,\n    getFieldProps,\n    getIconProps,\n    getInputProps,\n    getRootProps,\n    getSeparatorProps,\n    onActiveDescendant,\n    onChange,\n    onClose,\n    onInputChange,\n    onOpen,\n    onSelect,\n  }\n}\n\nexport type UseAutocompleteReturn = ReturnType<typeof useAutocomplete>\n\nexport interface UseAutocompleteOptionProps extends UseComboboxItemProps {}\n\nexport const useAutocompleteOption = ({\n  children,\n  closeOnSelect,\n  disabled,\n  hidden,\n  value,\n  ...rest\n}: UseAutocompleteOptionProps = {}) => {\n  const { max, value: selectedValue } = useAutocompleteContext()\n\n  value ??= isString(children) ? children : undefined\n\n  const selected = isArray(selectedValue)\n    ? !isUndefined(value) && selectedValue.includes(value)\n    : selectedValue === value\n  const completed =\n    isNumber(max) && isArray(selectedValue) && selectedValue.length >= max\n  const { getIndicatorProps, getItemProps } = useComboboxItem({\n    children,\n    closeOnSelect,\n    disabled: disabled || hidden || (completed && !selected),\n    hidden,\n    selected,\n    value,\n    ...rest,\n  })\n\n  const getOptionProps: PropGetter = useCallback(\n    (props = {}) => getItemProps(props),\n    [getItemProps],\n  )\n\n  return { getIndicatorProps, getOptionProps }\n}\n\nexport type UseAutocompleteOptionReturn = ReturnType<\n  typeof useAutocompleteOption\n>\n"
    }
  ]
}
