{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "section": "hooks",
  "sources": [
    {
      "name": "index.ts",
      "content": "\"use client\"\n\nimport type { CSSAnimationObject, Token } from \"@yamada-ui/react\"\nimport { useCallback, useRef, useState } from \"react\"\nimport {\n  animation,\n  css,\n  useSystem,\n  isArray,\n  isUndefined,\n  runIfFn,\n} from \"@yamada-ui/react\"\n\ntype CSSObject =\n  | Token<CSSAnimationObject, \"animations\">\n  | Token<CSSAnimationObject, \"animations\">[]\n\n/**\n * `useAnimation` is a custom hook that implements animations similar to CSS `keyframes`.\n *\n * @see https://yamada-ui.com/hooks/use-animation\n */\nexport const useAnimation = (cssObj: CSSObject): string => {\n  const system = useSystem()\n\n  if (isArray(cssObj)) {\n    return cssObj.map((cssObj) => animation(cssObj, { css, system })).join(\", \")\n  } else {\n    return animation(cssObj, { css, system })\n  }\n}\n\n/**\n * `useDynamicAnimation` is a custom hook used to switch animations.\n *\n * @see https://yamada-ui.com/hooks/use-dynamic-animation\n */\nexport const useDynamicAnimation = <\n  Y extends\n    | Token<CSSAnimationObject, \"animations\">[]\n    | { [key: string]: CSSObject },\n>(\n  arrayOrObj: Y,\n  init?: (keyof Y)[] | keyof Y,\n): [\n  string | undefined,\n  (\n    key:\n      | ((key: (keyof Y)[] | keyof Y | undefined) => (keyof Y)[] | keyof Y)\n      | (keyof Y)[]\n      | keyof Y,\n  ) => void,\n] => {\n  const system = useSystem()\n\n  const keys = useRef<string | string[] | undefined>(\n    !isUndefined(init)\n      ? isArray(init)\n        ? init.map(String)\n        : String(init)\n      : undefined,\n  )\n  const cache = useRef<Map<string, string>>(new Map<string, string>())\n\n  const [animations, setAnimations] = useState<string | undefined>(() => {\n    for (const [key, styles] of Object.entries(arrayOrObj)) {\n      if (cache.current.has(key)) return\n\n      if (isArray(styles)) {\n        cache.current.set(\n          key,\n          styles.map((style) => animation(style, { css, system })).join(\", \"),\n        )\n      } else {\n        cache.current.set(key, animation(styles, { css, system }))\n      }\n    }\n\n    if (isArray(keys.current)) {\n      return keys.current.map((key) => cache.current.get(key)).join(\", \")\n    } else {\n      return cache.current.get(keys.current ?? \"\")\n    }\n  })\n\n  const setAnimation = useCallback(\n    (\n      keysOrFunc:\n        | ((key: (keyof Y)[] | keyof Y | undefined) => (keyof Y)[] | keyof Y)\n        | (keyof Y)[]\n        | keyof Y,\n    ) => {\n      const args = (() => {\n        if (!isUndefined(keys.current) && isArray(arrayOrObj)) {\n          return isArray(keys.current)\n            ? keys.current.map(Number)\n            : Number(keys.current)\n        } else {\n          return keys.current\n        }\n      })() as (keyof Y)[] | keyof Y | undefined\n\n      const keyOrArray = runIfFn(keysOrFunc, args)\n\n      keys.current = isArray(keyOrArray)\n        ? keyOrArray.map(String)\n        : String(keyOrArray)\n\n      if (isArray(keys.current)) {\n        setAnimations(\n          keys.current.map((key) => cache.current.get(key)).join(\", \"),\n        )\n      } else {\n        setAnimations(cache.current.get(keys.current))\n      }\n    },\n    [arrayOrObj],\n  )\n\n  return [animations, setAnimation]\n}\n"
    }
  ]
}
