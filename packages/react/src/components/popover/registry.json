{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["motion", "portal", "fade-scale", "slide-fade"],
    "externals": ["motion@12.18.1"],
    "hooks": [
      "use-disclosure",
      "use-popper",
      "use-event-listener",
      "use-focus",
      "use-outside-click"
    ],
    "providers": []
  },
  "dependents": {
    "components": ["autocomplete", "menu", "modal", "select", "tooltip"],
    "hooks": [],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./popover.style\"\nexport * as Popover from \"./namespace\"\nexport type {\n  PopoverAnchorProps,\n  PopoverBodyProps,\n  PopoverContentProps,\n  PopoverFooterProps,\n  PopoverHeaderProps,\n  PopoverRootProps,\n  PopoverTriggerProps,\n  PopupAnimationProps,\n} from \"./popover\"\nexport {\n  getPopupAnimationProps,\n  PopoverAnchor,\n  PopoverBody,\n  PopoverContent,\n  PopoverFooter,\n  PopoverHeader,\n  PopoverPropsContext,\n  PopoverRoot,\n  PopoverTrigger,\n  usePopoverPropsContext,\n} from \"./popover\"\nexport * from \"./use-popover\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  PopoverAnchor as Anchor,\n  PopoverBody as Body,\n  PopoverContent as Content,\n  PopoverFooter as Footer,\n  PopoverHeader as Header,\n  PopoverPropsContext as PropsContext,\n  PopoverRoot as Root,\n  PopoverTrigger as Trigger,\n  usePopoverPropsContext as usePropsContext,\n} from \"./popover\"\nexport type {\n  PopoverAnchorProps as AnchorProps,\n  PopoverBodyProps as BodyProps,\n  PopoverContentProps as ContentProps,\n  PopoverFooterProps as FooterProps,\n  PopoverHeaderProps as HeaderProps,\n  PopoverRootProps as RootProps,\n  PopoverTriggerProps as TriggerProps,\n} from \"./popover\"\n"
    },
    {
      "name": "popover.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const popoverStyle = defineComponentSlotStyle({\n  base: {\n    body: {\n      alignItems: \"flex-start\",\n      display: \"flex\",\n      flex: \"1\",\n      flexDirection: \"column\",\n      gap: \"{gap}\",\n    },\n    content: {\n      bg: \"bg.panel\",\n      borderColor: \"border.muted\",\n      borderWidth: \"1px\",\n      boxShadow: \"sm\",\n      display: \"flex\",\n      flexDirection: \"column\",\n      focusVisibleRing: \"none\",\n      gap: \"{gap}\",\n      p: \"{padding}\",\n      rounded: \"l2\",\n    },\n    footer: {\n      alignItems: \"center\",\n      display: \"flex\",\n      gap: \"{gap}\",\n      justifyContent: \"flex-start\",\n    },\n    header: {\n      alignItems: \"center\",\n      display: \"flex\",\n      fontWeight: \"semibold\",\n      gap: \"{gap}\",\n      justifyContent: \"flex-start\",\n    },\n    positioner: {\n      zIndex: \"recoome\",\n    },\n  },\n\n  sizes: {\n    xs: {\n      content: {\n        \"--gap\": \"spaces.1\",\n        \"--padding\": \"spaces.2\",\n        fontSize: \"xs\",\n      },\n    },\n    sm: {\n      content: {\n        \"--gap\": \"spaces.2\",\n        \"--padding\": \"spaces.3\",\n        fontSize: \"sm\",\n      },\n    },\n    md: {\n      content: {\n        \"--gap\": \"spaces.3\",\n        \"--padding\": \"spaces.4\",\n        fontSize: \"md\",\n      },\n    },\n    lg: {\n      content: {\n        \"--gap\": \"spaces.4\",\n        \"--padding\": \"spaces.5\",\n        fontSize: \"md\",\n      },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n  },\n})\n\nexport type PopoverStyle = typeof popoverStyle\n"
    },
    {
      "name": "popover.tsx",
      "content": "\"use client\"\n\nimport type { FC, PropsWithChildren } from \"react\"\nimport type {\n  HTMLProps,\n  HTMLStyledProps,\n  SimplePlacement,\n  ThemeProps,\n  ReactNodeOrFunction,\n} from \"@yamada-ui/react\"\nimport type { HTMLMotionProps, MotionTransitionProps } from \"../motion\"\nimport type { PortalProps } from \"../portal\"\nimport type { PopoverStyle } from \"./popover.style\"\nimport type { UsePopoverProps, UsePopoverReturn } from \"./use-popover\"\nimport { AnimatePresence } from \"motion/react\"\nimport { useMemo } from \"react\"\nimport { createSlotComponent, cast, runIfFn } from \"@yamada-ui/react\"\nimport { fadeScaleVariants } from \"../fade-scale\"\nimport { motion } from \"../motion\"\nimport { Portal } from \"../portal\"\nimport { slideFadeVariants } from \"../slide-fade\"\nimport { popoverStyle } from \"./popover.style\"\nimport { usePopover } from \"./use-popover\"\n\nexport interface PopupAnimationProps {\n  /**\n   * The animation of the element.\n   *\n   * @default 'scale'\n   */\n  animationScheme?: \"none\" | \"scale\" | SimplePlacement\n  /**\n   * The animation duration.\n   *\n   * @default 0.2\n   */\n  duration?: MotionTransitionProps[\"duration\"]\n}\n\nexport const getPopupAnimationProps = (\n  animationScheme: PopupAnimationProps[\"animationScheme\"] = \"scale\",\n  duration?: PopupAnimationProps[\"duration\"],\n) => {\n  const sharedProps = { animate: \"enter\", exit: \"exit\", initial: \"exit\" }\n\n  switch (animationScheme) {\n    case \"scale\":\n      return {\n        ...sharedProps,\n        custom: { duration, reverse: true, scale: 0.95 },\n        variants: fadeScaleVariants,\n      }\n    case \"block-start\":\n      return {\n        ...sharedProps,\n        custom: { duration, offsetY: -16, reverse: true },\n        variants: slideFadeVariants,\n      }\n    case \"inline-end\":\n      return {\n        ...sharedProps,\n        custom: { duration, offsetX: 16, reverse: true },\n        variants: slideFadeVariants,\n      }\n    case \"inline-start\":\n      return {\n        ...sharedProps,\n        custom: { duration, offsetX: -16, reverse: true },\n        variants: slideFadeVariants,\n      }\n    case \"block-end\":\n      return {\n        ...sharedProps,\n        custom: { duration, offsetY: 16, reverse: true },\n        variants: slideFadeVariants,\n      }\n    default:\n      return {}\n  }\n}\n\ninterface ComponentContext\n  extends Pick<\n      UsePopoverReturn,\n      | \"getAnchorProps\"\n      | \"getBodyProps\"\n      | \"getContentProps\"\n      | \"getFooterProps\"\n      | \"getHeaderProps\"\n      | \"getPositionerProps\"\n      | \"getTriggerProps\"\n      | \"open\"\n    >,\n    PopupAnimationProps,\n    Pick<PopoverRootProps, \"withCloseButton\"> {}\n\nexport interface PopoverRootProps\n  extends UsePopoverProps,\n    PopupAnimationProps,\n    ThemeProps<PopoverStyle> {\n  /**\n   * The children of the popover.\n   */\n  children?: ReactNodeOrFunction<{\n    open: boolean\n    onClose: () => void\n  }>\n  /**\n   * The animation duration.\n   *\n   * @default 0.2\n   */\n  duration?: PopupAnimationProps[\"duration\"]\n  /**\n   * If `true`, display the popover close button.\n   *\n   * @default true\n   */\n  withCloseButton?: boolean\n}\n\nconst {\n  ComponentContext,\n  PropsContext: PopoverPropsContext,\n  StyleContext,\n  useComponentContext,\n  usePropsContext: usePopoverPropsContext,\n  withContext,\n  useRootComponentProps,\n} = createSlotComponent<PopoverRootProps, PopoverStyle, ComponentContext>(\n  \"popover\",\n  popoverStyle,\n)\n\nexport { PopoverPropsContext, usePopoverPropsContext }\n\n/**\n * `Popover` is a component that floats around an element to display information.\n *\n * @see https://yamada-ui.com/components/popover\n */\nexport const PopoverRoot: FC<PopoverRootProps> = (props) => {\n  const [\n    styleContext,\n    {\n      animationScheme = \"scale\",\n      children,\n      duration = 0.1,\n      withCloseButton = true,\n      ...rest\n    },\n  ] = useRootComponentProps(props)\n  const {\n    open,\n    getAnchorProps,\n    getBodyProps,\n    getContentProps,\n    getFooterProps,\n    getHeaderProps,\n    getPositionerProps,\n    getTriggerProps,\n    onClose,\n  } = usePopover(rest)\n  const componentContext = useMemo(\n    () => ({\n      animationScheme,\n      duration,\n      open,\n      withCloseButton,\n      getAnchorProps,\n      getBodyProps,\n      getContentProps,\n      getFooterProps,\n      getHeaderProps,\n      getPositionerProps,\n      getTriggerProps,\n    }),\n    [\n      withCloseButton,\n      open,\n      animationScheme,\n      duration,\n      getAnchorProps,\n      getBodyProps,\n      getContentProps,\n      getFooterProps,\n      getHeaderProps,\n      getPositionerProps,\n      getTriggerProps,\n    ],\n  )\n\n  return (\n    <StyleContext value={styleContext}>\n      <ComponentContext value={componentContext}>\n        {runIfFn(children, { open, onClose })}\n      </ComponentContext>\n    </StyleContext>\n  )\n}\n\nexport interface PopoverTriggerProps extends HTMLStyledProps<\"button\"> {}\n\nexport const PopoverTrigger = withContext<\"button\", PopoverTriggerProps>(\n  \"button\",\n  \"trigger\",\n)({ asChild: true }, (props) => {\n  const { getTriggerProps } = useComponentContext()\n\n  return getTriggerProps(props)\n})\n\nexport interface PopoverAnchorProps extends HTMLStyledProps {}\n\nexport const PopoverAnchor = withContext<\"div\", PopoverAnchorProps>(\n  \"div\",\n  \"anchor\",\n)({ asChild: true }, (props) => {\n  const { getAnchorProps } = useComponentContext()\n\n  return getAnchorProps(props)\n})\n\ninterface PopoverPositionerProps extends HTMLStyledProps {}\n\nconst PopoverPositioner = withContext<\"div\", PopoverPositionerProps>(\n  \"div\",\n  \"positioner\",\n)(undefined, (props) => {\n  const { getPositionerProps } = useComponentContext()\n\n  return getPositionerProps(props)\n})\n\nexport interface PopoverContentProps\n  extends Omit<HTMLMotionProps, \"children\">,\n    PropsWithChildren {\n  /**\n   * Props for portal component.\n   */\n  portalProps?: Omit<PortalProps, \"children\">\n}\n\nexport const PopoverContent = withContext<\"div\", PopoverContentProps>(\n  ({ portalProps, ...rest }) => {\n    const { animationScheme, duration, open, getContentProps } =\n      useComponentContext()\n\n    return (\n      <AnimatePresence>\n        {open ? (\n          <Portal {...portalProps}>\n            <PopoverPositioner>\n              <motion.div\n                {...getPopupAnimationProps(animationScheme, duration)}\n                {...cast<HTMLMotionProps>(\n                  getContentProps(cast<HTMLProps>(rest)),\n                )}\n              />\n            </PopoverPositioner>\n          </Portal>\n        ) : null}\n      </AnimatePresence>\n    )\n  },\n  \"content\",\n)()\n\nexport interface PopoverHeaderProps extends HTMLStyledProps {}\n\nexport const PopoverHeader = withContext<\"div\", PopoverHeaderProps>(\n  \"div\",\n  \"header\",\n)(undefined, (props) => {\n  const { getHeaderProps } = useComponentContext()\n\n  return getHeaderProps(props)\n})\n\nexport interface PopoverBodyProps extends HTMLStyledProps {}\n\nexport const PopoverBody = withContext<\"div\", PopoverBodyProps>(\"div\", \"body\")(\n  undefined,\n  (props) => {\n    const { getBodyProps } = useComponentContext()\n\n    return getBodyProps(props)\n  },\n)\n\nexport interface PopoverFooterProps extends HTMLStyledProps {}\n\nexport const PopoverFooter = withContext<\"div\", PopoverFooterProps>(\n  \"div\",\n  \"footer\",\n)(undefined, (props) => {\n  const { getFooterProps } = useComponentContext()\n\n  return getFooterProps(props)\n})\n"
    },
    {
      "name": "use-popover.tsx",
      "content": "\"use client\"\n\nimport type { FocusEvent, KeyboardEvent, RefObject } from \"react\"\nimport type { Direction, PropGetter, Dict } from \"@yamada-ui/react\"\nimport type { UseDisclosureProps } from \"../../hooks/use-disclosure\"\nimport type { UsePopperProps } from \"../../hooks/use-popper\"\nimport type { PopupAnimationProps } from \"./popover\"\nimport { useCallback, useEffect, useId, useRef } from \"react\"\nimport {\n  useEnvironment,\n  useSplitProps,\n  ariaAttr,\n  assignRef,\n  contains,\n  cx,\n  dataAttr,\n  focusTransfer,\n  focusTrap,\n  getEventRelatedTarget,\n  handlerAll,\n  mergeRefs,\n  runKeyAction,\n  scrollLock,\n  useUnmountEffect,\n} from \"@yamada-ui/react\"\nimport { useDisclosure } from \"../../hooks/use-disclosure\"\nimport { useEventListener } from \"../../hooks/use-event-listener\"\nimport { useFocusOnShow } from \"../../hooks/use-focus\"\nimport { useOutsideClick } from \"../../hooks/use-outside-click\"\nimport { popperProps, usePopper } from \"../../hooks/use-popper\"\n\nexport interface UsePopoverProps\n  extends Omit<UseDisclosureProps, \"timing\">,\n    UsePopperProps<\"button\"> {\n  /**\n   * If `true`, focus will be transferred to the first interactive element when the popover opens.\n   *\n   * @default true\n   */\n  autoFocus?: boolean\n  /**\n   * If `true`, scrolling will be disabled on the `body` when the modal opens.\n   *\n   * @default false\n   */\n  blockScrollOnMount?: boolean\n  /**\n   * If `true`, the popover will close when you blur out it by clicking outside or tabbing out.\n   *\n   * @default true\n   */\n  closeOnBlur?: boolean\n  /**\n   * If `true`, the popover will hide on pressing Esc key.\n   *\n   * @default true\n   */\n  closeOnEsc?: boolean\n  /**\n   * If `true`, the popover will hide on scroll.\n   *\n   * @default false\n   */\n  closeOnScroll?: boolean\n  /**\n   * If `true`, the popover will be disabled.\n   *\n   * @default false\n   */\n  disabled?: boolean\n  /**\n   * The `ref` of the element that should receive focus when the popover opens.\n   */\n  initialFocusRef?: RefObject<HTMLElement | null>\n  /**\n   * If `true`, the popover will be modal.\n   *\n   * - scrolling is blocked.\n   * - focus is trapped within the popover.\n   *\n   * @default false\n   */\n  modal?: boolean\n  /**\n   * If `true`, the popover will be opened when click on the field.\n   *\n   * @default true\n   */\n  openOnClick?: boolean\n  /**\n   * The placement of the popper relative to its reference.\n   *\n   * @default 'end'\n   */\n  placement?: Direction\n  /**\n   * Update the position of the floating element, re-rendering the component if required.\n   */\n  updateRef?: RefObject<() => void>\n}\n\nexport const usePopover = ({\n  autoFocus = true,\n  autoUpdate,\n  modal = false,\n  blockScrollOnMount = modal,\n  closeOnBlur = true,\n  closeOnEsc = true,\n  closeOnScroll,\n  defaultOpen,\n  disabled,\n  elements,\n  flip,\n  gutter,\n  initialFocusRef,\n  matchWidth,\n  middleware,\n  offset,\n  open: openProp,\n  openOnClick = true,\n  placement = \"end\",\n  platform,\n  preventOverflow,\n  strategy,\n  transform,\n  updateRef,\n  whileElementsMounted,\n  onClose: onCloseProp,\n  onOpen: onOpenProp,\n}: UsePopoverProps = {}) => {\n  const { getDocument } = useEnvironment()\n  const headerId = useId()\n  const bodyId = useId()\n  const contentId = useId()\n  const anchorRef = useRef<HTMLElement>(null)\n  const triggerRef = useRef<HTMLButtonElement>(null)\n  const contentRef = useRef<HTMLElement>(null)\n  const openTimeout = useRef<NodeJS.Timeout>(undefined)\n  const closeTimeout = useRef<NodeJS.Timeout>(undefined)\n  const { open, onClose, onOpen } = useDisclosure({\n    defaultOpen,\n    open: openProp,\n    onClose: onCloseProp,\n    onOpen: onOpenProp,\n  })\n  const { refs, update, getPopperProps } = usePopper<\"button\">({\n    autoUpdate,\n    elements,\n    flip,\n    gutter,\n    matchWidth,\n    middleware,\n    offset,\n    open,\n    placement,\n    platform,\n    preventOverflow,\n    strategy,\n    transform,\n    whileElementsMounted,\n  })\n\n  assignRef(updateRef, update)\n\n  const onKeyDown = useCallback(\n    (ev: KeyboardEvent<HTMLElement>) => {\n      runKeyAction(ev, {\n        Escape: () => {\n          if (!closeOnEsc) return\n\n          onClose()\n\n          triggerRef.current?.focus()\n        },\n      })\n    },\n    [closeOnEsc, onClose],\n  )\n\n  const onBlur = useCallback(\n    (ev: FocusEvent<HTMLDivElement>) => {\n      const relatedTarget = getEventRelatedTarget(ev)\n      const popup = relatedTarget?.hasAttribute(\"data-popup\")\n\n      if (contains(triggerRef.current, relatedTarget)) return\n      if (contains(contentRef.current, relatedTarget)) return\n      if (contains(contentRef.current, ev.target) && popup) return\n\n      if (closeOnBlur) onClose()\n    },\n    [closeOnBlur, onClose],\n  )\n\n  useEventListener(getDocument(), \"scroll\", () => {\n    if (open && closeOnScroll) onClose()\n  })\n\n  useFocusOnShow(contentRef, {\n    focusTarget: initialFocusRef,\n    shouldFocus: autoFocus,\n    visible: open,\n  })\n\n  useOutsideClick({\n    ref: [contentRef, triggerRef],\n    enabled: open && closeOnBlur,\n    handler: onClose,\n  })\n\n  useEffect(() => {\n    if (!open || !modal) return\n\n    return focusTrap(contentRef.current)\n  }, [open, modal])\n\n  useEffect(() => {\n    if (!open || !blockScrollOnMount) return\n\n    return scrollLock(contentRef.current)\n  }, [open, modal, blockScrollOnMount])\n\n  useEffect(() => {\n    if (!open || modal) return\n\n    return focusTransfer(contentRef.current, triggerRef.current)\n  }, [open, modal])\n\n  useUnmountEffect(() => {\n    clearTimeout(openTimeout.current)\n    clearTimeout(closeTimeout.current)\n  })\n\n  const getTriggerProps: PropGetter<\"button\"> = useCallback(\n    ({ ref, ...props } = {}) => ({\n      \"aria-controls\": open ? contentId : undefined,\n      \"aria-disabled\": ariaAttr(disabled),\n      \"aria-expanded\": open,\n      \"aria-haspopup\": \"dialog\",\n      role: \"button\",\n      ...props,\n      ref: mergeRefs(ref, triggerRef, (node) => {\n        if (anchorRef.current == null) refs.setReference(node)\n      }),\n      onBlur: handlerAll(props.onBlur, (ev) =>\n        !contains(contentRef.current, getEventRelatedTarget(ev))\n          ? onClose()\n          : void 0,\n      ),\n      onClick: handlerAll(\n        props.onClick,\n        !open ? (!disabled && openOnClick ? onOpen : undefined) : onClose,\n      ),\n      onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n    }),\n    [contentId, disabled, onClose, onKeyDown, onOpen, open, openOnClick, refs],\n  )\n\n  const getAnchorProps: PropGetter = useCallback(\n    ({ ref, ...props } = {}) => ({\n      ...props,\n      ref: mergeRefs(ref, anchorRef, refs.setReference),\n    }),\n    [refs.setReference],\n  )\n\n  const getPositionerProps: PropGetter = useCallback(\n    (props) => {\n      return getPopperProps(props)\n    },\n    [getPopperProps],\n  )\n\n  const getContentProps: PropGetter = useCallback(\n    ({\n      ref,\n      \"aria-describedby\": ariaDescribedby,\n      \"aria-labelledby\": ariaLabelledby,\n      ...props\n    } = {}) => {\n      const hasHeader = !!getDocument()?.getElementById(headerId)\n      const hasBody = !!getDocument()?.getElementById(bodyId)\n\n      return {\n        id: contentId,\n        \"aria-describedby\": cx(ariaDescribedby, hasBody ? bodyId : undefined),\n        \"aria-hidden\": !open,\n        \"aria-labelledby\": cx(ariaLabelledby, hasHeader ? headerId : undefined),\n        \"aria-modal\": modal ? \"true\" : undefined,\n        \"data-close\": dataAttr(!open),\n        \"data-open\": dataAttr(open),\n        \"data-popup\": dataAttr(true),\n        role: \"dialog\",\n        tabIndex: -1,\n        ...props,\n        ref: mergeRefs(ref, contentRef),\n        onBlur: handlerAll(props.onBlur, onBlur),\n        onKeyDown: handlerAll(props.onKeyDown, onKeyDown),\n      }\n    },\n    [getDocument, headerId, bodyId, contentId, open, modal, onBlur, onKeyDown],\n  )\n\n  const getHeaderProps: PropGetter = useCallback(\n    (props) => ({\n      id: headerId,\n      ...props,\n    }),\n    [headerId],\n  )\n\n  const getBodyProps: PropGetter = useCallback(\n    (props) => ({\n      id: bodyId,\n      ...props,\n    }),\n    [bodyId],\n  )\n\n  const getFooterProps: PropGetter = useCallback((props) => ({ ...props }), [])\n\n  return {\n    open,\n    getAnchorProps,\n    getBodyProps,\n    getContentProps,\n    getFooterProps,\n    getHeaderProps,\n    getPositionerProps,\n    getTriggerProps,\n    onClose,\n    onOpen,\n  }\n}\n\nexport type UsePopoverReturn = ReturnType<typeof usePopover>\n\nexport const popoverProps: (\n  | keyof PopupAnimationProps\n  | keyof UsePopoverProps\n)[] = [\n  ...popperProps,\n  \"autoFocus\",\n  \"blockScrollOnMount\",\n  \"closeOnBlur\",\n  \"closeOnEsc\",\n  \"closeOnScroll\",\n  \"openOnClick\",\n  \"disabled\",\n  \"initialFocusRef\",\n  \"modal\",\n  \"updateRef\",\n  \"defaultOpen\",\n  \"onOpen\",\n  \"onClose\",\n  \"animationScheme\",\n  \"duration\",\n]\n\nexport const usePopoverProps = <\n  Y extends Dict = Dict,\n  M extends keyof PopupAnimationProps | keyof UsePopoverProps =\n    | keyof PopupAnimationProps\n    | keyof UsePopoverProps,\n>(\n  props: Y,\n  omitKeys?: M[],\n) => {\n  return useSplitProps(\n    props,\n    popoverProps.filter((key) => !omitKeys?.includes(key as M)),\n  ) as unknown as [\n    keyof PopupAnimationProps | keyof UsePopoverProps extends M\n      ? PopupAnimationProps & UsePopoverProps\n      : Omit<PopupAnimationProps & UsePopoverProps, M>,\n    Omit<\n      Y,\n      keyof PopupAnimationProps | keyof UsePopoverProps extends M\n        ? keyof PopupAnimationProps | keyof UsePopoverProps\n        : Exclude<keyof PopupAnimationProps | keyof UsePopoverProps, M>\n    >,\n  ]\n}\n"
    }
  ]
}
