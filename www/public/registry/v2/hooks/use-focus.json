{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": ["use-event-listener"],
    "providers": []
  },
  "dependents": {
    "components": ["editable", "popover"],
    "hooks": [],
    "providers": []
  },
  "section": "hooks",
  "sources": [
    {
      "name": "index.ts",
      "content": "\"use client\"\n\nimport type { RefObject } from \"react\"\nimport { useCallback, useRef } from \"react\"\nimport {\n  getActiveElement,\n  getDocument,\n  getFirstFocusableElement,\n  isRefObject,\n  isSafari,\n  useUpdateEffect,\n} from \"@yamada-ui/react\"\nimport { useEventListener } from \"../use-event-listener\"\n\nexport interface UseFocusOnShowProps {\n  focusTarget?: HTMLElement | null | RefObject<HTMLElement | null>\n  preventScroll?: boolean\n  shouldFocus?: boolean\n  visible?: boolean\n}\n\n/**\n * `useFocusOnShow` is a custom hook that focuses on the target element when it is shown.\n *\n * @see https://yamada-ui.com/docs/hooks/use-focus-on-show\n */\nexport const useFocusOnShow = <Y extends HTMLElement>(\n  refOrEl: RefObject<null | Y> | Y,\n  {\n    focusTarget: focusRefOrEl,\n    preventScroll,\n    shouldFocus,\n    visible,\n  }: UseFocusOnShowProps = {\n    preventScroll: true,\n    shouldFocus: false,\n  },\n) => {\n  const trulyShouldFocus = shouldFocus && visible\n  const focused = useRef(false)\n\n  const getTarget = useCallback(() => {\n    return isRefObject(refOrEl) ? refOrEl.current : refOrEl\n  }, [refOrEl])\n\n  const getFocusTarget = useCallback(() => {\n    return isRefObject(focusRefOrEl) ? focusRefOrEl.current : focusRefOrEl\n  }, [focusRefOrEl])\n\n  const onFocus = useCallback(() => {\n    const target = getTarget()\n\n    if (!target || !trulyShouldFocus || focused.current) return\n    if (target.contains(document.activeElement as HTMLElement)) return\n\n    const focusTarget = getFocusTarget()\n\n    if (focusTarget) {\n      requestAnimationFrame(() => {\n        focusTarget.focus({ preventScroll })\n\n        focused.current = true\n      })\n    } else {\n      const firstFocusable = getFirstFocusableElement(target)\n\n      if (firstFocusable) {\n        requestAnimationFrame(() => {\n          firstFocusable.focus({ preventScroll })\n\n          focused.current = true\n        })\n      } else {\n        requestAnimationFrame(() => {\n          target.focus({ preventScroll })\n\n          focused.current = true\n        })\n      }\n    }\n  }, [getTarget, trulyShouldFocus, getFocusTarget, preventScroll])\n\n  useUpdateEffect(() => {\n    focused.current = !trulyShouldFocus\n  }, [trulyShouldFocus])\n\n  useUpdateEffect(() => {\n    requestAnimationFrame(onFocus)\n  }, [onFocus])\n\n  useEventListener(getTarget, \"transitionend\", onFocus)\n}\n\nexport interface UseFocusOnMouseDownProps {\n  ref: RefObject<HTMLElement | null>\n  elements?: (HTMLElement | null | RefObject<HTMLElement | null>)[]\n  enabled?: boolean\n}\n\n/**\n * `useFocusOnPointerDown` is a custom hook that focuses on the target element when it is clicked.\n *\n * @see https://yamada-ui.com/docs/hooks/use-focus-on-pointer-down\n */\nexport const useFocusOnPointerDown = ({\n  ref,\n  elements,\n  enabled,\n}: UseFocusOnMouseDownProps) => {\n  useEventListener(\n    () => getDocument(ref.current),\n    \"pointerdown\",\n    (ev) => {\n      if (!isSafari() || !enabled) return\n      const target = ev.target as HTMLElement\n\n      const els = elements ?? [ref]\n\n      const validTarget = els.some((elOrRef) => {\n        const el = isRefObject(elOrRef) ? elOrRef.current : elOrRef\n\n        return el?.contains(target) || el === target\n      })\n\n      if (\n        getActiveElement(getDocument(ref.current)) !== target &&\n        validTarget\n      ) {\n        ev.preventDefault()\n\n        target.focus()\n      }\n    },\n  )\n}\n"
    }
  ]
}
