{
  "$schema": "https://yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": [],
    "externals": [],
    "hooks": [],
    "providers": []
  },
  "dependents": {
    "components": [
      "accordion",
      "airy",
      "autocomplete",
      "calendar",
      "carousel",
      "checkbox",
      "date-picker",
      "editable",
      "file-input",
      "flip",
      "menu",
      "pagination",
      "password-input",
      "pin-input",
      "radio",
      "rating",
      "rotate",
      "saturation-slider",
      "segmented-control",
      "select",
      "slider",
      "steps",
      "switch",
      "table",
      "tabs",
      "toggle"
    ],
    "hooks": [],
    "providers": []
  },
  "section": "hooks",
  "sources": [
    {
      "name": "index.ts",
      "content": "\"use client\"\n\nimport type {\n  ChangeEvent,\n  ChangeEventHandler,\n  Dispatch,\n  SetStateAction,\n} from \"react\"\nimport { useState } from \"react\"\nimport {\n  isBoolean,\n  isNull,\n  isUndefined,\n  runIfFn,\n  useCallbackRef,\n} from \"@yamada-ui/react\"\n\ninterface UseControllableStateMethods<Y> {\n  onChange?: (value: Y) => void\n  onUpdate?: (prev: Y, next: Y) => boolean\n}\n\nexport interface UseControllableStateProps<Y>\n  extends UseControllableStateMethods<Y> {\n  defaultValue?: (() => Y) | Y\n  value?: Y\n}\n\nexport function useControllableState<Y>(\n  props: UseControllableStateMethods<Y> & {\n    value: Y\n    defaultValue?: (() => Y) | Y\n  },\n): [Y, Dispatch<SetStateAction<Y>>]\n\nexport function useControllableState<Y>(\n  props: UseControllableStateMethods<Y> & {\n    defaultValue: (() => Y) | Y\n    value?: Y\n  },\n): [Y, Dispatch<SetStateAction<Y>>]\n\nexport function useControllableState<Y>(\n  props: UseControllableStateProps<Y>,\n): [Y, Dispatch<SetStateAction<Y>>]\n\nexport function useControllableState<Y>({\n  defaultValue: defaultValueProp,\n  value,\n  onChange: onChangeProp,\n  onUpdate: onUpdateProp = (prev, next) => prev !== next,\n}: UseControllableStateProps<Y>) {\n  const onChange = useCallbackRef(onChangeProp)\n  const onUpdate = useCallbackRef(onUpdateProp)\n  const [defaultValue, setDefaultValue] = useState(defaultValueProp)\n  const controlled = !isUndefined(value)\n  const currentValue = (controlled ? value : defaultValue) as Y\n\n  const setValue = useCallbackRef(\n    (next: SetStateAction<Y>) => {\n      const nextValue = runIfFn(next, currentValue)\n\n      if (!onUpdate(currentValue, nextValue)) return\n\n      if (!controlled || isUndefined(nextValue) || isNull(nextValue))\n        setDefaultValue(nextValue)\n\n      onChange(nextValue)\n    },\n    [controlled, currentValue, onChange, onUpdate],\n  )\n\n  return [currentValue, setValue]\n}\n\nfunction isHTMLInputElement(el: HTMLElement): el is HTMLInputElement {\n  return el instanceof HTMLInputElement\n}\n\ninterface UseControllableEventStateMethods<\n  Y extends HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\n> {\n  onChange?: ChangeEventHandler<Y>\n}\n\nexport interface UseControllableEventStateProps<\n  Y extends boolean | number | string,\n  M extends HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\n> extends UseControllableEventStateMethods<M> {\n  defaultValue?: (() => Y) | Y\n  value?: Y\n}\n\nexport function useControllableEventState<\n  Y extends boolean | number | string,\n  M extends HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\n>(\n  props: UseControllableEventStateMethods<M> & {\n    value: Y\n    defaultValue?: (() => Y) | Y\n  },\n): [Y, ChangeEventHandler<M>]\n\nexport function useControllableEventState<\n  Y extends boolean | number | string,\n  M extends HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\n>(\n  props: UseControllableEventStateMethods<M> & {\n    defaultValue: (() => Y) | Y\n    value?: Y\n  },\n): [Y, ChangeEventHandler<M>]\n\nexport function useControllableEventState<\n  Y extends boolean | number | string,\n  M extends HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\n>(props: UseControllableEventStateProps<Y, M>): [Y, ChangeEventHandler<M>]\n\nexport function useControllableEventState<\n  Y extends boolean | number | string,\n  M extends HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\n>({\n  defaultValue: defaultValueProp,\n  value,\n  onChange: onChangeProp,\n}: UseControllableEventStateProps<Y, M>) {\n  const onChange = useCallbackRef(onChangeProp)\n  const [defaultValue, setDefaultValue] = useState(defaultValueProp)\n  const controlled = !isUndefined(value)\n  const currentValue = (controlled ? value : defaultValue) as Y\n  const boolean = isBoolean(currentValue)\n\n  const setValue = useCallbackRef(\n    (ev: ChangeEvent<M>) => {\n      const value =\n        boolean && isHTMLInputElement(ev.target)\n          ? (ev.target.checked as Y)\n          : (ev.target.value as Y)\n\n      if (!controlled || isUndefined(value) || isNull(value)) {\n        setDefaultValue(value)\n      }\n\n      onChange(ev)\n    },\n    [controlled, currentValue, onChange],\n  )\n\n  return [currentValue, setValue]\n}\n"
    }
  ]
}
