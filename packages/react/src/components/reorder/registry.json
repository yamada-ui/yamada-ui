{
  "$schema": "https://v2.yamada-ui.com/registry/v2/schema.json",
  "dependencies": {
    "components": ["motion", "icon"],
    "externals": ["motion@12.18.1"],
    "hooks": ["use-value"],
    "providers": []
  },
  "section": "components",
  "sources": [
    {
      "name": "index.ts",
      "content": "export * from \"./reorder.style\"\nexport * as Reorder from \"./namespace\"\nexport {\n  ReorderItem,\n  ReorderPropsContext,\n  ReorderRoot,\n  ReorderTrigger,\n  useReorderPropsContext,\n} from \"./reorder\"\nexport type {\n  ReorderItemProps,\n  ReorderRootProps,\n  ReorderTriggerProps,\n} from \"./reorder\"\nexport * from \"./use-reorder\"\n"
    },
    {
      "name": "namespace.ts",
      "content": "export {\n  ReorderItem as Item,\n  ReorderPropsContext as PropsContext,\n  ReorderRoot as Root,\n  ReorderTrigger as Trigger,\n  useReorderPropsContext as usePropsContext,\n} from \"./reorder\"\nexport type {\n  ReorderItemProps as ItemProps,\n  ReorderRootProps as RootProps,\n  ReorderTriggerProps as TriggerProps,\n} from \"./reorder\"\nexport {\n  ReorderContext as Context,\n  ReorderItemContext as ItemContext,\n  useReorderContext as useContext,\n  useReorderItemContext as useItemContext,\n} from \"./use-reorder\"\n"
    },
    {
      "name": "reorder.style.ts",
      "content": "import { defineComponentSlotStyle } from \"@yamada-ui/react\"\n\nexport const reorderStyle = defineComponentSlotStyle({\n  base: {\n    item: {\n      \"&[data-has-trigger]\": {\n        cursor: \"default\",\n        userSelect: \"none\",\n      },\n      cursor: \"grab\",\n      flex: \"1\",\n      rounded: \"l2\",\n      _selected: {\n        boxShadow: \"md\",\n        cursor: \"grabbing\",\n      },\n    },\n    root: {\n      display: \"flex\",\n      w: \"full\",\n    },\n    trigger: {\n      alignItems: \"center\",\n      color: \"fg.subtle\",\n      cursor: \"grab\",\n      display: \"flex\",\n      fontSize: \"2xl\",\n      justifyContent: \"center\",\n      _selected: {\n        cursor: \"grabbing\",\n      },\n      _disabled: {\n        layerStyle: \"disabled\",\n      },\n    },\n  },\n\n  sizes: {\n    sm: {\n      item: { p: \"3\" },\n      root: { gap: \"3\" },\n    },\n    md: {\n      item: { p: \"4\" },\n      root: { gap: \"4\" },\n    },\n    lg: {\n      item: { p: \"6\" },\n      root: { gap: \"6\" },\n    },\n    xl: {\n      item: { p: \"8\" },\n      root: { gap: \"8\" },\n    },\n  },\n\n  variants: {\n    elevated: {\n      item: {\n        bg: \"bg.panel\",\n        boxShadow: \"md\",\n        _selected: {\n          boxShadow: \"lg\",\n        },\n      },\n    },\n    outline: {\n      item: {\n        layerStyle: \"outline\",\n        bg: \"bg\",\n      },\n    },\n    panel: {\n      item: {\n        layerStyle: \"panel\",\n      },\n    },\n    plain: {\n      item: {\n        flex: \"inherit\",\n        p: \"0px\",\n        rounded: \"0px\",\n        _selected: { boxShadow: \"unset\" },\n      },\n      root: { gap: \"0px\" },\n    },\n    solid: {\n      item: {\n        layerStyle: \"solid\",\n      },\n    },\n    subtle: {\n      item: {\n        layerStyle: \"subtle\",\n      },\n    },\n    surface: {\n      item: {\n        layerStyle: \"surface\",\n      },\n    },\n  },\n\n  props: {\n    /**\n     * The orientation of the reorder.\n     *\n     * @default 'vertical'\n     */\n    orientation: {\n      horizontal: {\n        root: {\n          flexDirection: \"row\",\n        },\n      },\n      vertical: {\n        root: {\n          alignItems: \"stretch\",\n          flexDirection: \"column\",\n        },\n      },\n    },\n  },\n\n  defaultProps: {\n    size: \"md\",\n    variant: \"panel\",\n    orientation: \"vertical\",\n  },\n})\n\nexport type ReorderStyle = typeof reorderStyle\n"
    },
    {
      "name": "reorder.tsx",
      "content": "\"use client\"\n\nimport type { PropsWithChildren, ReactElement } from \"react\"\nimport type {\n  GenericsComponent,\n  HTMLStyledProps,\n  ThemeProps,\n  Merge,\n} from \"@yamada-ui/react\"\nimport type { HTMLMotionProps } from \"../motion\"\nimport type { ReorderStyle } from \"./reorder.style\"\nimport type { UseReorderItemProps, UseReorderProps } from \"./use-reorder\"\nimport { Reorder as OriginalReorder } from \"motion/react\"\nimport { createSlotComponent, styled } from \"@yamada-ui/react\"\nimport { useValue } from \"../../hooks/use-value\"\nimport { GripVerticalIcon } from \"../icon\"\nimport { reorderStyle } from \"./reorder.style\"\nimport {\n  ReorderContext,\n  ReorderItemContext,\n  useReorder,\n  useReorderItem,\n  useReorderItemContext,\n} from \"./use-reorder\"\n\nexport interface ReorderRootProps<Y = string>\n  extends Merge<\n      HTMLMotionProps<\"ul\">,\n      Omit<UseReorderProps<Y>, \"item\" | \"items\" | \"orientation\">\n    >,\n    ThemeProps<ReorderStyle> {\n  /**\n   * If provided, generate reorder items based on items.\n   *\n   */\n  items?: ReorderItemProps<Y>[]\n}\n\nconst {\n  PropsContext: ReorderPropsContext,\n  usePropsContext: useReorderPropsContext,\n  withContext,\n  withProvider,\n} = createSlotComponent<ReorderRootProps, ReorderStyle>(\"reorder\", reorderStyle)\n\nexport { ReorderPropsContext, useReorderPropsContext }\n\n/**\n * `Reorder` is a component that allows you to change the order of items using drag and drop.\n *\n * @see https://yamada-ui.com/components/reorder\n */\nexport const ReorderRoot = withProvider<\"ul\", ReorderRootProps>(\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-constraint\n  <Y extends any = string>(props: ReorderRootProps<Y>) => {\n    const orientation = useValue(props.orientation)\n    const { children, getRootProps } = useReorder({\n      ...props,\n      item: <ReorderItem />,\n      orientation,\n    })\n\n    return (\n      <ReorderContext value={{ orientation }}>\n        <styled.ul\n          as={OriginalReorder.Group<Y>}\n          {...(getRootProps() as HTMLStyledProps<\"ul\">)}\n        >\n          {children}\n        </styled.ul>\n      </ReorderContext>\n    )\n  },\n  \"root\",\n  { transferProps: [\"orientation\"] },\n)() as GenericsComponent<{\n  <Y = string>(props: ReorderRootProps<Y>): ReactElement\n}>\n\nexport interface ReorderItemProps<Y = string>\n  extends Omit<\n      Merge<HTMLMotionProps<\"li\">, UseReorderItemProps<Y>>,\n      \"children\"\n    >,\n    PropsWithChildren {}\n\nexport const ReorderItem = withContext<\"li\", ReorderItemProps>(\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-constraint\n  <Y extends any = string>(props: ReorderItemProps<Y>) => {\n    const { getItemProps, getTriggerProps } = useReorderItem(props)\n\n    return (\n      <ReorderItemContext value={{ getTriggerProps }}>\n        <styled.li\n          as={OriginalReorder.Item<Y>}\n          {...(getItemProps() as HTMLStyledProps<\"li\">)}\n        />\n      </ReorderItemContext>\n    )\n  },\n  \"item\",\n)() as GenericsComponent<{\n  <Y = string>(props: ReorderItemProps<Y>): ReactElement\n}>\n\nexport interface ReorderTriggerProps extends HTMLStyledProps {}\n\nexport const ReorderTrigger = withContext<\"div\", ReorderTriggerProps>(\n  \"div\",\n  \"trigger\",\n)(undefined, (props) => {\n  const { getTriggerProps } = useReorderItemContext()\n\n  return { children: <GripVerticalIcon />, ...getTriggerProps(props) }\n})\n"
    },
    {
      "name": "use-reorder.ts",
      "content": "\"use client\"\n\nimport type { HTMLMotionProps, Reorder } from \"motion/react\"\nimport type { PropsWithChildren, ReactElement, ReactNode } from \"react\"\nimport type { Orientation, PropGetter, Dict, Merge } from \"@yamada-ui/react\"\nimport { useDragControls, useMotionValue } from \"motion/react\"\nimport {\n  cloneElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport {\n  createContext,\n  dataAttr,\n  handlerAll,\n  isArray,\n  isObject,\n  mergeRefs,\n  useUpdateEffect,\n  useValidChildren,\n} from \"@yamada-ui/react\"\n\nconst getAlternativeValue = ({ children, label }: Dict = {}) =>\n  serializeValue(children ?? label)\n\nconst serializeValue = (value: any) =>\n  isObject(value) || isArray(value) ? JSON.stringify(value) : value\n\ntype ReorderGroupProps<Y = string> = Merge<\n  HTMLMotionProps<\"ul\">,\n  Pick<Parameters<typeof Reorder.Group<Y>>[0], \"axis\" | \"onReorder\" | \"values\">\n>\ntype ReorderItemProps<Y = string> = Merge<\n  HTMLMotionProps<\"li\">,\n  Partial<Pick<Parameters<typeof Reorder.Item<Y>>[0], \"layout\" | \"value\">>\n>\n\ninterface ReorderContext extends Pick<UseReorderProps, \"orientation\"> {}\n\nconst [ReorderContext, useReorderContext] = createContext<ReorderContext>({\n  name: \"ReorderContext\",\n})\n\nexport { ReorderContext, useReorderContext }\n\ninterface ReorderItemContext {\n  getTriggerProps: PropGetter\n}\n\nconst [ReorderItemContext, useReorderItemContext] =\n  createContext<ReorderItemContext>({\n    name: \"ReorderItemContext\",\n  })\n\nexport { ReorderItemContext, useReorderItemContext }\n\nexport interface UseReorderProps<Y = string>\n  extends Partial<\n      Omit<ReorderGroupProps<Y>, \"children\" | \"onChange\" | \"values\">\n    >,\n    PropsWithChildren {\n  /**\n   * The component to be used for the item.\n   */\n  item?: ReactElement<any>\n  /**\n   * If provided, generate reorder items based on items.\n   *\n   */\n  items?: UseReorderItemProps<Y>[]\n  /**\n   * The orientation of the reorder.\n   *\n   * @default 'vertical'\n   */\n  orientation?: Orientation\n  /**\n   * The callback invoked when reorder items are moved.\n   */\n  onChange?: (values: Y[]) => void\n  /**\n   * The callback invoked when the movement of reorder items is completed.\n   */\n  onCompleteChange?: (values: Y[]) => void\n}\n\nexport const useReorder = <Y = string,>({\n  ref,\n  children,\n  item,\n  items = [],\n  orientation = \"vertical\",\n  onChange,\n  onCompleteChange,\n  ...rest\n}: UseReorderProps<Y> = {}) => {\n  const axis = orientation === \"vertical\" ? \"y\" : \"x\"\n  const validChildren = useValidChildren(children)\n  const hasChildren = !!validChildren.length\n  const defaultValues = useMemo(() => {\n    const values = hasChildren\n      ? validChildren.map(\n          ({ props }) => props.value ?? getAlternativeValue(props),\n        )\n      : items.map((props) => props.value ?? getAlternativeValue(props))\n\n    const duplicatedValues = values.filter(\n      (value, index, self) =>\n        self.indexOf(value) === index && index !== self.lastIndexOf(value),\n    )\n\n    if (duplicatedValues.length)\n      console.warn(\n        `Reorder: 'value' of 'ReorderItem' must not be duplicated. duplicate 'value' is '${duplicatedValues.join(\n          `', '`,\n        )}' `,\n      )\n\n    return Array.from(new Set(values))\n  }, [hasChildren, validChildren, items])\n  const childMap = useMemo(() => {\n    return Object.fromEntries(\n      validChildren.map((child) => [\n        serializeValue(child.props.value) ??\n          serializeValue(getAlternativeValue(child.props)),\n        child,\n      ]),\n    )\n  }, [validChildren])\n  const itemMap = useMemo(() => {\n    return Object.fromEntries(\n      items.map((props) => [\n        serializeValue(props.value) ??\n          serializeValue(getAlternativeValue(props)),\n        props,\n      ]),\n    )\n  }, [items])\n  const prevDefaultValues = useRef<Y[]>(defaultValues)\n  const [values, setValues] = useState<Y[]>(defaultValues)\n  const prevValues = useRef<Y[]>(defaultValues)\n  const cloneChildren = useMemo(\n    () =>\n      values.map((value) => {\n        if (hasChildren) {\n          return childMap[serializeValue(value)]\n        } else {\n          const props = itemMap[serializeValue(value)]\n\n          return props && item\n            ? cloneElement(item, { key: serializeValue(props.value), ...props })\n            : null\n        }\n      }),\n    [values, hasChildren, childMap, itemMap, item],\n  )\n\n  const onReorder = useCallback(\n    (newValues: Y[]) => {\n      setValues(newValues)\n\n      onChange?.(newValues)\n    },\n    [onChange],\n  )\n\n  const onCompleteReorder = useCallback(() => {\n    const equal = JSON.stringify(prevValues.current) === JSON.stringify(values)\n\n    if (equal) return\n\n    prevValues.current = values\n\n    onCompleteChange?.(values)\n  }, [onCompleteChange, values])\n\n  useUpdateEffect(() => {\n    const equal =\n      JSON.stringify(defaultValues) ===\n      JSON.stringify(prevDefaultValues.current)\n\n    if (equal) return\n\n    prevValues.current = defaultValues\n    prevDefaultValues.current = defaultValues\n\n    setValues(defaultValues)\n  }, [defaultValues])\n\n  const getRootProps: PropGetter<\n    Partial<Omit<ReorderGroupProps<Y>, \"values\">>,\n    undefined,\n    ReorderGroupProps<Y>\n  > = useCallback(\n    (props = {}) => ({\n      axis,\n      values,\n      ...rest,\n      ...props,\n      ref: mergeRefs(props.ref, ref),\n      onMouseUp: handlerAll(props.onMouseUp, rest.onMouseUp, onCompleteReorder),\n      onReorder: handlerAll(props.onReorder, rest.onReorder, onReorder),\n      onTouchEnd: handlerAll(\n        props.onTouchEnd,\n        rest.onTouchEnd,\n        onCompleteReorder,\n      ),\n    }),\n    [rest, ref, onCompleteReorder, onReorder, axis, values],\n  )\n\n  return { children: cloneChildren, orientation, values, getRootProps }\n}\n\nexport type UseReorderReturn<Y = string> = ReturnType<typeof useReorder<Y>>\n\nexport interface UseReorderItemProps<Y = string> extends ReorderItemProps<Y> {\n  /**\n   * The label of the reorder item.\n   */\n  label?: ReactNode\n  /**\n   * The value of the reorder item.\n   */\n  value?: Y\n}\n\nexport const useReorderItem = <Y = string,>({\n  ref,\n  label,\n  value,\n  ...rest\n}: UseReorderItemProps<Y>) => {\n  const { orientation } = useReorderContext()\n  const dragControls = useDragControls()\n  const [hasTrigger, setHasTrigger] = useState<boolean>(false)\n  const [drag, setDrag] = useState<boolean>(false)\n  const x = useMotionValue(0)\n  const y = useMotionValue(0)\n\n  const register = useCallback(\n    (node: HTMLElement | null) => setHasTrigger(!!node),\n    [],\n  )\n\n  useEffect(() => {\n    const unsubscribeX = x.on(\"change\", (x) => {\n      if (orientation === \"horizontal\") setDrag(x !== 0)\n    })\n    const unsubscribeY = y.on(\"change\", (y) => {\n      if (orientation === \"vertical\") setDrag(y !== 0)\n    })\n\n    return () => {\n      unsubscribeX()\n      unsubscribeY()\n    }\n  }, [orientation, x, y])\n\n  const getItemProps: PropGetter<\n    Omit<HTMLMotionProps<\"li\">, \"layout\" | \"value\"> &\n      Pick<ReorderItemProps<Y>, \"layout\">,\n    undefined,\n    ReorderItemProps<Y>\n  > = useCallback(\n    (props = {}) => {\n      const children = props.children ?? rest.children ?? label\n\n      return {\n        \"data-has-trigger\": dataAttr(hasTrigger),\n        \"data-selected\": dataAttr(drag),\n        dragControls,\n        dragListener: !hasTrigger,\n        value: value ?? getAlternativeValue({ children }),\n        ...props,\n        ...rest,\n        ref: mergeRefs(props.ref, ref),\n        style: { x, y, ...props.style, ...rest.style },\n        children,\n      }\n    },\n    [ref, rest, dragControls, hasTrigger, value, x, y, drag, label],\n  )\n\n  const getTriggerProps: PropGetter = useCallback(\n    (props = {}) => ({\n      ...props,\n      ref: mergeRefs(register, props.ref),\n      \"data-selected\": dataAttr(drag),\n      onPointerDown: handlerAll(props.onPointerDown, (ev) =>\n        dragControls.start(ev),\n      ),\n    }),\n    [drag, dragControls, register],\n  )\n\n  return { getItemProps, getTriggerProps }\n}\n\nexport type UseReorderItemReturn<Y = string> = ReturnType<\n  typeof useReorderItem<Y>\n>\n"
    }
  ]
}
